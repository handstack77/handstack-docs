---
marp: true
theme: gaia
_class: lead
footer: QCN
paginate: true
backgroundColor: #fff
---

<style>
:root {
  font-family: Pretendard;
  --border-color: #303030;
  --text-color: #0a0a0a;
  --bg-color-alt: #dadada;
  --mark-background: #ffef92;
}

h1 {
  border-bottom: none;
  font-size: 1.6em;
}

h2 {
  border-bottom: none;
  font-size: 1.3em;
}

h3 {
  font-size: 1.1em;
}

h4 {
  font-size: 1.05em;
}

h5 {
  font-size: 1em;
}

h6 {
  font-size: 0.9em;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  color: var(--text-color);
}

code:not([class*="language-"]) {
  font-family: D2Coding;
  color: #000;
  vertical-align: text-bottom;
  background-color: rgba(100, 100, 100, 0.2);
}

section {
  padding: 1rem;
  border-bottom: 1px solid #000;
  background-image: linear-gradient(to bottom right, #f7f7f7 0%, #d3d3d3 100%);
}

section > h2 {
  border-bottom: 4px solid #17344f;
}

section table {
    margin: auto;
    margin-top: 1rem;
    font-size: 28px;
}

section::after {
  font-size: 0.75em;
  content: attr(data-marpit-pagination) " / " attr(data-marpit-pagination-total);
}

img[alt~="center"] {
  display: block;
  margin: 0 auto;
}

blockquote {
  font-size: 26px;
  border-left: 8px solid var(--border-color);
  background: var(--bg-color-alt);
  margin: 0.5em;
  padding: 0.5em;
}

blockquote::before,
blockquote::after {
    content: '';
}

mark {
  background-color: var(--mark-background);
  padding: 0 2px 2px;
  border-radius: 4px;
  margin: 0 2px;
}

section.tinytext>p,
section.tinytext>ul,
section.tinytext>blockquote {
  font-size: 0.65em;
}
</style>

# 클라이언트와 서버 데이터 연동 (거래) 테스트

### 화면과 서버의 CRUD 요청 및 데이터 바인딩 알아보기

---

## 오늘의 목표

- 클라이언트(화면)와 서버가 데이터를 주고받는 '거래'의 개념을 이해합니다.
- HandStack에서 제공하는 두 가지 거래 방식의 차이를 알아봅니다.
- 거래에 필요한 요청/응답 정보 정의 방법을 학습합니다.
- 거래 전후에 특정 로직을 실행하는 'Hook 이벤트'를 알아봅니다.
- 실제 데이터 연동 과정을 실습하여 자신감을 얻습니다.

---

## 거래 방식: 어떻게 통신할까?

HandStack은 두 가지 거래 방식을 제공하여 유연한 개발을 지원합니다.

- `선언 거래`
  - HTML 태그 속성에 거래 정보를 정의하는 방식입니다.
  - 코딩 없이 간단하게 데이터 조회 기능을 구현할 때 유용합니다.
  - 예: `<div syn-trcode="S01,Form" syn-autrun="true">`

- `직접 거래`
  - 자바스크립트 코드 내에서 `syn.transaction.run` 함수를 호출하는 방식입니다.
  - 복잡한 조건 처리나 동적 데이터 구성이 필요할 때 사용합니다.
  - 예: `syn.transaction.run(this, 'I01,Row');`

---

## 거래 정보 정의: 무엇을 주고받을까?

거래 정보는 `입력,출력` 형식으로 정의하며, 콤마(,)로 구분합니다.

- `입력 정보` (클라이언트 👉 서버)
  - `Row`: 단일 건의 데이터 (예: 입력 폼 하나의 정보)
  - `List`: 여러 건의 데이터 (예: 그리드의 변경된 행 목록)

- `출력 정보` (서버 👉 클라이언트)
  - `Form`: 단일 건의 데이터 (예: 상세 조회 결과)
  - `Grid`: 여러 건의 데이터 (예: 목록 조회 결과)

- 조합 예시
  - `Row,Form`: 단일 건을 보내고 단일 건을 받음 (저장 후 상세조회)
  - `List,Grid`: 목록을 보내고 목록을 받음 (다수 항목 상태 변경)

---

## 거래 Hook 이벤트: 언제 개입할까?

거래의 특정 시점에 실행할 함수를 미리 정의하여 로직을 추가할 수 있습니다.

- `beforeTransaction`
  - 서버로 거래를 요청하기 직전에 호출됩니다.
  - 주로 입력값 유효성 검사, 데이터 전처리, 사용자 확인 창 표시에 사용됩니다.
  - 이 함수에서 `false`를 반환하면 거래 실행이 중단됩니다.

- `afterTransaction`
  - 서버로부터 응답을 받은 직후에 호출됩니다.
  - 주로 응답 데이터 후처리, 특정 UI 상태 변경, 결과 메시지 표시에 사용됩니다.

---

## 화면 요소와 데이터 바인딩

`syn-datafield` 속성을 사용하면 HTML 요소를 데이터와 쉽게 연결할 수 있습니다.

- 서버에서 받은 `formData` 또는 `gridData`의 Key 값과 `syn-datafield` 값이 일치하는 요소에 자동으로 값이 채워집니다.
- 서버로 보낼 때도 마찬가지로 해당 요소의 값을 자동으로 가져가 `rowData` 또는 `listData`를 구성합니다.

- 예제
  - `USER_ID`라는 Key를 가진 데이터를 아래 입력 상자와 연결합니다.
```html
<input type="text" syn-datafield="USER_ID" />
```
  - `USER_NAME`이라는 Key를 가진 데이터를 아래 `<span>` 태그와 연결합니다.
```html
<span syn-datafield="USER_NAME"></span>
```

---

## 거래 로직 구현 구조

페이지별 자바스크립트 파일에 `hook`과 `transaction` 객체를 정의하여 거래 관련 로직을 관리합니다.

```javascript
'use strict';
// 페이지별 전역 객체 (예: TST010.html -> $TST010)
let $TST010 = {
    // life cycle, 외부 이벤트 hook 선언
    hook: {
        // beforeTransaction, afterTransaction 등 Hook 함수를 이곳에 정의
    },

    // 거래 메서드 선언
    transaction: {
        // 조회, 저장 등 버튼 클릭 시 호출될 거래 함수들을 이곳에 정의
        search: function () {
            syn.transaction.run(this, 'S01,Grid');
        }
    },
};
```
---

## 요청 정보 프로토콜 (Client → Server)

클라이언트가 서버로 거래를 요청할 때 보내는 데이터 구조의 주요 항목입니다.

- `TRCODE`: 거래 ID (예: `TST010_S01`)
- `EXECUTE_ID`: 서버에서 실행할 비즈니스 로직 ID (SQL 파일명 또는 함수명)
- `rowData`: `Row` 타입으로 정의된 입력 데이터 (JSON Object)
- `listData`: `List` 타입으로 정의된 입력 데이터 (JSON Array)
- `parameters`: 기타 필요한 파라미터

---

## 응답 정보 프로토콜 (Server → Client)

서버가 클라이언트의 요청을 처리한 후 보내주는 데이터 구조의 주요 항목입니다.

- `resultCode`: 처리 결과 코드 (`S`: 성공, `E`: 실패)
- `resultMessage`: 처리 결과 메시지
- `formData`: `Form` 타입으로 정의된 출력 데이터 (JSON Object)
- `gridData`: `Grid` 타입으로 정의된 출력 데이터 (JSON Array)
- `totalCount`: `Grid` 데이터의 전체 개수 (페이징 처리에 사용)

---

## 더미(Dummy) 데이터로 프론트엔드 테스트하기

백엔드 API가 준비되지 않았을 때, `dummyfile` 설정을 통해 프론트엔드 개발을 미리 진행할 수 있습니다.

- 프로젝트의 `syn.config.json` 파일에 `transact` 모듈 설정을 추가합니다.

```json
{
  "modules": {
    "transact": {
      "dummyfile": true
    }
  }
}
```

- `dummyfile`을 `true`로 설정하면, HandStack은 서버 요청 대신 프로젝트 내의 더미 데이터 파일을 찾아 응답을 시뮬레이션합니다.
- 더미 파일 경로: `/dummy/{거래ID}.json` (예: `/dummy/TST010_S01.json`)

---

## 핸즈온: 데이터 연동 실습

이제 직접 화면과 서버의 데이터 연동 과정을 체험해 봅시다.

- 1단계: 페이지 자바스크립트 파일에 거래(transaction) 함수 정의하기
- 2단계: HTML 요소에 `syn-datafield` 속성으로 데이터 Key 연결하기
- 3단계: 조회 버튼에 `onclick` 이벤트를 연결하여 거래 함수 호출하기
- 4단계: `beforeTransaction` Hook으로 조회 전 조건을, `afterTransaction` Hook으로 조회 후 결과를 확인하기
- 5단계: 브라우저에서 버튼을 클릭하고 개발자 도구(F12) 네트워크 탭에서 실제 통신 데이터 확인하기

---

## 마무리

이제 서버와 연동하는 기능을 담은 화면을 직접 만들 수 있게 되었네요! 점점 더 웹 개발이 재미있어지지 않나요?

- HandStack의 거래 기능을 통해 복잡한 서버 통신을 간단하게 처리하는 방법을 배웠습니다.
- 선언적 방식과 직접 호출 방식을 적절히 사용하여 생산성을 높일 수 있습니다.
