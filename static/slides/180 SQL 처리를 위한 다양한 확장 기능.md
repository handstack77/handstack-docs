---
marp: true
theme: gaia
_class: lead
footer: QCN
paginate: true
backgroundColor: #fff
---

<style>
:root {
  font-family: Pretendard;
  --border-color: #303030;
  --text-color: #0a0a0a;
  --bg-color-alt: #dadada;
  --mark-background: #ffef92;
}

h1 {
  border-bottom: none;
  font-size: 1.6em;
}

h2 {
  border-bottom: none;
  font-size: 1.3em;
}

h3 {
  font-size: 1.1em;
}

h4 {
  font-size: 1.05em;
}

h5 {
  font-size: 1em;
}

h6 {
  font-size: 0.9em;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  color: var(--text-color);
}

code:not([class*="language-"]) {
  font-family: D2Coding;
  color: #000;
  vertical-align: text-bottom;
  background-color: rgba(100, 100, 100, 0.2);
}

section {
  background-image: linear-gradient(to bottom right, #f7f7f7 0%, #d3d3d3 100%);
}

section table {
    margin: auto;
    font-size: 28px;
}

section::after {
  font-size: 0.75em;
  content: attr(data-marpit-pagination) " / " attr(data-marpit-pagination-total);
}

img[alt~="center"] {
  display: block;
  margin: 0 auto;
}

blockquote {
  font-size: 26px;
  border-left: 8px solid var(--border-color);
  background: var(--bg-color-alt);
  margin: 0.5em;
  padding: 0.5em;
}

blockquote::before,
blockquote::after {
    content: '';
}

mark {
  background-color: var(--mark-background);
  padding: 0 2px 2px;
  border-radius: 4px;
  margin: 0 2px;
}

section.tinytext>p,
section.tinytext>ul,
section.tinytext>blockquote {
  font-size: 0.65em;
}
</style>



# SQL 처리를 위한 다양한 확장 기능

데이터베이스 SQL 처리를 위한 표준/네이티브 매개변수 바인딩과
다양한 확장 기능을 알아봅니다.

---

## SQL 매개변수 바인딩

HandStack은 데이터베이스가 제공하는 네이티브 매개변수 바인딩을 기본으로 사용합니다. 이는 SQL Injection 공격을 방어하는 가장 기본적인 방법입니다.

- `@` 접두사: 표준적인 SQL 매개변수 표기법
- `: ` 접두사: Oracle 등에서 사용하는 표기법
- `?` : 순서 기반 매개변수 표기법

```xml
<query>
  SELECT UserID, UserName
  FROM   Users
  WHERE  UserID = @UserID
</query>
```
- 위 예제에서 `@UserID`는 외부에서 전달된 `UserID` 값으로 안전하게 치환됩니다.

---

## 문자열 변수 치환: `${...}` 와 `#{...}`

동적 테이블명, 컬럼명 또는 `LIKE` 구문 등 매개변수 바인딩이 불가능한 경우 문자열 치환을 사용합니다.

- `${...}`: 따옴표 없이 변수 값을 그대로 치환합니다.
- `#{...}`: 변수 값을 문자열로 간주하여 따옴표로 감싸 치환합니다.

```xml
<query>
  SELECT UserID, UserName
  FROM   Users
  WHERE  UserName LIKE '%' + #{KEYWORD} + '%'
</query>
```
```xml
<query>
  SELECT UserID, UserName, Email
  FROM   ${TABLE_NAME}
  WHERE  Status = 'Active'
</query>
```
- <mark>보안에 유의하여 사용해야 합니다.</mark>

---

## 로그인 세션 매개변수 사용

로그인한 사용자의 세션 정보(예: 사용자 ID, 부서 코드)를 SQL 쿼리에서 직접 사용할 수 있습니다.

- 세션 변수는 `Session.` 접두사를 사용하여 접근합니다.
- 컨트롤러나 비즈니스 로직에서 세션 값을 매번 전달할 필요가 없어 코드가 간결해집니다.

```xml
<query>
  INSERT INTO Posts (Title, Content, CreatedBy)
  VALUES (@Title, @Content, @Session.UserID)
</query>
```
```xml
<query>
  SELECT *
  FROM   Projects
  WHERE  DepartmentID = @Session.DepartmentID
</query>
```

---

## 전처리 변수 추가: `<pretreatment>`

SQL 실행 전에 특정 쿼리를 먼저 실행하고, 그 결과를 다음 쿼리의 매개변수로 사용할 수 있습니다.

- `resultType="Row"`: 단일 행 결과를 반환하여 각 컬럼을 변수로 사용합니다.
- `resultType="Value"`: 단일 값(Scalar)을 반환하여 지정된 변수명으로 사용합니다.

```xml
<!-- 특정 코드 값의 상세 정보를 먼저 조회하여 변수로 활용 -->
<pretreatment resultType="Row">
  SELECT MinorCode AS ProcessStatus, MinorName AS ProcessStatusName
  FROM   CommonCode
  WHERE  MajorCode = 'STATUS' AND MinorCode = @StatusCode
</pretreatment>
<query>
  UPDATE Orders
  SET    Status = @ProcessStatus, StatusName = @ProcessStatusName
  WHERE  OrderID = @OrderID
</query>
```

---

## 치환 변수 추가: `<bind>`

기존 변수들을 조합하거나 가공하여 새로운 변수를 만들어 SQL 내에서 사용할 수 있습니다.

- 복잡한 표현식을 XML 내에서 처리하여 SQL을 더 간결하게 유지할 수 있습니다.

```xml
<!-- 날짜 검색을 위해 시작일과 종료일을 동적으로 생성 -->
<bind name="SearchStart" value="StartDate + ' 00:00:00'" />
<bind name="SearchEnd" value="EndDate + ' 23:59:59'" />
<query>
  SELECT *
  FROM   EventLogs
  WHERE  EventTime BETWEEN @SearchStart AND @SearchEnd
</query>
```

---

## 동적 쿼리: `<if>` 조건문

조건에 따라 SQL 구문을 동적으로 추가하거나 변경할 수 있습니다. 검색 조건이 다양한 경우에 매우 유용합니다.

- `test` 속성에 JavaScript와 유사한 조건식을 사용합니다.

```xml
<query>
  SELECT * FROM Products
  WHERE 1 = 1
  <if test="(Keyword != '')">
    AND ProductName LIKE '%' + #{Keyword} + '%'
  </if>
  <if test="(CategoryID > 0)">
    AND CategoryID = @CategoryID
  </if>
</query>
```
- `WHERE 1=1`은 모든 `AND` 조건이 `if` 태그 안에 있을 때 발생하는 구문 오류를 방지하는 일반적인 트릭입니다.

---

## 동적 쿼리: `<foreach>` 반복문

배열이나 리스트 형태의 매개변수를 처리할 때 사용합니다. `IN` 절을 동적으로 생성하는 데 효과적입니다.

- `collection`: 반복할 대상 매개변수 (배열)
- `item`: 각 반복에서의 현재 요소 변수명
- `open`, `close`, `separator`: 반복문의 시작, 끝, 구분자 문자열

```xml
<query>
  SELECT *
  FROM   Users
  WHERE  UserID IN
  <foreach collection="UserIDs" item="id" open="(" close=")" separator=",">
    @id
  </foreach>
</query>
```

---

## 초기값 및 변환값 설정: `<param>`

매개변수에 대한 초기값을 설정하거나, 특정 규칙에 따라 값을 변환할 수 있습니다.

- `<param value="@KEYWORD">`: `KEYWORD` 매개변수가 없을 경우 기본값을 설정합니다.
- `<param transform="@KEYWORD">`: `KEYWORD` 매개변수 값을 특정 형식으로 변환합니다.

```xml
<transaction>
  <!-- KEYWORD가 비어 있으면 '%'를 기본값으로 사용 -->
  <param value="@KEYWORD">%</param>
  <!-- SEARCH_TYPE 값을 대문자로 변환 -->
  <param transform="@SEARCH_TYPE">upper</param>
  <query>
    SELECT * FROM Board
    WHERE  ${SEARCH_TYPE} LIKE '%' + #{KEYWORD} + '%'
  </query>
</transaction>
```

---

## 핸즈온: 쿼리 테스트 및 XML 작성

1. **SSMS에서 쿼리 테스트**
   - SQL Server Management Studio 같은 데이터베이스 클라이언트 도구를 엽니다.
   - 만들고 싶은 기능의 SQL 쿼리를 직접 작성하고 실행하며 원하는 결과가 나오는지 테스트합니다.
   - 동적 조건이 필요한 부분은 주석으로 표기하며 여러 케이스를 테스트합니다.

2. **HandStack XML 쿼리로 변환**
   - 테스트가 완료된 SQL을 `dbclient`의 XML 파일로 옮깁니다.
   - 동적으로 처리했던 부분을 `<if>`, `<foreach>` 등의 태그를 사용하여 변경합니다.
   - 매개변수는 `@` 표기법으로 바꾸고, 필요한 경우 `<bind>`, `<param>` 등을 추가하여 쿼리를 완성합니다.

---

## 결론: 생산성을 위한 약속

> Mybatis의 장점과 데이터베이스 중심의 업무 처리 노하우를 활용하는 HandStack이 약속하는 개발 생산성입니다.

- <mark>안전한 매개변수 바인딩</mark>을 기본으로 제공합니다.
- <mark>동적 SQL</mark>을 XML 내에서 선언적으로 쉽게 작성할 수 있습니다.
- SQL과 비즈니스 로직의 <mark>관심사를 분리</mark>하여 유지보수성을 높입니다.
- 복잡한 데이터 처리 로직을 <mark>SQL에 집중</mark시켜 애플리케이션 코드를 단순하게 유지합니다.

