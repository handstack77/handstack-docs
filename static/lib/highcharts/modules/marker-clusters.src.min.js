!function(e){"object"==typeof module&&module.exports?module.exports=e.default=e:"function"==typeof define&&define.amd?define("highcharts/modules/marker-clusters",["highcharts"],function(t){return e(t),e.Highcharts=t,e}):e("undefined"!=typeof Highcharts?Highcharts:void 0)}(function(a){"use strict";var t=a?a._modules:{};function e(t,e,r,s){t.hasOwnProperty(e)||(t[e]=s.apply(null,r),"function"==typeof CustomEvent&&a.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded",{detail:{path:e,module:t[e]}})))}e(t,"Extensions/MarkerClusters/MarkerClusterDefaults.js",[],function(){return{cluster:{enabled:!1,allowOverlap:!0,animation:{duration:500},drillToCluster:!0,minimumClusterSize:2,layoutAlgorithm:{gridSize:50,distance:40,kmeansThreshold:100},marker:{symbol:"cluster",radius:15,lineWidth:0,lineColor:"#ffffff"},dataLabels:{enabled:!0,format:"{point.clusterPointsAmount}",verticalAlign:"middle",align:"center",style:{color:"contrast"},inside:!0}},tooltip:{clusterFormat:"<span>Clustered points: {point.clusterPointsAmount}</span><br/>"}}}),e(t,"Extensions/MarkerClusters/MarkerClusterScatter.js",[t["Core/Animation/AnimationUtilities.js"],t["Extensions/MarkerClusters/MarkerClusterDefaults.js"],t["Core/Utilities.js"]],function(t,s,e){const k=t["animObject"],E=s["cluster"],{addEvent:P,defined:j,error:b,isArray:A,isFunction:z,isObject:X,isNumber:w,merge:Y,objectEach:a,relativeLength:O,syncTimeout:M}=e,o={grid:function(t,e,r,s){const a={},o=this.getGridOffset();let i,n,l,p,u;var d=this.getScaledGridSize(s);for(u=0;u<t.length;u++){var c=F(this,{x:t[u],y:e[u]});i=c.x-o.plotLeft,n=c.y-o.plotTop,l=Math.floor(i/d),p=Math.floor(n/d)+"-"+l,a[p]||(a[p]=[]),a[p].push({dataIndex:r[u],x:t[u],y:e[u]})}return a},kmeans:function(e,r,s,t){const a=this,o=[],i=[],n={},l=t.processedDistance||E.layoutAlgorithm.distance,p=t.iterations;let u=0,d=!0,c,h,f,m=[];t.processedGridSize=t.processedDistance;var g=a.markerClusterAlgorithms?a.markerClusterAlgorithms.grid.call(a,e,r,s,t):{};for(const x in g)1<g[x].length&&(f=V(g[x]),o.push({posX:f.x,posY:f.y,oldX:0,oldY:0,startPointsLen:g[x].length,points:[]}));for(;d;){for(const y of o)y.points.length=0;for(let t=i.length=0;t<e.length;t++)c=e[t],h=r[t],((m=a.getClusterDistancesFromPoint(o,c,h)).length&&m[0].distance<l?o[m[0].clusterIndex].points:i).push({x:c,y:h,dataIndex:s[t]});for(let t=0;t<o.length;t++)1===o[t].points.length&&(m=a.getClusterDistancesFromPoint(o,o[t].points[0].x,o[t].points[0].y))[1].distance<l&&(o[m[1].clusterIndex].points.push(o[t].points[0]),o[m[0].clusterIndex].points.length=0);d=!1;for(let t=0;t<o.length;t++)f=V(o[t].points),o[t].oldX=o[t].posX,o[t].oldY=o[t].posY,o[t].posX=f.x,o[t].posY=f.y,(o[t].posX>o[t].oldX+1||o[t].posX<o[t].oldX-1||o[t].posY>o[t].oldY+1||o[t].posY<o[t].oldY-1)&&(d=!0);p&&(d=u<p-1),u++}for(let t=0,e=o.length;t<e;++t)n["cluster"+t]=o[t].points;for(let t=0,e=i.length;t<e;++t)n["noise"+t]=[i[t]];return n},optimizedKmeans:function(t,e,r,s){var a=this,o=s.processedDistance||E.layoutAlgorithm.gridSize,i=a.getRealExtremes(),n=(a.options.cluster||{}).marker;let l,p={},u,d;if(!a.markerClusterInfo||a.initMaxX&&a.initMaxX<i.maxX||a.initMinX&&a.initMinX>i.minX||a.initMaxY&&a.initMaxY<i.maxY||a.initMinY&&a.initMinY>i.minY)a.initMaxX=i.maxX,a.initMinX=i.minX,a.initMaxY=i.maxY,a.initMinY=i.minY,p=a.markerClusterAlgorithms?a.markerClusterAlgorithms.kmeans.call(a,t,e,r,s):{},a.baseClusters=null;else{a.baseClusters||(a.baseClusters={clusters:a.markerClusterInfo.clusters,noise:a.markerClusterInfo.noise});for(const f of a.baseClusters.clusters){f.pointsOutside=[],f.pointsInside=[];for(const m of f.data){var c=F(a,m),h=F(a,f);l=Math.sqrt(Math.pow(c.x-h.x,2)+Math.pow(c.y-h.y,2)),u=0<=o-(d=(f.clusterZone&&f.clusterZone.marker&&f.clusterZone.marker.radius?f.clusterZone.marker:n&&n.radius?n:E.marker).radius)?o-d:d,l>d+u&&j(f.pointsOutside)?f.pointsOutside.push(m):j(f.pointsInside)&&f.pointsInside.push(m)}f.pointsInside.length&&(p[f.id]=f.pointsInside);let t=0;for(const g of f.pointsOutside)p[f.id+"_noise"+t++]=[g]}for(const x of a.baseClusters.noise)p[x.id]=x.data}return p}};let T,l=[],r=0;function i(t,e,r){t.attr({opacity:e}).animate({opacity:1},r)}function I(t,e,r,s){S(t,s,r,!0,!0);for(const a of e)a.point&&a.point.destroy&&a.point.destroy()}function S(t,e,r,s,a){t.point&&(s&&t.point.graphic&&(t.point.graphic.show(),i(t.point.graphic,e,r)),a&&t.point.dataLabel&&(t.point.dataLabel.show(),i(t.point.dataLabel,e,r)))}function V(e){var r=e.length;let s=0,a=0;for(let t=0;t<r;t++)s+=e[t].x,a+=e[t].y;return{x:s/r,y:a/r}}function p(t,e){const r=[];return r.length=e,t.clusters.forEach(function(t){t.data.forEach(function(t){r[t.dataIndex]=t})}),t.noise.forEach(function(t){r[t.data[0].dataIndex]=t.data[0]}),r}function D(){return Math.random().toString(36).substring(2,7)+"-"+r++}function L(t,e,r){t.point&&(e&&t.point.graphic&&t.point.graphic.hide(),r&&t.point.dataLabel&&t.point.dataLabel.hide())}function G(t){const e=t.point||t.target;e.firePointEvent("drillToCluster",t,function(a){const t=a.point||a.target,e=t.series,o=t.series.xAxis,i=t.series.yAxis,n=t.series.chart,{inverted:l,mapView:r,pointer:p}=n,s=e.options.cluster,u=(s||{}).drillToCluster;if(u&&t.clusteredData){var a=t.clusteredData.map(t=>t.x).sort((t,e)=>t-e),d=t.clusteredData.map(t=>t.y).sort((t,e)=>t-e),c=a[0],a=a[a.length-1],h=d[0],d=d[d.length-1],f=Math.abs(.1*(a-c)),m=Math.abs(.1*(d-h)),g=Math.min(c,a)-f,c=Math.max(c,a)+f,a=Math.min(h,d)-m,f=Math.max(h,d)+m;if(r)r.fitToBounds({x1:g,x2:c,y1:a,y2:f});else if(o&&i){let t=o.toPixels(g),e=o.toPixels(c),r=i.toPixels(a),s=i.toPixels(f);l&&([t,e,r,s]=[r,s,t,e]),t>e&&([t,e]=[e,t]),r>s&&([r,s]=[s,r]),p&&(p.zoomX=!0,p.zoomY=!0),n.transform({from:{x:t,y:r,width:e-t,height:s-r}})}}})}function R(t,e){const{chart:r,xAxis:s,yAxis:a}=t;return r.mapView?r.mapView.pixelsToProjectedUnits(e):{x:s?s.toValue(e.x):0,y:a?a.toValue(e.y):0}}function n(t){const e=this.chart,r=e.mapView,s=this.options.cluster,a=k((s||{}).animation),o=a.duration||500,i=(this.markerClusterInfo||{}).pointsState,n=(i||{}).newState,l=(i||{}).oldState,p=[];let u,d,c,h,f,m,g,x=!1,y=!1;var C;l&&n&&(C=F(this,c=n[t.stateId]),m=C.x-(r?0:e.plotLeft),g=C.y-(r?0:e.plotTop),1===c.parentsId.length?(u=(n||{})[t.stateId].parentsId[0],d=l[u],c.point&&c.point.graphic&&d&&d.point&&d.point.plotX&&d.point.plotY&&d.point.plotX!==c.point.plotX&&d.point.plotY!==c.point.plotY&&(h=c.point.graphic.getBBox(),f=c.point.graphic&&c.point.graphic.isImg?0:h.width/2,c.point.graphic.attr({x:d.point.plotX-f,y:d.point.plotY-f}),c.point.graphic.animate({x:m-(c.point.graphic.radius||0),y:g-(c.point.graphic.radius||0)},a,function(){y=!0,d.point&&d.point.destroy&&d.point.destroy()}),c.point.dataLabel&&c.point.dataLabel.alignAttr&&d.point.dataLabel&&d.point.dataLabel.alignAttr&&(c.point.dataLabel.attr({x:d.point.dataLabel.alignAttr.x,y:d.point.dataLabel.alignAttr.y}),c.point.dataLabel.animate({x:c.point.dataLabel.alignAttr.x,y:c.point.dataLabel.alignAttr.y},a)))):0===c.parentsId.length?(L(c,!0,!0),M(function(){S(c,.1,a,!0,!0)},o/2)):(L(c,!0,!0),c.parentsId.forEach(function(t){l&&l[t]&&(d=l[t],p.push(d),d.point&&d.point.graphic&&(x=!0,d.point.graphic.show(),d.point.graphic.animate({x:m-(d.point.graphic.radius||0),y:g-(d.point.graphic.radius||0),opacity:.4},a,function(){y=!0,I(c,p,a,.7)}),d.point.dataLabel&&-9999!==d.point.dataLabel.y&&c.point&&c.point.dataLabel&&c.point.dataLabel.alignAttr&&(d.point.dataLabel.show(),d.point.dataLabel.animate({x:c.point.dataLabel.alignAttr.x,y:c.point.dataLabel.alignAttr.y,opacity:.4},a))))}),M(function(){y||I(c,p,a,.85)},o),x||M(function(){I(c,p,a,.1)},o/2)))}function u(){const t=this.markerClusterSeriesData;(t||[]).forEach(function(t){t&&t.destroy&&t.destroy()}),this.markerClusterSeriesData=null}function d(){const r=this,t=r.chart,e=t.mapView,s=r.xData,a=r.yData,o=r.options.cluster,i=r.getRealExtremes(),n=[],l=[],p=[];let u,d,c,h,f,m,g,x,y,C,k,M,I,S,b,A,X;if(e&&r.is("mappoint")&&s&&a&&(r.options.data||[]).forEach((t,e)=>{t=r.projectPoint(t);t&&(s[e]=t.x,a[e]=t.y)}),o&&o.enabled&&s&&s.length&&a&&a.length&&!t.polar){k=o.layoutAlgorithm.type,(b=o.layoutAlgorithm).processedGridSize=O(b.gridSize||E.layoutAlgorithm.gridSize,t.plotWidth),b.processedDistance=O(b.distance||E.layoutAlgorithm.distance,t.plotWidth),h=b.kmeansThreshold||E.layoutAlgorithm.kmeansThreshold;var Y=b.processedGridSize/2,D=R(r,{x:0,y:0}),Y=R(r,{x:Y,y:Y});for(f=Math.abs(D.x-Y.x),m=Math.abs(D.y-Y.y),X=0;X<s.length;X++)r.dataMaxX||(j(x)&&j(g)&&j(C)&&j(y)?w(a[X])&&w(C)&&w(y)&&(x=Math.max(s[X],x),g=Math.min(s[X],g),C=Math.max(a[X]||C,C),y=Math.min(a[X]||y,y)):(x=g=s[X],C=y=a[X])),s[X]>=i.minX-f&&s[X]<=i.maxX+f&&(a[X]||i.minY)>=i.minY-m&&(a[X]||i.maxY)<=i.maxY+m&&(n.push(s[X]),l.push(a[X]),p.push(X));if(j(x)&&j(g)&&w(C)&&w(y)&&(r.dataMaxX=x,r.dataMinX=g,r.dataMaxY=C,r.dataMinY=y),I=(S=(M=z(k)?k:r.markerClusterAlgorithms?k&&r.markerClusterAlgorithms[k]?r.markerClusterAlgorithms[k]:n.length<h?r.markerClusterAlgorithms.kmeans:r.markerClusterAlgorithms.grid:function(){return!1}).call(this,n,l,p,b))&&r.getClusteredData(S,o),o.animation&&r.markerClusterInfo&&r.markerClusterInfo.pointsState&&r.markerClusterInfo.pointsState.oldState){var L=r.markerClusterInfo.pointsState.oldState;if(L){let t;for(const v of Object.keys(L))(t=L[v]).point&&t.point.destroy&&t.point.destroy()}u=r.markerClusterInfo.pointsState.newState}else u={};d=s.length,c=r.markerClusterInfo,I&&(r.processedXData=I.groupedXData,r.processedYData=I.groupedYData,r.hasGroupedData=!0,r.markerClusterInfo=I,r.groupMap=I.groupMap),T.apply(this),I&&r.markerClusterInfo&&((r.markerClusterInfo.clusters||[]).forEach(function(t){(A=r.points[t.index]).isCluster=!0,A.clusteredData=t.data,A.clusterPointsAmount=t.data.length,t.point=A,P(A,"click",G)}),(r.markerClusterInfo.noise||[]).forEach(function(t){t.point=r.points[t.index]}),o.animation&&r.markerClusterInfo&&(r.markerClusterInfo.pointsState={oldState:u,newState:r.getPointsState(I,c,d)}),o.animation?this.hideClusteredData():this.destroyClusteredData(),this.markerClusterSeriesData=this.hasGroupedData?this.points:null)}else T.apply(this)}function c(e,r,s){const a=[];for(let t=0;t<e.length;t++){var o=F(this,{x:r,y:s}),i=F(this,{x:e[t].posX,y:e[t].posY}),o=Math.sqrt(Math.pow(o.x-i.x,2)+Math.pow(o.y-i.y,2));a.push({clusterIndex:t,distance:o})}return a.sort((t,e)=>t.distance-e.distance)}function h(t,e){const r=this,s=[],a=[],o=[],i=[],n=[],l=Math.max(2,e.minimumClusterSize||2);let p=0,u,d,c,h,f,m,g,x,y,C,k,M,I,S;if(z(e.layoutAlgorithm.type)&&!r.isValidGroupedDataObject(t))return b("Highcharts marker-clusters module: The custom algorithm result is not valid!",!1,r.chart),!1;for(S in t)if(t[S].length>=l){if(c=t[S],u=D(),f=c.length,e.zones)for(I=0;I<e.zones.length;I++)f>=e.zones[I].from&&f<=e.zones[I].to&&((k=e.zones[I]).zoneIndex=I,C=e.zones[I].marker,M=e.zones[I].className);for(y=V(c),g="grid"!==e.layoutAlgorithm.type||e.allowOverlap?{x:y.x,y:y.y}:(m=r.options.marker||{},r.preventClusterCollisions({x:y.x,y:y.y,key:S,groupedData:t,gridSize:r.getScaledGridSize(e.layoutAlgorithm),defaultRadius:m.radius||3+(m.lineWidth||0),clusterRadius:C&&C.radius?C.radius:(e.marker||{}).radius||E.marker.radius})),I=0;I<f;I++)c[I].parentStateId=u;if(o.push({x:g.x,y:g.y,id:S,stateId:u,index:p,data:c,clusterZone:k,clusterZoneClassName:M}),s.push(g.x),a.push(g.y),n.push({options:{formatPrefix:"cluster",dataLabels:e.dataLabels,marker:Y(e.marker,{states:e.states},C||{})}}),r.options.data&&r.options.data.length)for(I=0;I<f;I++)X(r.options.data[c[I].dataIndex])&&(c[I].options=r.options.data[c[I].dataIndex]);p++,C=null}else for(I=0;I<t[S].length;I++)d=t[S][I],u=D(),x=null,h=((r.options||{}).data||[])[d.dataIndex],s.push(d.x),a.push(d.y),d.parentStateId=u,i.push({x:d.x,y:d.y,id:S,stateId:u,index:p,data:t[S]}),x=h&&"object"==typeof h&&!A(h)?Y(h,{x:d.x,y:d.y}):{userOptions:h,x:d.x,y:d.y},n.push({options:x}),p++;return{clusters:o,noise:i,groupedXData:s,groupedYData:a,groupMap:n}}function f(){const t=this,e=t.chart,r=t.xAxis,s=t.yAxis;let a=0,o=0;return a=r&&t.dataMinX&&t.dataMaxX?r.reversed?r.toPixels(t.dataMaxX):r.toPixels(t.dataMinX):e.plotLeft,o=s&&t.dataMinY&&t.dataMaxY?s.reversed?s.toPixels(t.dataMinY):s.toPixels(t.dataMaxY):e.plotTop,{plotLeft:a,plotTop:o}}function m(t,e,r){const s=e?p(e,r):[],a=p(t,r),o={};var i,n;l=[],t.clusters.forEach(function(t){o[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),t.noise.forEach(function(t){o[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}});for(let t=0;t<a.length;t++)i=a[t],n=s[t],i&&n&&i.parentStateId&&n.parentStateId&&o[i.parentStateId]&&-1===o[i.parentStateId].parentsId.indexOf(n.parentStateId)&&(o[i.parentStateId].parentsId.push(n.parentStateId),-1===l.indexOf(n.parentStateId)&&l.push(n.parentStateId));return o}function g(){var t=this.chart,e=t.mapView?0:t.plotLeft,r=R(this,{x:e,y:t.mapView?0:t.plotTop}),e=R(this,{x:e+t.plotWidth,y:e+t.plotHeight}),t=r.x,s=e.x,r=r.y,e=e.y;return{minX:Math.min(t,s),maxX:Math.max(t,s),minY:Math.min(r,e),maxY:Math.max(r,e)}}function x(t){const e=this,r=e.xAxis,s=this.chart.mapView,a=t.processedGridSize||E.layoutAlgorithm.gridSize;let o=!0,i=1,n=1;e.gridValueSize||(s?e.gridValueSize=a/s.getScale():e.gridValueSize=Math.abs(r.toValue(a)-r.toValue(0)));for(var l=+(a/(s?e.gridValueSize*s.getScale():r.toPixels(e.gridValueSize)-r.toPixels(0))).toFixed(14);o&&1!=l;){var p=Math.pow(2,i);.75<l&&l<1.25?o=!1:1/p<=l&&l<1/p*2?(o=!1,n=p):l<=p&&p/2<l&&(o=!1,n=1/p),i++}return a/n/l}function y(){const t=this.markerClusterSeriesData,e=((this.markerClusterInfo||{}).pointsState||{}).oldState||{},r=l.map(t=>(e[t].point||{}).id||"");(t||[]).forEach(function(t){t&&-1!==r.indexOf(t.id)?(t.graphic&&t.graphic.hide(),t.dataLabel&&t.dataLabel.hide()):t&&t.destroy&&t.destroy()})}function C(t){let e=!1,r;return!!X(t)&&(a(t,function(t){if(e=!0,A(t)&&t.length){for(r=0;r<t.length;r++)if(!X(t[r])||!t[r].x||!t[r].y)return void(e=!1)}else e=!1}),e)}function v(t){const e=this,[r,s]=t.key.split("-").map(parseFloat),a=t.gridSize,o=t.groupedData,i=t.defaultRadius,n=t.clusterRadius,l=s*a,p=r*a,u=F(e,t),d=[],c=(e.options.cluster||{}).marker,h=(e.options.cluster||{}).zones,f=e.getGridOffset();let m=u.x,g=u.y,x,y=0,C,k,M,I,S,b,A,X,Y,D,L,v,P;for(m-=f.plotLeft,g-=f.plotTop,A=1;A<5;A++)for(M=A%2?-1:1,I=A<3?-1:1,S=Math.floor((m+M*n)/a),P=[(b=Math.floor((g+I*n)/a))+"-"+S,b+"-"+s,r+"-"+S],X=0;X<P.length;X++)-1===d.indexOf(P[X])&&P[X]!==t.key&&d.push(P[X]);for(const w of d)if(o[w]){o[w].posX||(L=V(o[w]),o[w].posX=L.x,o[w].posY=L.y);const z=F(e,{x:o[w].posX||0,y:o[w].posY||0});if(C=z.x-f.plotLeft,k=z.y-f.plotTop,[D,Y]=w.split("-").map(parseFloat),h)for(x=o[w].length,A=0;A<h.length;A++)x>=h[A].from&&x<=h[A].to&&(y=j((h[A].marker||{}).radius)?h[A].marker.radius||0:(c&&c.radius?c:E.marker).radius);1<o[w].length&&0===y&&c&&c.radius?y=c.radius:1===o[w].length&&(y=i),v=n+y,y=0,Y!==s&&Math.abs(m-C)<v&&(m=Y-s<0?l+n:l+a-n),D!==r&&Math.abs(g-k)<v&&(g=D-r<0?p+n:p+a-n)}const z=R(e,{x:m+f.plotLeft,y:g+f.plotTop});return o[t.key].posX=z.x,o[t.key].posY=z.y,z}function F(t,e){const{chart:r,xAxis:s,yAxis:a}=t;return r.mapView?r.mapView.projectedUnitsToPixels(e):{x:s?s.toPixels(e.x):0,y:a?a.toPixels(e.y):0}}return{compose:function(t,e){const r=e.prototype;r.markerClusterAlgorithms||(T=r.generatePoints,r.markerClusterAlgorithms=o,r.animateClusterPoint=n,r.destroyClusteredData=u,r.generatePoints=d,r.getClusterDistancesFromPoint=c,r.getClusteredData=h,r.getGridOffset=f,r.getPointsState=m,r.getRealExtremes=g,r.getScaledGridSize=x,r.hideClusteredData=y,r.isValidGroupedDataObject=C,r.preventClusterCollisions=v,P(e,"destroy",r.destroyClusteredData),(t.plotOptions||{}).series=Y((t.plotOptions||{}).series,s))}}}),e(t,"Extensions/MarkerClusters/MarkerClusters.js",[t["Core/Animation/AnimationUtilities.js"],t["Core/Defaults.js"],t["Core/Globals.js"],t["Extensions/MarkerClusters/MarkerClusterDefaults.js"],t["Extensions/MarkerClusters/MarkerClusterScatter.js"],t["Core/Utilities.js"]],function(t,e,r,s,i,a){const o=t["animObject"],n=e["defaultOptions"],l=r["composed"],{addEvent:p,defined:u,error:d,isFunction:c,merge:h,pushUnique:f,syncTimeout:m}=a;function g(){const t=this.chart;let e=0;for(const r of t.series)r.markerClusterInfo&&(e=o((r.options.cluster||{}).animation).duration||0);m(()=>{t.tooltip&&t.tooltip.destroy()},e)}function x(){for(const r of this.series||[])if(r.markerClusterInfo){var t=r.options.cluster,e=((r.markerClusterInfo||{}).pointsState||{}).oldState;if((t||{}).animation&&r.markerClusterInfo&&0===(r.chart.pointer?.pinchDown||[]).length&&"pan"!==((r.xAxis||{}).eventArgs||{}).trigger&&e&&Object.keys(e).length){for(const s of r.markerClusterInfo.clusters)r.animateClusterPoint(s);for(const a of r.markerClusterInfo.noise)r.animateClusterPoint(a)}}}function y(t){const e=t.point||t.target,r=e.series,s=r.options.cluster,a=((s||{}).events||{}).drillToCluster;c(a)&&a.call(this,t)}function C(){if(this.dataGroup)return d("Highcharts marker-clusters module: Running `Point.update` when point belongs to clustered series is not supported.",!1,this.series.chart),!1}function k(){var t=(this.options.cluster||{}).drillToCluster;if(this.markerClusterInfo&&this.markerClusterInfo.clusters)for(const e of this.markerClusterInfo.clusters)e.point&&e.point.graphic&&(e.point.graphic.addClass("highcharts-cluster-point"),t&&e.point&&(e.point.graphic.css({cursor:"pointer"}),e.point.dataLabel&&e.point.dataLabel.css({cursor:"pointer"})),u(e.clusterZone)&&e.point.graphic.addClass(e.clusterZoneClassName||"highcharts-cluster-zone-"+e.clusterZone.zoneIndex))}return(n.plotOptions||{}).series=h((n.plotOptions||{}).series,s),{compose:function(t,e,r,s){var a,o;f(l,"MarkerClusters")&&(a=s.prototype.pointClass,o=s.types["scatter"],p(t,"setExtremes",g),p(e,"render",x),p(a,"drillToCluster",y),p(a,"update",C),p(s,"afterRender",k),o&&i.compose(r,o))}}}),e(t,"Extensions/MarkerClusters/MarkerClusterSymbols.js",[],function(){let p;function e(t,e,r,s){const a=r/2,o=s/2,i=p.arc(t+a,e+o,a-4,o-4,{start:.5*Math.PI,end:2.5*Math.PI,open:!1}),n=p.arc(t+a,e+o,a-3,o-3,{start:.5*Math.PI,end:2.5*Math.PI,innerR:a-2,open:!1}),l=p.arc(t+a,e+o,a-1,o-1,{start:.5*Math.PI,end:2.5*Math.PI,innerR:a,open:!1});return l.concat(n,i)}return{compose:function(t){(p=t.prototype.symbols).cluster=e}}}),e(t,"masters/modules/marker-clusters.src.js",[t["Core/Globals.js"],t["Extensions/MarkerClusters/MarkerClusters.js"],t["Extensions/MarkerClusters/MarkerClusterSymbols.js"]],function(t,e,r){var s=t;return e.compose(s.Axis,s.Chart,s.defaultOptions,s.Series),r.compose(s.SVGRenderer),t})});