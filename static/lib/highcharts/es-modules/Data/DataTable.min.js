"use strict";import U from"../Core/Utilities.js";const{addEvent,defined,fireEvent,uniqueKey}=U;class DataTable{static isNull(o){if(o===DataTable.NULL)return!0;if(o instanceof Array){if(!o.length)return!1;for(let e=0,t=o.length;e<t;++e)if(null!==o[e])return!1}else{var n=Object.keys(o);if(!n.length)return!1;for(let e=0,t=n.length;e<t;++e)if(null!==o[n[e]])return!1}return!0}constructor(e={}){this.autoId=!e.id,this.columns={},this.id=e.id||uniqueKey(),(this.modified=this).rowCount=0,this.versionTag=uniqueKey();const r=e.columns||{},s=Object.keys(r),l=this.columns;let i=0;for(let e=0,t=s.length,o,n;e<t;++e)n=s[e],o=r[n].slice(),l[n]=o,i=Math.max(i,o.length);for(let e=0,t=s.length;e<t;++e)l[s[e]].length=i;this.rowCount=i}clone(e,t){const o=this,n={},r=(o.emit({type:"cloneTable",detail:t}),e||(n.columns=o.columns),o.autoId||(n.id=o.id),new DataTable(n));return e||(r.versionTag=o.versionTag,r.originalRowIndexes=o.originalRowIndexes,r.localRowIndexes=o.localRowIndexes),o.emit({type:"afterCloneTable",detail:t,tableClone:r}),r}deleteColumns(r,e){const t=this,s=t.columns,l={},i={},o=t.modifier,u=t.rowCount;if((r=r||Object.keys(s)).length){t.emit({type:"deleteColumns",columnNames:r,detail:e});for(let e=0,t=r.length,o,n;e<t;++e)n=r[e],(o=s[n])&&(l[n]=o,i[n]=new Array(u)),delete s[n];return Object.keys(s).length||(t.rowCount=0,this.deleteRowIndexReferences()),o&&o.modifyColumns(t,i,0,e),t.emit({type:"afterDeleteColumns",columns:l,columnNames:r,detail:e}),l}}deleteRowIndexReferences(){delete this.originalRowIndexes,delete this.localRowIndexes}deleteRows(r,s=1,e){const l=this,i=[],u=[],t=l.modifier;if(l.emit({type:"deleteRows",detail:e,rowCount:s,rowIndex:r||0}),void 0===r&&(r=0,s=l.rowCount),0<s&&r<l.rowCount){var a=l.columns,m=Object.keys(a);for(let o=0,e=m.length,t,n;o<e;++o){n=(t=a[m[o]]).splice(r,s),o||(l.rowCount=t.length);for(let e=0,t=n.length;e<t;++e)i[e]=i[e]||[],i[e][o]=n[e];u.push(new Array(e))}}return t&&t.modifyRows(l,u,r||0,e),l.emit({type:"afterDeleteRows",detail:e,rowCount:s,rowIndex:r||0,rows:i}),i}emit(e){switch(e.type){case"afterDeleteColumns":case"afterDeleteRows":case"afterSetCell":case"afterSetColumns":case"afterSetRows":this.versionTag=uniqueKey()}fireEvent(this,e.type,e)}getCell(e,t){e=this.columns[e];if(e)return e[t]}getCellAsBoolean(e,t){e=this.columns[e];return!(!e||!e[t])}getCellAsNumber(e,t,o){e=this.columns[e];let n=e&&e[t];switch(typeof n){case"boolean":return n?1:0;case"number":return isNaN(n)&&!o?null:n}return n=parseFloat(""+(n??"")),isNaN(n)&&!o?null:n}getCellAsString(e,t){e=this.columns[e];return""+(e&&e[t])}getColumn(e,t){return this.getColumns([e],t)[e]}getColumnAsNumbers(t,e){const o=this.columns[t],n=[];if(o){var r=o.length;if(e)for(let e=0;e<r;++e)n.push(this.getCellAsNumber(t,e,!0));else{for(let e=0,t;e<r;++e){if("number"==typeof(t=o[e]))return o.slice();if(null!=t)break}for(let e=0;e<r;++e)n.push(this.getCellAsNumber(t,e))}}return n}getColumnNames(){return Object.keys(this.columns)}getColumns(r,s){const l=this.columns,i={};for(let e=0,t=(r=r||Object.keys(l)).length,o,n;e<t;++e)n=r[e],(o=l[n])&&(i[n]=s?o:o.slice());return i}getLocalRowIndex(e){var t=this["localRowIndexes"];return t?t[e]:e}getModifier(){return this.modifier}getOriginalRowIndex(e){var t=this["originalRowIndexes"];return t?t[e]:e}getRow(e,t){return this.getRows(e,1,t)[0]}getRowCount(){return this.rowCount}getRowIndexBy(e,t,o){const n=this.columns[e];if(n){e=n.indexOf(t,o);if(-1!==e)return e}}getRowObject(e,t){return this.getRowObjects(e,1,t)[0]}getRowObjects(s=0,l=this.rowCount-s,i){const u=this.columns,a=new Array(l);i=i||Object.keys(u);for(let e=s,t=0,o=Math.min(this.rowCount,s+l),n,r;e<o;++e,++t){r=a[t]={};for(const m of i)n=u[m],r[m]=n?n[e]:void 0}return a}getRows(s=0,l=this.rowCount-s,i){const u=this.columns,a=new Array(l);i=i||Object.keys(u);for(let e=s,t=0,o=Math.min(this.rowCount,s+l),n,r;e<o;++e,++t){r=a[t]=[];for(const m of i)n=u[m],r.push(n?n[e]:void 0)}return a}getVersionTag(){return this.versionTag}hasColumns(o){var n=this.columns;for(let e=0,t=o.length;e<t;++e)if(!n[o[e]])return!1;return!0}hasRowWith(e,t){const o=this.columns[e];return!!o&&-1!==o.indexOf(t)}on(e,t){return addEvent(this,e,t)}renameColumn(e,t){const o=this.columns;return!!o[e]&&(e!==t&&(o[t]=o[e],delete o[e]),!0)}setCell(e,t,o,n){const r=this,s=r.columns,l=r.modifier;let i=s[e];i&&i[t]===o||(r.emit({type:"setCell",cellValue:o,columnName:e,detail:n,rowIndex:t}),i=i||(s[e]=new Array(r.rowCount)),t>=r.rowCount&&(r.rowCount=t+1),i[t]=o,l&&l.modifyCell(r,e,t,o),r.emit({type:"afterSetCell",cellValue:o,columnName:e,detail:n,rowIndex:t}))}setColumn(e,t=[],o=0,n){this.setColumns({[e]:t},o,n)}setColumns(r,s,e){const l=this,i=l.columns,t=l.modifier,u=void 0===s,a=Object.keys(r);l.emit({type:"setColumns",columns:r,columnNames:a,detail:e,rowIndex:s});for(let e=0,t=a.length,o,n;e<t;++e)if(n=a[e],o=r[n],u)i[n]=o.slice(),l.rowCount=o.length;else{const m=i[n]||(i[n]=new Array(l.rowCount));for(let e=s||0,t=o.length;e<t;++e)m[e]=o[e];l.rowCount=Math.max(l.rowCount,m.length)}var o=Object.keys(i);for(let e=0,t=o.length;e<t;++e)i[o[e]].length=l.rowCount;t&&t.modifyColumns(l,r,s||0),l.emit({type:"afterSetColumns",columns:r,columnNames:a,detail:e,rowIndex:s})}setModifier(t,o){const n=this;let e;return n.emit({type:"setModifier",detail:o,modifier:t,modified:n.modified}),(n.modified=n).modifier=t,(e=t?t.modify(n):Promise.resolve(n)).then(e=>(e.emit({type:"afterSetModifier",detail:o,modifier:t,modified:e.modified}),e)).catch(e=>{throw n.emit({type:"setModifierError",error:e,modifier:t,modified:n.modified}),e})}setOriginalRowIndexes(n,e=!1){if(this.originalRowIndexes=n,!e){const r=this.localRowIndexes=[];for(let e=0,t=n.length,o;e<t;++e)o=n[e],defined(o)&&(r[o]=e)}}setRow(e,t,o){this.setRows([e],t,o)}setRows(t,o=this.rowCount,e){const n=this,s=n.columns,l=Object.keys(s),r=n.modifier,i=t.length;n.emit({type:"setRows",detail:e,rowCount:i,rowIndex:o,rows:t});for(let e=0,n=o,r;e<i;++e,++n)if((r=t[e])===DataTable.NULL)for(let e=0,t=l.length;e<t;++e)s[l[e]][n]=null;else if(r instanceof Array)for(let e=0,t=l.length;e<t;++e)s[l[e]][n]=r[e];else{var u=Object.keys(r);for(let e=0,t=u.length,o;e<t;++e)o=u[e],s[o]||(s[o]=new Array(n+1)),s[o][n]=r[o]}var a=o+i;if(a>n.rowCount){n.rowCount=a;for(let e=0,t=l.length;e<t;++e)s[l[e]].length=a}r&&r.modifyRows(n,t,o),n.emit({type:"afterSetRows",detail:e,rowCount:i,rowIndex:o,rows:t})}}DataTable.NULL={},DataTable.version="1.0.0";export default DataTable;