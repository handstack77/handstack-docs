"use strict";import PC from"../Core/Geometry/PolygonClip.js";const{clipLineString,clipPolygon}=PC;import ProjectionRegistry from"./Projections/ProjectionRegistry.js";import U from"../Core/Utilities.js";const{clamp,erase}=U,deg2rad=2*Math.PI/360,floatCorrection=1e-6,wrapLon=t=>(t<-180&&(t+=360),180<t&&(t-=360),t),hav=t=>(1-Math.cos(t))/2,havFromCoords=(t,r)=>{const o=Math.cos,e=t[1]*deg2rad,i=t[0]*deg2rad,a=r[1]*deg2rad,n=r[0]*deg2rad,s=a-e,c=n-i,d=hav(s)+o(e)*o(a)*hav(c);return d};class Projection{static add(t,r){Projection.registry[t]=r}static distance(t,r){const{atan2:o,sqrt:e}=Math,i=havFromCoords(t,r),a=2*o(e(i),e(1-i)),n=6371e3*a;return n}static geodesic(t,r,o,e=5e5){const{atan2:i,cos:a,sin:n,sqrt:s}=Math,c=Projection.distance,d=t[1]*deg2rad,h=t[0]*deg2rad,l=r[1]*deg2rad,f=r[0]*deg2rad,g=a(d)*a(h),u=a(l)*a(f),p=a(d)*n(h),v=a(l)*n(f),M=n(d),P=n(l),y=c(t,r),j=y/6371e3,m=n(j),w=Math.round(y/e),L=[];if(o&&L.push(t),1<w){var C=1/w;for(let t=C;t<.999;t+=C){var x=n((1-t)*j)/m,b=n(t*j)/m,E=x*g+b*u,G=x*p+b*v,x=i(x*M+b*P,s(E*E+G*G)),b=i(G,E);L.push([b/deg2rad,x/deg2rad])}}return o&&L.push(r),L}static insertGeodesics(t){let r=t.length-1;for(;r--;){var o;10<Math.max(Math.abs(t[r][0]-t[r+1][0]),Math.abs(t[r][1]-t[r+1][1]))&&((o=Projection.geodesic(t[r],t[r+1])).length&&t.splice(r+1,0,...o))}}static toString(t){const{name:r,rotation:o}=t||{};return[r,o&&o.join(",")].join(";")}constructor(t={}){this.hasCoordinates=!1,this.hasGeoProjection=!1,this.maxLatitude=90;var{name:r,projectedBounds:o,rotation:e}=this.options=t;this.rotator=e?this.getRotator(e):void 0;const i=r?Projection.registry[r]:void 0,{def:a,rotator:n}=(i&&(this.def=new i(t)),this);a&&(this.maxLatitude=a.maxLatitude||90,this.hasGeoProjection=!0),n&&a?(this.forward=t=>a.forward(n.forward(t)),this.inverse=t=>n.inverse(a.inverse(t))):a?(this.forward=t=>a.forward(t),this.inverse=t=>a.inverse(t)):n&&(this.forward=n.forward,this.inverse=n.inverse),this.bounds="world"===o?a&&a.bounds:o}lineIntersectsBounds(t){var{x1:r,x2:o,y1:e,y2:i}=this.bounds||{},a=(t,r,o)=>{var e,[t,i]=t,a=r?0:1;if("number"==typeof o&&t[r]>=o!=i[r]>=o)return e=(o-t[r])/(i[r]-t[r]),e=t[a]+e*(i[a]-t[a]),r?[e,o]:[o,e]};let n,s=t[0];return((n=a(t,0,r))||(n=a(t,0,o)))&&(s=n,t[1]=n),s=(n=a(t,1,e))||(n=a(t,1,i))?n:s}getRotator(t){const i=t[0]*deg2rad,r=(t[1]||0)*deg2rad,o=(t[2]||0)*deg2rad,a=Math.cos(r),n=Math.sin(r),s=Math.cos(o),c=Math.sin(o);if(0!=i||0!=r||0!=o)return{forward:t=>{var r=t[0]*deg2rad+i,t=t[1]*deg2rad,o=Math.cos(t),e=Math.cos(r)*o,r=Math.sin(r)*o,o=Math.sin(t),t=o*a+e*n;return[Math.atan2(r*s-t*c,e*a-o*n)/deg2rad,Math.asin(t*s+r*c)/deg2rad]},inverse:t=>{var r=t[0]*deg2rad,t=t[1]*deg2rad,o=Math.cos(t),e=Math.cos(r)*o,r=Math.sin(r)*o,o=Math.sin(t),t=o*s-r*c;return[(Math.atan2(r*s+o*c,e*a+t*n)-i)/deg2rad,Math.asin(t*a-e*n)/deg2rad]}}}forward(t){return t}inverse(t){return t}cutOnAntimeridian(o,e){const i=[],r=[o];for(let r=0,t=o.length;r<t;++r){var a=o[r];let t=o[r-1];if(!r){if(!e)continue;t=o[o.length-1]}var n=t[0],s=a[0];(n<-90||90<n)&&(s<-90||90<s)&&0<n!=0<s&&(s=clamp((180-(n+360)%360)/((s+360)%360-(n+360)%360),0,1),s=t[1]+s*(a[1]-t[1]),i.push({i:r,lat:s,direction:n<0?1:-1,previousLonLat:t,lonLat:a}))}let c;if(i.length)if(e){i.length%2==1&&(c=i.slice().sort((t,r)=>Math.abs(r.lat)-Math.abs(t.lat))[0],erase(i,c));let t=i.length-2;for(;0<=t;){var d=i[t].i,h=wrapLon(180+i[t].direction*floatCorrection),l=wrapLon(180-i[t].direction*floatCorrection);const v=o.splice(d,i[t+1].i-d,...Projection.geodesic([h,i[t].lat],[h,i[t+1].lat],!0));v.push(...Projection.geodesic([l,i[t+1].lat],[l,i[t].lat],!0)),r.push(v),t-=2}if(c)for(let t=0;t<r.length;t++){const{direction:M,lat:P}=c,o=r[t],y=o.indexOf(c.lonLat);if(-1<y){var f=(P<0?-1:1)*this.maxLatitude,g=wrapLon(180+M*floatCorrection),u=wrapLon(180-M*floatCorrection);const j=Projection.geodesic([g,P],[g,f],!0);for(let t=g+120*M;-180<t&&t<180;t+=120*M)j.push([t,f]);j.push(...Projection.geodesic([u,f],[u,c.lat],!0)),o.splice(y,0,...j);break}}}else{let t=i.length;for(;t--;){var p=i[t].i;const m=o.splice(p,o.length,[wrapLon(180+i[t].direction*floatCorrection),i[t].lat]);m.unshift([wrapLon(180-i[t].direction*floatCorrection),i[t].lat]),r.push(m)}}return r}path(t){const{bounds:g,def:r,rotator:o}=this,u=[],p="Polygon"===t.type||"MultiPolygon"===t.type,v=this.hasGeoProjection,M=!r||!1!==r.antimeridianCutting,e=M?o:void 0,P=M&&r||this;let y;g&&(y=[[g.x1,g.y1],[g.x2,g.y1],[g.x2,g.y2],[g.x1,g.y2]]);const i=t=>{t=t.map(r=>{if(M){let t=(r=e?e.forward(r):r)[0];r=[t=Math.abs(t-180)<floatCorrection?t<180?180-floatCorrection:180+floatCorrection:t,r[1]]}return r});let r=[t];v&&(Projection.insertGeodesics(t),M&&(r=this.cutOnAntimeridian(t,p))),r.forEach(c=>{if(!(c.length<2)){let r=!1,o,e,i=!1;const l=t=>{r?u.push(["L",t[0],t[1]]):(u.push(["M",t[0],t[1]]),r=!0)};let a=!1,n=!1,s=c.map(t=>{const r=P.forward(t);return r.outside?a=!0:n=!0,r[1]===1/0?r[1]=1e10:r[1]===-1/0&&(r[1]=-1e10),r});if(M){if(p&&s.push(s[0]),a){if(!n)return;if(y)if(p)s=clipPolygon(s,y);else if(g)return void clipLineString(s,y).forEach(t=>{r=!1,t.forEach(l)})}s.forEach(l)}else for(let t=0;t<s.length;t++){var d=c[t],h=s[t];if(h.outside)i=!0;else{if(p&&!o&&(o=d,c.push(d),s.push(h)),i&&e)if(p&&v){const f=Projection.geodesic(e,d);f.forEach(t=>l(P.forward(t)))}else r=!1;l(h),e=d,i=!1}}}})};return"LineString"===t.type?i(t.coordinates):"MultiLineString"===t.type?t.coordinates.forEach(t=>i(t)):"Polygon"===t.type?(t.coordinates.forEach(t=>i(t)),u.length&&u.push(["Z"])):"MultiPolygon"===t.type&&(t.coordinates.forEach(t=>{t.forEach(t=>i(t))}),u.length&&u.push(["Z"])),u}}Projection.registry=ProjectionRegistry;export default Projection;