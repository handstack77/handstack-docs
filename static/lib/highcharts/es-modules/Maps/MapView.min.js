"use strict";import H from"../Core/Globals.js";const composed=H["composed"];import MapViewDefaults from"./MapViewDefaults.js";import GeoJSONComposition from"./GeoJSONComposition.js";import GeometryUtilities from"../Core/Geometry/GeometryUtilities.js";const pointInPolygon=GeometryUtilities["pointInPolygon"],topo2geo=GeoJSONComposition["topo2geo"];import MU from"./MapUtilities.js";const boundsFromPath=MU["boundsFromPath"];import Projection from"./Projection.js";import U from"../Core/Utilities.js";const{addEvent,clamp,crisp,fireEvent,isArray,isNumber,isObject,isString,merge,pick,pushUnique,relativeLength}=U,tileSize=256,worldSize=400.979322;let maps={};function zoomFromBounds(t,e){var{width:e,height:o}=e,e=Math.max((t.x2-t.x1)/(e/tileSize),(t.y2-t.y1)/(o/tileSize));return Math.log(worldSize/e)/Math.log(2)}function recommendedMapViewAfterDrill(t){t.seriesOptions.mapData&&this.mapView?.recommendMapView(this,[this.options.chart.map,t.seriesOptions.mapData],this.options.drilldown?.mapZooming)}class MapView{static compose(t){pushUnique(composed,"MapView")&&(maps=t.maps,addEvent(t,"afterInit",function(){this.mapView=new MapView(this,this.options.mapView)},{order:0}),addEvent(t,"addSeriesAsDrilldown",recommendedMapViewAfterDrill),addEvent(t,"afterDrillUp",recommendedMapViewAfterDrill))}static compositeBounds(t){if(t.length)return t.slice(1).reduce((t,e)=>(t.x1=Math.min(t.x1,e.x1),t.y1=Math.min(t.y1,e.y1),t.x2=Math.max(t.x2,e.x2),t.y2=Math.max(t.y2,e.y2),t),merge(t[0]))}static mergeInsets(t,e){var o=t=>{const o={};return t.forEach((t,e)=>{o[t&&t.id||"i"+e]=t}),o};const i=merge(o(t),o(e)),s=Object.keys(i).map(t=>i[t]);return s}constructor(t,e){this.allowTransformAnimation=!0,this.eventsToUnbind=[],this.insets=[],this.padding=[0,0,0,0],this.recommendedMapView={},this instanceof MapViewInset||this.recommendMapView(t,[t.options.chart.map,...(t.options.series||[]).map(t=>t.mapData)]),this.userOptions=e||{};const o=merge(MapViewDefaults,this.recommendedMapView,e);var i=this.recommendedMapView?.insets,e=e&&e.insets;i&&e&&(o.insets=MapView.mergeInsets(i,e)),this.chart=t,this.center=o.center,this.options=o,this.projection=new Projection(o.projection),this.playingField=t.plotBox,this.zoom=o.zoom||0,this.minZoom=o.minZoom,this.createInsets(),this.eventsToUnbind.push(addEvent(t,"afterSetChartSize",()=>{this.playingField=this.getField(),void 0!==this.minZoom&&this.minZoom!==this.zoom||(this.fitToBounds(void 0,void 0,!1),!this.chart.hasRendered&&isNumber(this.userOptions.zoom)&&(this.zoom=this.userOptions.zoom),this.userOptions.center&&merge(!0,this.center,this.userOptions.center))})),this.setUpEvents()}createInsets(){const e=this.options,t=e.insets;t&&t.forEach(t=>{t=new MapViewInset(this,merge(e.insetOptions,t));this.insets.push(t)})}fitToBounds(t,e,o=!0,i){var s,r=t||this.getProjectedBounds();r&&(e=pick(e,t?0:this.options.padding),s=this.getField(!1),e=isArray(e)?e:[e,e,e,e],this.padding=[relativeLength(e[0],s.height),relativeLength(e[1],s.width),relativeLength(e[2],s.height),relativeLength(e[3],s.width)],this.playingField=this.getField(),e=zoomFromBounds(r,this.playingField),t||(this.minZoom=e),s=this.projection.inverse([(r.x2+r.x1)/2,(r.y2+r.y1)/2]),this.setView(s,e,o,i))}getField(t=!0){t=t?this.padding:[0,0,0,0];return{x:t[3],y:t[0],width:this.chart.plotWidth-t[1]-t[3],height:this.chart.plotHeight-t[0]-t[2]}}getGeoMap(t){return isString(t)?maps[t]&&"Topology"===maps[t].type?topo2geo(maps[t]):maps[t]:isObject(t,!0)?"FeatureCollection"===t.type?t:"Topology"===t.type?topo2geo(t):void 0:void 0}getMapBBox(){var t,e,o=this.getProjectedBounds(),i=this.getScale();if(o)return t=this.padding,e=this.projectedUnitsToPixels({x:o.x1,y:o.y2}),{width:(o.x2-o.x1)*i+t[1]+t[3],height:(o.y2-o.y1)*i+t[0]+t[2],x:e.x-t[3],y:e.y-t[0]}}getProjectedBounds(){const e=this.projection;var t=this.chart.series.reduce((t,e)=>{var o=e.getProjectedBounds&&e.getProjectedBounds();return o&&!1!==e.options.affectsMapView&&t.push(o),t},[]);const o=this.options.fitToGeometry;if(o){if(!this.fitToGeometryCache)if("MultiPoint"===o.type){const i=o.coordinates.map(t=>e.forward(t)),s=i.map(t=>t[0]),r=i.map(t=>t[1]);this.fitToGeometryCache={x1:Math.min.apply(0,s),x2:Math.max.apply(0,s),y1:Math.min.apply(0,r),y2:Math.max.apply(0,r)}}else this.fitToGeometryCache=boundsFromPath(e.path(o));return this.fitToGeometryCache}return this.projection.bounds||MapView.compositeBounds(t)}getScale(){return tileSize/worldSize*Math.pow(2,this.zoom)}getSVGTransform(){var{x:t,y:e,width:o,height:i}=this.playingField,s=this.projection.forward(this.center),r=this.projection.hasCoordinates?-1:1,n=this.getScale(),r=n*r;return{scaleX:n,scaleY:r,translateX:t+o/2-s[0]*n,translateY:e+i/2-s[1]*r}}lonLatToPixels(t){t=this.lonLatToProjectedUnits(t);if(t)return this.projectedUnitsToPixels(t)}lonLatToProjectedUnits(t){const e=this.chart,o=e.mapTransforms;if(o){for(const n in o)if(Object.hasOwnProperty.call(o,n)&&o[n].hitZone){var i=e.transformFromLatLon(t,o[n]);if(i&&pointInPolygon(i,o[n].hitZone.coordinates[0]))return i}return e.transformFromLatLon(t,o.default)}for(const a of this.insets){var s;if(a.options.geoBounds&&pointInPolygon({x:t.lon,y:t.lat},a.options.geoBounds.coordinates[0]))return s=a.projection.forward([t.lon,t.lat]),s=a.projectedUnitsToPixels({x:s[0],y:s[1]}),this.pixelsToProjectedUnits(s)}var r=this.projection.forward([t.lon,t.lat]);if(!r.outside)return{x:r[0],y:r[1]}}projectedUnitsToLonLat(t){const e=this.chart,o=e.mapTransforms;if(o){for(const r in o)if(Object.hasOwnProperty.call(o,r)&&o[r].hitZone&&pointInPolygon(t,o[r].hitZone.coordinates[0]))return e.transformToLatLon(t,o[r]);return e.transformToLatLon(t,o.default)}var i=this.projectedUnitsToPixels(t);for(const n of this.insets)if(n.hitZone&&pointInPolygon(i,n.hitZone.coordinates[0])){const a=n.pixelsToProjectedUnits(i),s=n.projection.inverse([a.x,a.y]);return{lon:s[0],lat:s[1]}}const s=this.projection.inverse([t.x,t.y]);return{lon:s[0],lat:s[1]}}recommendMapView(t,e,o=!1){this.recommendedMapView={};const i=e.map(t=>this.getGeoMap(t)),s=[],r=(i.forEach(t=>{var e,o,i;t&&(Object.keys(this.recommendedMapView).length||(this.recommendedMapView=t["hc-recommended-mapview"]||{}),t.bbox&&([t,e,o,i]=t.bbox,s.push({x1:t,y1:e,x2:o,y2:i})))}),s.length&&MapView.compositeBounds(s));fireEvent(this,"onRecommendMapView",{geoBounds:r,chart:t},function(){var t,e,o,i;r&&this.recommendedMapView&&(this.recommendedMapView.projection||({x1:t,y1:e,x2:o,y2:i}=r,this.recommendedMapView.projection=180<o-t&&90<i-e?{name:"EqualEarth",parallels:[0,0],rotation:[0]}:{name:"LambertConformalConic",parallels:[e,i],rotation:[-(t+o)/2]}),this.recommendedMapView.insets||(this.recommendedMapView.insets=void 0))}),this.geoMap=i[0],o&&t.hasRendered&&!t.userOptions.mapView?.projection&&this.recommendedMapView&&this.update(this.recommendedMapView)}redraw(t){this.chart.series.forEach(t=>{t.useMapGeometry&&(t.isDirty=!0)}),this.chart.redraw(t)}setView(t,e,o=!0,i){t&&(this.center=t),"number"==typeof e&&("number"==typeof this.minZoom&&(e=Math.max(e,this.minZoom)),"number"==typeof this.options.maxZoom&&(e=Math.min(e,this.options.maxZoom)),isNumber(e)&&(this.zoom=e));var s,r,t=this.getProjectedBounds();if(t){const n=this.projection.forward(this.center),{x:a,y:h,width:p,height:d}=this.playingField,c=this.getScale(),m=this.projectedUnitsToPixels({x:t.x1,y:t.y1}),l=this.projectedUnitsToPixels({x:t.x2,y:t.y2}),u=[(t.x1+t.x2)/2,(t.y1+t.y2)/2],g=this.chart.series.some(t=>t.isDrilling);g||(e=m.x,t=l.y,s=l.x,r=m.y,s-e<p?n[0]=u[0]:e<a&&s<a+p?n[0]+=Math.max(e-a,s-p-a)/c:a+p<s&&a<e&&(n[0]+=Math.min(s-p-a,e-a)/c),r-t<d?n[1]=u[1]:t<h&&r<h+d?n[1]-=Math.max(t-h,r-d-h)/c:h+d<r&&h<t&&(n[1]-=Math.min(r-d-h,t-h)/c),this.center=this.projection.inverse(n)),this.insets.forEach(t=>{t.options.field&&(t.hitZone=t.getHitZone(),t.playingField=t.getField())}),this.render()}fireEvent(this,"afterSetView"),o&&this.redraw(i)}projectedUnitsToPixels(t){var e=this.getScale(),o=this.projection.forward(this.center),i=this.playingField,s=i.x+i.width/2,i=i.y+i.height/2;return{x:s-e*(o[0]-t.x),y:i+e*(o[1]-t.y)}}pixelsToLonLat(t){return this.projectedUnitsToLonLat(this.pixelsToProjectedUnits(t))}pixelsToProjectedUnits(t){var{x:t,y:e}=t,o=this.getScale(),i=this.projection.forward(this.center),s=this.playingField,r=s.x+s.width/2,s=s.y+s.height/2;return{x:i[0]+(t-r)/o,y:i[1]-(e-s)/o}}setUpEvents(){const d=this["chart"];let c,m,l;var t=o=>{var{lastTouches:i,pinchDown:s}=d.pointer,r=this.projection,n=o.touches;let{mouseDownX:a,mouseDownY:h}=d,p=0;if(1===s?.length?(a=s[0].chartX,h=s[0].chartY):2===s?.length&&(a=(s[0].chartX+s[1].chartX)/2,h=(s[0].chartY+s[1].chartY)/2),2===n?.length&&i&&(s=Math.sqrt(Math.pow(i[0].chartX-i[1].chartX,2)+Math.pow(i[0].chartY-i[1].chartY,2)),i=Math.sqrt(Math.pow(n[0].chartX-n[1].chartX,2)+Math.pow(n[0].chartY-n[1].chartY,2)),p=Math.log(s/i)/Math.log(.5)),isNumber(a)&&isNumber(h)){s=a+","+h;let{chartX:t,chartY:e}=o.originalEvent;2===n?.length&&(t=(n[0].chartX+n[1].chartX)/2,e=(n[0].chartY+n[1].chartY)/2),s!==m&&(m=s,c=this.projection.forward(this.center),l=(this.projection.options.rotation||[0,0]).slice());var i=r.def&&r.def.bounds,s=i&&zoomFromBounds(i,this.playingField)||-1/0;"Orthographic"===r.options.name&&(n?.length||0)<2&&(this.minZoom||1/0)<1.3*s?(i=440/(this.getScale()*Math.min(d.plotWidth,d.plotHeight)),l&&(r=(a-t)*i-l[0],n=clamp(-l[1]-(h-e)*i,-80,80),s=this.zoom,this.update({projection:{rotation:[-r,-n]}},!1),this.fitToBounds(void 0,void 0,!1),this.zoom=s,d.redraw(!1))):isNumber(t)&&isNumber(e)&&(i=this.getScale(),r=this.projection.hasCoordinates?1:-1,n=this.projection.inverse([c[0]+(a-t)/i,c[1]-(h-e)/i*r]),isNaN(n[0]+n[1])||this.zoomBy(p,n,void 0,!1)),o.preventDefault()}};addEvent(d,"pan",t),addEvent(d,"touchpan",t),addEvent(d,"selection",t=>{var e,o,i,s;t.resetSelection?this.zoomBy():(i=t.x-d.plotLeft,s=t.y-d.plotTop,{y:e,x:o}=this.pixelsToProjectedUnits({x:i,y:s}),{y:i,x:s}=this.pixelsToProjectedUnits({x:i+t.width,y:s+t.height}),this.fitToBounds({x1:o,y1:e,x2:s,y2:i},void 0,!0,!t.originalEvent.touches&&void 0),/^touch/.test(t.originalEvent.type)||d.showResetZoom(),t.preventDefault())})}render(){this.group||(this.group=this.chart.renderer.g("map-view").attr({zIndex:4}).add())}update(t,e=!0,o){var i=t.projection,i=i&&Projection.toString(i)!==Projection.toString(this.options.projection);let s=!1;merge(!0,this.userOptions,t),merge(!0,this.options,t),"insets"in t&&(this.insets.forEach(t=>t.destroy()),this.insets.length=0,s=!0),(i||"fitToGeometry"in t)&&delete this.fitToGeometryCache,(i||s)&&(this.chart.series.forEach(t=>{const e=t.transformGroups;if(t.clearBounds&&t.clearBounds(),t.isDirty=!0,t.isDirtyData=!0,s&&e)for(;1<e.length;){const o=e.pop();o&&o.destroy()}}),i&&(this.projection=new Projection(this.options.projection)),s&&this.createInsets(),t.center||!Object.hasOwnProperty.call(t,"zoom")||isNumber(t.zoom)||this.fitToBounds(void 0,void 0,!1)),t.center||isNumber(t.zoom)?this.setView(this.options.center,t.zoom,!1):"fitToGeometry"in t&&this.fitToBounds(void 0,void 0,!1),e&&this.chart.redraw(o)}zoomBy(i,s,r,n){const a=this.chart,h=this.projection.forward(this.center);if("number"==typeof i){var p,d,i=this.zoom+i;let t,e,o;r&&([r,p]=r,d=this.getScale(),r=r-a.plotLeft-a.plotWidth/2,p=p-a.plotTop-a.plotHeight/2,e=h[0]+r/d,o=h[1]+p/d),"number"==typeof e&&"number"==typeof o&&(r=1-Math.pow(2,this.zoom)/Math.pow(2,i),p=h[0]-e,d=h[1]-o,h[0]-=p*r,h[1]+=d*r,t=this.projection.inverse(h)),this.setView(s||t,i,void 0,n)}else this.fitToBounds(void 0,void 0,void 0,n)}}class MapViewInset extends MapView{constructor(t,e){if(super(t.chart,e),this.id=e.id,this.mapView=t,this.options=merge({center:[0,0]},t.options.insetOptions,e),this.allBounds=[],this.options.geoBounds){const o=t.projection.path(this.options.geoBounds);this.geoBoundsProjectedBox=boundsFromPath(o),this.geoBoundsProjectedPolygon=o.map(t=>[t[1]||0,t[2]||0])}}getField(t=!0){var e=this.hitZone;if(e){const o=t?this.padding:[0,0,0,0],i=e.coordinates[0],s=i.map(t=>t[0]),r=i.map(t=>t[1]),n=Math.min.apply(0,s)+o[3],a=Math.max.apply(0,s)-o[1],h=Math.min.apply(0,r)+o[0],p=Math.max.apply(0,r)-o[2];if(isNumber(n)&&isNumber(h))return{x:n,y:h,width:a-n,height:p-h}}return super.getField.call(this,t)}getHitZone(){const{chart:e,mapView:o,options:i}=this,s=(i.field||{})["coordinates"];if(s){let t=s[0];if("percent"===i.units){const r="mapBoundingBox"===i.relativeTo&&o.getMapBBox()||merge(e.plotBox,{x:0,y:0});t=t.map(t=>[relativeLength(t[0]+"%",r.width,r.x),relativeLength(t[1]+"%",r.height,r.y)])}return{type:"Polygon",coordinates:[t]}}}getProjectedBounds(){return MapView.compositeBounds(this.allBounds)}isInside(t){var{geoBoundsProjectedBox:e,geoBoundsProjectedPolygon:o}=this;return Boolean(e&&t.x>=e.x1&&t.x<=e.x2&&t.y>=e.y1&&t.y<=e.y2&&o&&pointInPolygon(t,o))}render(){const{chart:r,mapView:e,options:n}=this,o=n.borderPath||n.field;if(o&&e.group){let t=!0;this.border||(this.border=r.renderer.path().addClass("highcharts-mapview-inset-border").add(e.group),t=!1),r.styledMode||this.border.attr({stroke:n.borderColor,"stroke-width":n.borderWidth});const a=this.border.strokeWidth(),h="mapBoundingBox"===n.relativeTo&&e.getMapBBox()||e.playingField;var i=(o.coordinates||[]).reduce((t,e)=>e.reduce((t,e,o)=>{let[i,s]=e;return"percent"===n.units&&(i=r.plotLeft+relativeLength(i+"%",h.width,h.x),s=r.plotTop+relativeLength(s+"%",h.height,h.y)),i=crisp(i,a),s=crisp(s,a),t.push(0===o?["M",i,s]:["L",i,s]),t},t),[]);this.border[t?"animate":"attr"]({d:i})}}destroy(){this.border&&(this.border=this.border.destroy()),this.eventsToUnbind.forEach(t=>t())}setUpEvents(){}}export default MapView;