"use strict";import A from"../../Core/Animation/AnimationUtilities.js";const animObject=A["animObject"];import MarkerClusterDefaults from"./MarkerClusterDefaults.js";const clusterDefaults=MarkerClusterDefaults["cluster"];import U from"../../Core/Utilities.js";const{addEvent,defined,error,isArray,isFunction,isObject,isNumber,merge,objectEach,relativeLength,syncTimeout}=U,markerClusterAlgorithms={grid:function(t,e,a,i){const s={},o=this.getGridOffset();let r,n,l,d,u;var p=this.getScaledGridSize(i);for(u=0;u<t.length;u++){var c=valuesToPixels(this,{x:t[u],y:e[u]});r=c.x-o.plotLeft,n=c.y-o.plotTop,l=Math.floor(r/p),d=Math.floor(n/p)+"-"+l,s[d]||(s[d]=[]),s[d].push({dataIndex:a[u],x:t[u],y:e[u]})}return s},kmeans:function(e,a,i,t){const s=this,o=[],r=[],n={},l=t.processedDistance||clusterDefaults.layoutAlgorithm.distance,d=t.iterations;let u=0,p=!0,c,h,f,m=[];t.processedGridSize=t.processedDistance;var x=s.markerClusterAlgorithms?s.markerClusterAlgorithms.grid.call(s,e,a,i,t):{};for(const g in x)1<x[g].length&&(f=getClusterPosition(x[g]),o.push({posX:f.x,posY:f.y,oldX:0,oldY:0,startPointsLen:x[g].length,points:[]}));for(;p;){for(const y of o)y.points.length=0;for(let t=r.length=0;t<e.length;t++)c=e[t],h=a[t],((m=s.getClusterDistancesFromPoint(o,c,h)).length&&m[0].distance<l?o[m[0].clusterIndex].points:r).push({x:c,y:h,dataIndex:i[t]});for(let t=0;t<o.length;t++)1===o[t].points.length&&(m=s.getClusterDistancesFromPoint(o,o[t].points[0].x,o[t].points[0].y))[1].distance<l&&(o[m[1].clusterIndex].points.push(o[t].points[0]),o[m[0].clusterIndex].points.length=0);p=!1;for(let t=0;t<o.length;t++)f=getClusterPosition(o[t].points),o[t].oldX=o[t].posX,o[t].oldY=o[t].posY,o[t].posX=f.x,o[t].posY=f.y,(o[t].posX>o[t].oldX+1||o[t].posX<o[t].oldX-1||o[t].posY>o[t].oldY+1||o[t].posY<o[t].oldY-1)&&(p=!0);d&&(p=u<d-1),u++}for(let t=0,e=o.length;t<e;++t)n["cluster"+t]=o[t].points;for(let t=0,e=r.length;t<e;++t)n["noise"+t]=[r[t]];return n},optimizedKmeans:function(t,e,a,i){var s=this,o=i.processedDistance||clusterDefaults.layoutAlgorithm.gridSize,r=s.getRealExtremes(),n=(s.options.cluster||{}).marker;let l,d={},u,p;if(!s.markerClusterInfo||s.initMaxX&&s.initMaxX<r.maxX||s.initMinX&&s.initMinX>r.minX||s.initMaxY&&s.initMaxY<r.maxY||s.initMinY&&s.initMinY>r.minY)s.initMaxX=r.maxX,s.initMinX=r.minX,s.initMaxY=r.maxY,s.initMinY=r.minY,d=s.markerClusterAlgorithms?s.markerClusterAlgorithms.kmeans.call(s,t,e,a,i):{},s.baseClusters=null;else{s.baseClusters||(s.baseClusters={clusters:s.markerClusterInfo.clusters,noise:s.markerClusterInfo.noise});for(const f of s.baseClusters.clusters){f.pointsOutside=[],f.pointsInside=[];for(const m of f.data){var c=valuesToPixels(s,m),h=valuesToPixels(s,f);l=Math.sqrt(Math.pow(c.x-h.x,2)+Math.pow(c.y-h.y,2)),u=0<=o-(p=(f.clusterZone&&f.clusterZone.marker&&f.clusterZone.marker.radius?f.clusterZone.marker:n&&n.radius?n:clusterDefaults.marker).radius)?o-p:p,l>p+u&&defined(f.pointsOutside)?f.pointsOutside.push(m):defined(f.pointsInside)&&f.pointsInside.push(m)}f.pointsInside.length&&(d[f.id]=f.pointsInside);let t=0;for(const x of f.pointsOutside)d[f.id+"_noise"+t++]=[x]}for(const g of s.baseClusters.noise)d[g.id]=g.data}return d}};let baseGeneratePoints,oldPointsStateId=[],stateIdCounter=0;function compose(t,e){const a=e.prototype;a.markerClusterAlgorithms||(baseGeneratePoints=a.generatePoints,a.markerClusterAlgorithms=markerClusterAlgorithms,a.animateClusterPoint=seriesAnimateClusterPoint,a.destroyClusteredData=seriesDestroyClusteredData,a.generatePoints=seriesGeneratePoints,a.getClusterDistancesFromPoint=seriesGetClusterDistancesFromPoint,a.getClusteredData=seriesGetClusteredData,a.getGridOffset=seriesGetGridOffset,a.getPointsState=seriesGetPointsState,a.getRealExtremes=seriesGetRealExtremes,a.getScaledGridSize=seriesGetScaledGridSize,a.hideClusteredData=seriesHideClusteredData,a.isValidGroupedDataObject=seriesIsValidGroupedDataObject,a.preventClusterCollisions=seriesPreventClusterCollisions,addEvent(e,"destroy",a.destroyClusteredData),(t.plotOptions||{}).series=merge((t.plotOptions||{}).series,MarkerClusterDefaults))}function destroyOldPoints(e){if(e){let t;for(const a of Object.keys(e))(t=e[a]).point&&t.point.destroy&&t.point.destroy()}}function fadeInElement(t,e,a){t.attr({opacity:e}).animate({opacity:1},a)}function fadeInNewPointAndDestoryOld(t,e,a,i){fadeInStatePoint(t,i,a,!0,!0);for(const s of e)s.point&&s.point.destroy&&s.point.destroy()}function fadeInStatePoint(t,e,a,i,s){t.point&&(i&&t.point.graphic&&(t.point.graphic.show(),fadeInElement(t.point.graphic,e,a)),s&&t.point.dataLabel&&(t.point.dataLabel.show(),fadeInElement(t.point.dataLabel,e,a)))}function getClusterPosition(e){var a=e.length;let i=0,s=0;for(let t=0;t<a;t++)i+=e[t].x,s+=e[t].y;return{x:i/a,y:s/a}}function getDataState(t,e){const a=[];return a.length=e,t.clusters.forEach(function(t){t.data.forEach(function(t){a[t.dataIndex]=t})}),t.noise.forEach(function(t){a[t.data[0].dataIndex]=t.data[0]}),a}function getStateId(){return Math.random().toString(36).substring(2,7)+"-"+stateIdCounter++}function hideStatePoint(t,e,a){t.point&&(e&&t.point.graphic&&t.point.graphic.hide(),a&&t.point.dataLabel&&t.point.dataLabel.hide())}function onPointDrillToCluster(t){const e=t.point||t.target;e.firePointEvent("drillToCluster",t,function(s){const t=s.point||s.target,e=t.series,o=t.series.xAxis,r=t.series.yAxis,n=t.series.chart,{inverted:l,mapView:a,pointer:d}=n,i=e.options.cluster,u=(i||{}).drillToCluster;if(u&&t.clusteredData){var s=t.clusteredData.map(t=>t.x).sort((t,e)=>t-e),p=t.clusteredData.map(t=>t.y).sort((t,e)=>t-e),c=s[0],s=s[s.length-1],h=p[0],p=p[p.length-1],f=Math.abs(.1*(s-c)),m=Math.abs(.1*(p-h)),x=Math.min(c,s)-f,c=Math.max(c,s)+f,s=Math.min(h,p)-m,f=Math.max(h,p)+m;if(a)a.fitToBounds({x1:x,x2:c,y1:s,y2:f});else if(o&&r){let t=o.toPixels(x),e=o.toPixels(c),a=r.toPixels(s),i=r.toPixels(f);l&&([t,e,a,i]=[a,i,t,e]),t>e&&([t,e]=[e,t]),a>i&&([a,i]=[i,a]),d&&(d.zoomX=!0,d.zoomY=!0),n.transform({from:{x:t,y:a,width:e-t,height:i-a}})}}})}function pixelsToValues(t,e){const{chart:a,xAxis:i,yAxis:s}=t;return a.mapView?a.mapView.pixelsToProjectedUnits(e):{x:i?i.toValue(e.x):0,y:s?s.toValue(e.y):0}}function seriesAnimateClusterPoint(t){const e=this.chart,a=e.mapView,i=this.options.cluster,s=animObject((i||{}).animation),o=s.duration||500,r=(this.markerClusterInfo||{}).pointsState,n=(r||{}).newState,l=(r||{}).oldState,d=[];let u,p,c,h,f,m,x,g=!1,y=!1;var C;l&&n&&(C=valuesToPixels(this,c=n[t.stateId]),m=C.x-(a?0:e.plotLeft),x=C.y-(a?0:e.plotTop),1===c.parentsId.length?(u=(n||{})[t.stateId].parentsId[0],p=l[u],c.point&&c.point.graphic&&p&&p.point&&p.point.plotX&&p.point.plotY&&p.point.plotX!==c.point.plotX&&p.point.plotY!==c.point.plotY&&(h=c.point.graphic.getBBox(),f=c.point.graphic&&c.point.graphic.isImg?0:h.width/2,c.point.graphic.attr({x:p.point.plotX-f,y:p.point.plotY-f}),c.point.graphic.animate({x:m-(c.point.graphic.radius||0),y:x-(c.point.graphic.radius||0)},s,function(){y=!0,p.point&&p.point.destroy&&p.point.destroy()}),c.point.dataLabel&&c.point.dataLabel.alignAttr&&p.point.dataLabel&&p.point.dataLabel.alignAttr&&(c.point.dataLabel.attr({x:p.point.dataLabel.alignAttr.x,y:p.point.dataLabel.alignAttr.y}),c.point.dataLabel.animate({x:c.point.dataLabel.alignAttr.x,y:c.point.dataLabel.alignAttr.y},s)))):0===c.parentsId.length?(hideStatePoint(c,!0,!0),syncTimeout(function(){fadeInStatePoint(c,.1,s,!0,!0)},o/2)):(hideStatePoint(c,!0,!0),c.parentsId.forEach(function(t){l&&l[t]&&(p=l[t],d.push(p),p.point&&p.point.graphic&&(g=!0,p.point.graphic.show(),p.point.graphic.animate({x:m-(p.point.graphic.radius||0),y:x-(p.point.graphic.radius||0),opacity:.4},s,function(){y=!0,fadeInNewPointAndDestoryOld(c,d,s,.7)}),p.point.dataLabel&&-9999!==p.point.dataLabel.y&&c.point&&c.point.dataLabel&&c.point.dataLabel.alignAttr&&(p.point.dataLabel.show(),p.point.dataLabel.animate({x:c.point.dataLabel.alignAttr.x,y:c.point.dataLabel.alignAttr.y,opacity:.4},s))))}),syncTimeout(function(){y||fadeInNewPointAndDestoryOld(c,d,s,.85)},o),g||syncTimeout(function(){fadeInNewPointAndDestoryOld(c,d,s,.1)},o/2)))}function seriesDestroyClusteredData(){const t=this.markerClusterSeriesData;(t||[]).forEach(function(t){t&&t.destroy&&t.destroy()}),this.markerClusterSeriesData=null}function seriesGeneratePoints(){const a=this,t=a.chart,e=t.mapView,i=a.xData,s=a.yData,o=a.options.cluster,r=a.getRealExtremes(),n=[],l=[],d=[];let u,p,c,h,f,m,x,g,y,C,I,S,P,D,k,b,M;if(e&&a.is("mappoint")&&i&&s&&(a.options.data||[]).forEach((t,e)=>{t=a.projectPoint(t);t&&(i[e]=t.x,s[e]=t.y)}),o&&o.enabled&&i&&i.length&&s&&s.length&&!t.polar){I=o.layoutAlgorithm.type,(k=o.layoutAlgorithm).processedGridSize=relativeLength(k.gridSize||clusterDefaults.layoutAlgorithm.gridSize,t.plotWidth),k.processedDistance=relativeLength(k.distance||clusterDefaults.layoutAlgorithm.distance,t.plotWidth),h=k.kmeansThreshold||clusterDefaults.layoutAlgorithm.kmeansThreshold;var A=k.processedGridSize/2,X=pixelsToValues(a,{x:0,y:0}),A=pixelsToValues(a,{x:A,y:A});for(f=Math.abs(X.x-A.x),m=Math.abs(X.y-A.y),M=0;M<i.length;M++)a.dataMaxX||(defined(g)&&defined(x)&&defined(C)&&defined(y)?isNumber(s[M])&&isNumber(C)&&isNumber(y)&&(g=Math.max(i[M],g),x=Math.min(i[M],x),C=Math.max(s[M]||C,C),y=Math.min(s[M]||y,y)):(g=x=i[M],C=y=s[M])),i[M]>=r.minX-f&&i[M]<=r.maxX+f&&(s[M]||r.minY)>=r.minY-m&&(s[M]||r.maxY)<=r.maxY+m&&(n.push(i[M]),l.push(s[M]),d.push(M));defined(g)&&defined(x)&&isNumber(C)&&isNumber(y)&&(a.dataMaxX=g,a.dataMinX=x,a.dataMaxY=C,a.dataMinY=y),P=(D=(S=isFunction(I)?I:a.markerClusterAlgorithms?I&&a.markerClusterAlgorithms[I]?a.markerClusterAlgorithms[I]:n.length<h?a.markerClusterAlgorithms.kmeans:a.markerClusterAlgorithms.grid:function(){return!1}).call(this,n,l,d,k))&&a.getClusteredData(D,o),u=o.animation&&a.markerClusterInfo&&a.markerClusterInfo.pointsState&&a.markerClusterInfo.pointsState.oldState?(destroyOldPoints(a.markerClusterInfo.pointsState.oldState),a.markerClusterInfo.pointsState.newState):{},p=i.length,c=a.markerClusterInfo,P&&(a.processedXData=P.groupedXData,a.processedYData=P.groupedYData,a.hasGroupedData=!0,a.markerClusterInfo=P,a.groupMap=P.groupMap),baseGeneratePoints.apply(this),P&&a.markerClusterInfo&&((a.markerClusterInfo.clusters||[]).forEach(function(t){(b=a.points[t.index]).isCluster=!0,b.clusteredData=t.data,b.clusterPointsAmount=t.data.length,t.point=b,addEvent(b,"click",onPointDrillToCluster)}),(a.markerClusterInfo.noise||[]).forEach(function(t){t.point=a.points[t.index]}),o.animation&&a.markerClusterInfo&&(a.markerClusterInfo.pointsState={oldState:u,newState:a.getPointsState(P,c,p)}),o.animation?this.hideClusteredData():this.destroyClusteredData(),this.markerClusterSeriesData=this.hasGroupedData?this.points:null)}else baseGeneratePoints.apply(this)}function seriesGetClusterDistancesFromPoint(e,a,i){const s=[];for(let t=0;t<e.length;t++){var o=valuesToPixels(this,{x:a,y:i}),r=valuesToPixels(this,{x:e[t].posX,y:e[t].posY}),o=Math.sqrt(Math.pow(o.x-r.x,2)+Math.pow(o.y-r.y,2));s.push({clusterIndex:t,distance:o})}return s.sort((t,e)=>t.distance-e.distance)}function seriesGetClusteredData(t,e){const a=this,i=[],s=[],o=[],r=[],n=[],l=Math.max(2,e.minimumClusterSize||2);let d=0,u,p,c,h,f,m,x,g,y,C,I,S,P,D;if(isFunction(e.layoutAlgorithm.type)&&!a.isValidGroupedDataObject(t))return error("Highcharts marker-clusters module: The custom algorithm result is not valid!",!1,a.chart),!1;for(D in t)if(t[D].length>=l){if(c=t[D],u=getStateId(),f=c.length,e.zones)for(P=0;P<e.zones.length;P++)f>=e.zones[P].from&&f<=e.zones[P].to&&((I=e.zones[P]).zoneIndex=P,C=e.zones[P].marker,S=e.zones[P].className);for(y=getClusterPosition(c),x="grid"!==e.layoutAlgorithm.type||e.allowOverlap?{x:y.x,y:y.y}:(m=a.options.marker||{},a.preventClusterCollisions({x:y.x,y:y.y,key:D,groupedData:t,gridSize:a.getScaledGridSize(e.layoutAlgorithm),defaultRadius:m.radius||3+(m.lineWidth||0),clusterRadius:C&&C.radius?C.radius:(e.marker||{}).radius||clusterDefaults.marker.radius})),P=0;P<f;P++)c[P].parentStateId=u;if(o.push({x:x.x,y:x.y,id:D,stateId:u,index:d,data:c,clusterZone:I,clusterZoneClassName:S}),i.push(x.x),s.push(x.y),n.push({options:{formatPrefix:"cluster",dataLabels:e.dataLabels,marker:merge(e.marker,{states:e.states},C||{})}}),a.options.data&&a.options.data.length)for(P=0;P<f;P++)isObject(a.options.data[c[P].dataIndex])&&(c[P].options=a.options.data[c[P].dataIndex]);d++,C=null}else for(P=0;P<t[D].length;P++)p=t[D][P],u=getStateId(),g=null,h=((a.options||{}).data||[])[p.dataIndex],i.push(p.x),s.push(p.y),p.parentStateId=u,r.push({x:p.x,y:p.y,id:D,stateId:u,index:d,data:t[D]}),g=h&&"object"==typeof h&&!isArray(h)?merge(h,{x:p.x,y:p.y}):{userOptions:h,x:p.x,y:p.y},n.push({options:g}),d++;return{clusters:o,noise:r,groupedXData:i,groupedYData:s,groupMap:n}}function seriesGetGridOffset(){const t=this,e=t.chart,a=t.xAxis,i=t.yAxis;let s=0,o=0;return s=a&&t.dataMinX&&t.dataMaxX?a.reversed?a.toPixels(t.dataMaxX):a.toPixels(t.dataMinX):e.plotLeft,o=i&&t.dataMinY&&t.dataMaxY?i.reversed?i.toPixels(t.dataMinY):i.toPixels(t.dataMaxY):e.plotTop,{plotLeft:s,plotTop:o}}function seriesGetPointsState(t,e,a){const i=e?getDataState(e,a):[],s=getDataState(t,a),o={};var r,n;oldPointsStateId=[],t.clusters.forEach(function(t){o[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),t.noise.forEach(function(t){o[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}});for(let t=0;t<s.length;t++)r=s[t],n=i[t],r&&n&&r.parentStateId&&n.parentStateId&&o[r.parentStateId]&&-1===o[r.parentStateId].parentsId.indexOf(n.parentStateId)&&(o[r.parentStateId].parentsId.push(n.parentStateId),-1===oldPointsStateId.indexOf(n.parentStateId)&&oldPointsStateId.push(n.parentStateId));return o}function seriesGetRealExtremes(){var t=this.chart,e=t.mapView?0:t.plotLeft,a=pixelsToValues(this,{x:e,y:t.mapView?0:t.plotTop}),e=pixelsToValues(this,{x:e+t.plotWidth,y:e+t.plotHeight}),t=a.x,i=e.x,a=a.y,e=e.y;return{minX:Math.min(t,i),maxX:Math.max(t,i),minY:Math.min(a,e),maxY:Math.max(a,e)}}function seriesGetScaledGridSize(t){const e=this,a=e.xAxis,i=this.chart.mapView,s=t.processedGridSize||clusterDefaults.layoutAlgorithm.gridSize;let o=!0,r=1,n=1;e.gridValueSize||(i?e.gridValueSize=s/i.getScale():e.gridValueSize=Math.abs(a.toValue(s)-a.toValue(0)));for(var l=+(s/(i?e.gridValueSize*i.getScale():a.toPixels(e.gridValueSize)-a.toPixels(0))).toFixed(14);o&&1!=l;){var d=Math.pow(2,r);.75<l&&l<1.25?o=!1:1/d<=l&&l<1/d*2?(o=!1,n=d):l<=d&&d/2<l&&(o=!1,n=1/d),r++}return s/n/l}function seriesHideClusteredData(){const t=this.markerClusterSeriesData,e=((this.markerClusterInfo||{}).pointsState||{}).oldState||{},a=oldPointsStateId.map(t=>(e[t].point||{}).id||"");(t||[]).forEach(function(t){t&&-1!==a.indexOf(t.id)?(t.graphic&&t.graphic.hide(),t.dataLabel&&t.dataLabel.hide()):t&&t.destroy&&t.destroy()})}function seriesIsValidGroupedDataObject(t){let e=!1,a;return!!isObject(t)&&(objectEach(t,function(t){if(e=!0,isArray(t)&&t.length){for(a=0;a<t.length;a++)if(!isObject(t[a])||!t[a].x||!t[a].y)return void(e=!1)}else e=!1}),e)}function seriesPreventClusterCollisions(t){const e=this,[a,i]=t.key.split("-").map(parseFloat),s=t.gridSize,o=t.groupedData,r=t.defaultRadius,n=t.clusterRadius,l=i*s,d=a*s,u=valuesToPixels(e,t),p=[],c=(e.options.cluster||{}).marker,h=(e.options.cluster||{}).zones,f=e.getGridOffset();let m=u.x,x=u.y,g,y=0,C,I,S,P,D,k,b,M,A,X,Y,v,L;for(m-=f.plotLeft,x-=f.plotTop,b=1;b<5;b++)for(S=b%2?-1:1,P=b<3?-1:1,D=Math.floor((m+S*n)/s),L=[(k=Math.floor((x+P*n)/s))+"-"+D,k+"-"+i,a+"-"+D],M=0;M<L.length;M++)-1===p.indexOf(L[M])&&L[M]!==t.key&&p.push(L[M]);for(const T of p)if(o[T]){o[T].posX||(Y=getClusterPosition(o[T]),o[T].posX=Y.x,o[T].posY=Y.y);const G=valuesToPixels(e,{x:o[T].posX||0,y:o[T].posY||0});if(C=G.x-f.plotLeft,I=G.y-f.plotTop,[X,A]=T.split("-").map(parseFloat),h)for(g=o[T].length,b=0;b<h.length;b++)g>=h[b].from&&g<=h[b].to&&(y=defined((h[b].marker||{}).radius)?h[b].marker.radius||0:(c&&c.radius?c:clusterDefaults.marker).radius);1<o[T].length&&0===y&&c&&c.radius?y=c.radius:1===o[T].length&&(y=r),v=n+y,y=0,A!==i&&Math.abs(m-C)<v&&(m=A-i<0?l+n:l+s-n),X!==a&&Math.abs(x-I)<v&&(x=X-a<0?d+n:d+s-n)}const G=pixelsToValues(e,{x:m+f.plotLeft,y:x+f.plotTop});return o[t.key].posX=G.x,o[t.key].posY=G.y,G}function valuesToPixels(t,e){const{chart:a,xAxis:i,yAxis:s}=t;return a.mapView?a.mapView.projectedUnitsToPixels(e):{x:i?i.toPixels(e.x):0,y:s?s.toPixels(e.y):0}}const MarkerClusterScatter={compose:compose};export default MarkerClusterScatter;