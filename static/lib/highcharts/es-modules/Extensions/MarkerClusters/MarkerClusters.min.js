"use strict";import A from"../../Core/Animation/AnimationUtilities.js";const animObject=A["animObject"];import D from"../../Core/Defaults.js";const defaultOptions=D["defaultOptions"];import H from"../../Core/Globals.js";const composed=H["composed"];import MarkerClusterDefaults from"./MarkerClusterDefaults.js";import MarkerClusterScatter from"./MarkerClusterScatter.js";import U from"../../Core/Utilities.js";const{addEvent,defined,error,isFunction,merge,pushUnique,syncTimeout}=U;function compose(t,e,r,o){var s,n;pushUnique(composed,"MarkerClusters")&&(s=o.prototype.pointClass,n=o.types["scatter"],addEvent(t,"setExtremes",onAxisSetExtremes),addEvent(e,"render",onChartRender),addEvent(s,"drillToCluster",onPointDrillToCluster),addEvent(s,"update",onPointUpdate),addEvent(o,"afterRender",onSeriesAfterRender),n&&MarkerClusterScatter.compose(r,n))}function onAxisSetExtremes(){const t=this.chart;let e=0;for(const r of t.series)r.markerClusterInfo&&(e=animObject((r.options.cluster||{}).animation).duration||0);syncTimeout(()=>{t.tooltip&&t.tooltip.destroy()},e)}function onChartRender(){for(const r of this.series||[])if(r.markerClusterInfo){var t=r.options.cluster,e=((r.markerClusterInfo||{}).pointsState||{}).oldState;if((t||{}).animation&&r.markerClusterInfo&&0===(r.chart.pointer?.pinchDown||[]).length&&"pan"!==((r.xAxis||{}).eventArgs||{}).trigger&&e&&Object.keys(e).length){for(const o of r.markerClusterInfo.clusters)r.animateClusterPoint(o);for(const s of r.markerClusterInfo.noise)r.animateClusterPoint(s)}}}function onPointDrillToCluster(t){const e=t.point||t.target,r=e.series,o=r.options.cluster,s=((o||{}).events||{}).drillToCluster;isFunction(s)&&s.call(this,t)}function onPointUpdate(){if(this.dataGroup)return error("Highcharts marker-clusters module: Running `Point.update` when point belongs to clustered series is not supported.",!1,this.series.chart),!1}function onSeriesAfterRender(){var t=this,e=(t.options.cluster||{}).drillToCluster;if(t.markerClusterInfo&&t.markerClusterInfo.clusters)for(const r of t.markerClusterInfo.clusters)r.point&&r.point.graphic&&(r.point.graphic.addClass("highcharts-cluster-point"),e&&r.point&&(r.point.graphic.css({cursor:"pointer"}),r.point.dataLabel&&r.point.dataLabel.css({cursor:"pointer"})),defined(r.clusterZone)&&r.point.graphic.addClass(r.clusterZoneClassName||"highcharts-cluster-zone-"+r.clusterZone.zoneIndex))}(defaultOptions.plotOptions||{}).series=merge((defaultOptions.plotOptions||{}).series,MarkerClusterDefaults);const MarkerClusters={compose:compose};export default MarkerClusters;