"use strict";import BoostableMap from"./BoostableMap.js";import Boostables from"./Boostables.js";import BoostChart from"./BoostChart.js";const{getBoostClipRect,isChartSeriesBoosting}=BoostChart;import D from"../../Core/Defaults.js";const getOptions=D["getOptions"];import H from"../../Core/Globals.js";const{composed,doc,noop,win}=H;import U from"../../Core/Utilities.js";const{addEvent,destroyObjectProperties,error,extend,fireEvent,isArray,isNumber,pick,pushUnique,wrap,defined}=U;import WGLRenderer from"./WGLRenderer.js";const CHUNK_SIZE=3e3;let index,mainCanvas;function allocateIfNotSeriesBoosting(t,e){var o=e.boost;t&&o&&o.target&&o.canvas&&!isChartSeriesBoosting(e.chart)&&t.allocateBufferForSingleSeries(e)}function boostEnabled(t){return pick(t&&t.options&&t.options.boost&&t.options.boost.enabled,!0)}function compose(t,o,e){if(pushUnique(composed,"Boost.Series")){const s=getOptions().plotOptions,r=t.prototype;if(addEvent(t,"destroy",onSeriesDestroy),addEvent(t,"hide",onSeriesHide),e&&(r.renderCanvas=seriesRenderCanvas),wrap(r,"getExtremes",wrapSeriesGetExtremes),wrap(r,"processData",wrapSeriesProcessData),wrap(r,"searchPoint",wrapSeriesSearchPoint),["translate","generatePoints","drawTracker","drawPoints","render"].forEach(t=>wrapSeriesFunctions(r,o,t)),Boostables.forEach(t=>{const e=s[t];e&&(e.boostThreshold=5e3,e.boostData=[],o[t].prototype.fillOpacity=!0)}),e){const{area:i,areaspline:a,bubble:n,column:c,heatmap:p,scatter:l,treemap:h}=o;if(i&&extend(i.prototype,{fill:!0,fillOpacity:!0,sampling:!0}),a&&extend(a.prototype,{fill:!0,fillOpacity:!0,sampling:!0}),n){const d=n.prototype;delete d.buildKDTree,wrap(d,"markerAttribs",function(t){return!this.boosted&&t.apply(this,[].slice.call(arguments,1))})}c&&extend(c.prototype,{fill:!0,sampling:!0}),l&&(l.prototype.fill=!0),[p,h].forEach(t=>{t&&wrap(t.prototype,"drawPoints",wrapSeriesDrawPoints)})}}return t}function createAndAttachRenderer(t,e){const o=t.constructor,s=t.seriesGroup||e.group;let r=t.chartWidth,i=t.chartHeight,a=t,n=!1;isChartSeriesBoosting(t)?a=t:(a=e,n=Boolean(e.options.events?.click||e.options.point?.events?.click));const c=a.boost=a.boost||{};if(mainCanvas=mainCanvas||doc.createElement("canvas"),c.target||(c.canvas=mainCanvas,t.renderer.forExport,a.renderTarget=c.target=t.renderer.image("",0,0,r,i).addClass("highcharts-boost-canvas").add(s),c.clear=function(){c.target.attr({href:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII="})},c.copy=function(){c.resize(),c.target.attr({href:c.canvas.toDataURL("image/png")})},c.resize=function(){r=t.chartWidth,i=t.chartHeight,(c.targetFo||c.target).attr({x:0,y:0,width:r,height:i}).css({pointerEvents:n?void 0:"none",mixedBlendMode:"normal",opacity:1}).addClass(n?"highcharts-tracker":""),a instanceof o&&a.boost?.markerGroup?.translate(t.plotLeft,t.plotTop)},c.clipRect=t.renderer.clipRect(),(c.targetFo||c.target).attr({zIndex:e.options.zIndex}),a instanceof o&&(a.boost.markerGroup=a.renderer.g().add(s).translate(e.xAxis.pos,e.yAxis.pos))),c.canvas.width=r,c.canvas.height=i,c.clipRect){const p=getBoostClipRect(t,a),l=p.width===t.clipBox.width&&p.height===t.clipBox.height?s:c.targetFo||c.target;c.clipRect.attr(p),l?.clip(c.clipRect)}return c.resize(),c.clear(),c.wgl||(c.wgl=new WGLRenderer(t=>{t.settings.debug.timeBufferCopy&&console.time("buffer copy"),c.copy(),t.settings.debug.timeBufferCopy&&console.timeEnd("buffer copy")}),c.wgl.init(c.canvas)||error("[highcharts boost] - unable to init WebGL renderer"),c.wgl.setOptions(t.options.boost||{}),a instanceof o&&c.wgl.allocateBuffer(t)),c.wgl.setSize(r,i),c.wgl}function destroyGraphics(o){var s=o.points;if(s){let t,e;for(e=0;e<s.length;e+=1)(t=s[e])&&t.destroyElements&&t.destroyElements()}["graph","area","tracker"].forEach(t=>{const e=o[t];e&&(o[t]=e.destroy())});for(const t of o.zones)destroyObjectProperties(t,void 0,!0)}function eachAsync(t,e,o,s,r,i){r=r||0,s=s||CHUNK_SIZE;var a=r+s;let n=!0;for(;n&&r<a&&r<t.length;)n=e(t[r],r),++r;n&&(r<t.length?i?eachAsync(t,e,o,s,r,i):win.requestAnimationFrame?win.requestAnimationFrame(function(){eachAsync(t,e,o,s,r)}):setTimeout(eachAsync,0,t,e,o,s,r):o&&o())}function enterBoost(e){e.boost=e.boost||{getPoint:t=>getPoint(e,t)};const o=e.boost.altered=[];if(["allowDG","directTouch","stickyTracking"].forEach(t=>{o.push({prop:t,val:e[t],own:Object.hasOwnProperty.call(e,t)})}),e.allowDG=!1,e.directTouch=!1,e.stickyTracking=!0,e.finishedAnimating=!0,e.labelBySeries&&(e.labelBySeries=e.labelBySeries.destroy()),e.is("scatter")&&e.data.length){for(const t of e.data)t?.destroy?.();e.data.length=0,e.points.length=0,delete e.processedData}}function exitBoost(e){const t=e.boost,o=e.chart,s=o.boost;if(s?.markerGroup){s.markerGroup.destroy(),s.markerGroup=void 0;for(const r of o.series)r.markerGroup=void 0,r.markerGroup=r.plotGroup("markerGroup","markers","visible",1,o.seriesGroup).addClass("highcharts-tracker")}t&&((t.altered||[]).forEach(t=>{t.own?e[t.prop]=t.val:delete e[t.prop]}),t.clear&&t.clear()),(o.seriesGroup||e.group)?.clip()}function hasExtremes(t,e){var o=t.options,s=o.data,r=t.xAxis&&t.xAxis.options,i=t.yAxis&&t.yAxis.options,t=t.colorAxis&&t.colorAxis.options;return s.length>(o.boostThreshold||Number.MAX_VALUE)&&isNumber(i.min)&&isNumber(i.max)&&(!e||isNumber(r.min)&&isNumber(r.max))&&(!t||isNumber(t.min)&&isNumber(t.max))}const getSeriesBoosting=(t,e)=>!t.forceCrop&&(isChartSeriesBoosting(t.chart)||(e?e.length:0)>=(t.options.boostThreshold||Number.MAX_VALUE));function onSeriesDestroy(){const e=this,t=e.chart;t.boost&&t.boost.markerGroup===e.markerGroup&&(e.markerGroup=null),t.hoverPoints&&(t.hoverPoints=t.hoverPoints.filter(function(t){return t.series===e})),t.hoverPoint&&t.hoverPoint.series===e&&(t.hoverPoint=null)}function onSeriesHide(){const t=this.boost;t&&t.canvas&&t.target&&(t.wgl&&t.wgl.clear(),t.clear&&t.clear())}function renderIfNotSeriesBoosting(t){const e=t.boost;e&&e.canvas&&e.target&&e.wgl&&!isChartSeriesBoosting(t.chart)&&e.wgl.render(t.chart)}function getPoint(t,e){const o=t.options,s=t.xAxis,r=t.pointClass;if(e instanceof r)return e;const i=t.xData||o.xData||t.processedXData||!1,a=new r(t,(t.options.data||[])[e.i],i?i[e.i]:void 0);return a.category=pick(s.categories?s.categories[a.x]:a.x,a.x),a.dist=e.dist,a.distX=e.distX,a.plotX=e.plotX,a.plotY=e.plotY,a.index=e.i,a.percentage=e.percentage,a.isInside=t.isPointInside(a),a}function scatterProcessData(t){const e=this,{options:o,xAxis:s,yAxis:r}=e;if(!(e.isDirty||s.isDirty||r.isDirty||t))return!1;e.yAxis.setTickInterval();var t=o.boostThreshold||0,i=o.cropThreshold,a=o.data||e.data,n=e.xData,c=s.getExtremes(),p=c.max??Number.MAX_VALUE,l=c.min??-Number.MAX_VALUE,h=e.yData,d=r.getExtremes(),m=d.max??Number.MAX_VALUE,u=d.min??-Number.MAX_VALUE;if(!e.boosted&&s.old&&r.old&&l>=(s.old.min??-Number.MAX_VALUE)&&p<=(s.old.max??Number.MAX_VALUE)&&u>=(r.old.min??-Number.MAX_VALUE)&&m<=(r.old.max??Number.MAX_VALUE))return e.processedXData??(e.processedXData=n),e.processedYData??(e.processedYData=h),!0;if(!t||a.length<t||i&&!e.forceCrop&&!e.getExtremesFromAll&&!o.getExtremesFromAll&&a.length<i)return e.processedXData=n,e.processedYData=h,!0;const g=[],f=[],b=[],A=!(isNumber(c.max)||isNumber(c.min)),x=!(isNumber(d.max)||isNumber(d.min));let y=!1,v,w=n[0],B=n[0],E,S=h[0],k=h[0];for(let t=0,e=n.length;t<e;++t)v=n[t],E=h[t],l<=v&&v<=p&&u<=E&&E<=m?(g.push({x:v,y:E}),f.push(v),b.push(E),A&&(w=Math.max(w,v),B=Math.min(B,v)),x&&(S=Math.max(S,E),k=Math.min(k,E))):y=!0;return A&&((t=s.options).max??(t.max=w),(a=s.options).min??(a.min=B)),x&&((i=r.options).max??(i.max=S),(c=r.options).min??(c.min=k)),e.cropped=y,e.cropStart=0,e.processedXData=f,e.processedYData=b,getSeriesBoosting(e,f)||(e.processedData=g),!0}function seriesRenderCanvas(){const t=this.options||{},l=this.chart,e=l.boost,o=this.boost,h=this.xAxis,d=this.yAxis,s=t.xData||this.processedXData,m=t.yData||this.processedYData,r=this.processedData||t.data,i=h.getExtremes(),u=i.min-(h.minPointOffset||0),g=i.max+(h.minPointOffset||0),a=d.getExtremes(),f=a.min-(d.minPointOffset||0),b=a.max+(d.minPointOffset||0),n={},A=!!this.sampling,c=t.enableMouseTracking,R=t.threshold,x=this.pointArrayMap&&"low,high"===this.pointArrayMap.join(","),y=!!t.stacking,p=this.cropStart||0,O=this.requireSorting,v=!s,w="x"===t.findNearestPointBy,B=this.xData||this.options.xData||this.processedXData||!1,E=pick(t.lineWidth,1);let S=!1,k,D=d.getThreshold(R),P,C,G,N;if(!h.isPanning&&!d.isPanning&&(S=createAndAttachRenderer(l,this),l.boosted=!0,this.visible)){(this.points||this.graph)&&destroyGraphics(this),isChartSeriesBoosting(l)?(this.markerGroup&&this.markerGroup!==e?.markerGroup&&this.markerGroup.destroy(),this.markerGroup=e?.markerGroup,o&&o.target&&(this.renderTarget=o.target=o.target.destroy())):(this.markerGroup===e?.markerGroup&&(this.markerGroup=void 0),this.markerGroup=this.plotGroup("markerGroup","markers","visible",1,l.seriesGroup).addClass("highcharts-tracker"));const M=this.points=[],T=(t,e,o,s)=>{const r=!!B&&B[p+o],i=t=>{l.inverted&&(t=h.len-t,e=d.len-e),M.push({destroy:noop,x:r,clientX:t,plotX:t,plotY:e,i:p+o,percentage:s})};t=Math.ceil(t),index=w?t:t+","+e,c&&(n[index]?r===B[B.length-1]&&(M.length--,i(t)):(n[index]=!0,i(t)))},X=(this.buildKDTree=noop,fireEvent(this,"renderCanvas"),this.is("line")&&1<E&&o?.target&&e&&!e.lineWidthFilter&&(e.lineWidthFilter=l.renderer.definition({tagName:"filter",children:[{tagName:"feMorphology",attributes:{operator:"dilate",radius:.25*E}}],attributes:{id:"linewidth"}}),o.target.attr({filter:"url(#linewidth)"})),S&&(allocateIfNotSeriesBoosting(S,this),S.pushSeries(this),renderIfNotSeriesBoosting(this)),S.settings),U=()=>{fireEvent(this,"renderedCanvas"),delete this.buildKDTree,this.options&&this.buildKDTree(),X.debug.timeKDTree&&console.timeEnd("kd tree building")};l.renderer.forExport||(X.debug.timeKDTree&&console.time("kd tree building"),eachAsync(y?this.data.slice(p):s||r,function(t,e){var o=void 0===l.index;let s,r,i,a,n,c=!1,p=!0;return!defined(t)||(o||(r=v?(s=t[0],t[1]):(s=t,m[e]),x?(v&&(r=t.slice(1,3)),c=r[0],r=r[1]):y&&(s=t.x,r=t.stackY,c=r-t.y,n=t.percentage),O||(p=(r||0)>=f&&r<=b),null!==r&&s>=u&&s<=g&&p&&(i=h.toPixels(s,!0),A?(void 0!==G&&i!==k||(x||(c=r),(void 0===N||r>C)&&(C=r,N=e),(void 0===G||c<P)&&(P=c,G=e)),w&&i===k||(void 0!==G&&(a=d.toPixels(C,!0),D=d.toPixels(P,!0),T(i,a,N,n),D!==a&&T(i,D,G,n)),G=N=void 0,k=i)):(a=Math.ceil(d.toPixels(r,!0)),T(i,a,e,n)))),!o)},U))}}function wrapSeriesDrawPoints(t){let e=!0;if(!(e=this.chart.options&&this.chart.options.boost?void 0===this.chart.options.boost.enabled||this.chart.options.boost.enabled:e)||!this.boosted)return t.call(this);this.chart.boosted=!0;const o=createAndAttachRenderer(this.chart,this);o&&(allocateIfNotSeriesBoosting(o,this),o.pushSeries(this)),renderIfNotSeriesBoosting(this)}function wrapSeriesFunctions(t,e,o){function s(t){var e=this.options.stacking&&("translate"===o||"generatePoints"===o);this.boosted&&!e&&boostEnabled(this.chart)&&"heatmap"!==this.type&&"treemap"!==this.type&&BoostableMap[this.type]&&0!==this.options.boostThreshold?"render"===o&&this.renderCanvas&&this.renderCanvas():t.call(this)}if(wrap(t,o,s),"translate"===o)for(const r of["column","arearange","columnrange","heatmap","treemap"])e[r]&&wrap(e[r].prototype,o,s)}function wrapSeriesGetExtremes(t){if(this.boosted){if(hasExtremes(this))return{};if(this.xAxis.isPanning||this.yAxis.isPanning)return this}return t.apply(this,[].slice.call(arguments,1))}function wrapSeriesProcessData(t){let e=this.options.data;if(boostEnabled(this.chart)&&BoostableMap[this.type]){var o=this,s=o.is("scatter")&&!o.is("bubble")&&!o.is("heatmap");if(!getSeriesBoosting(o,e)||s||o.options.stacking||!hasExtremes(o,!0)){if(o.boosted&&(o.xAxis?.isPanning||o.yAxis?.isPanning))return;s&&!o.yAxis.treeGrid?scatterProcessData.call(o,arguments[1]):t.apply(o,[].slice.call(arguments,1)),e=o.processedXData}o.boosted=getSeriesBoosting(o,e),o.boosted?(o.options.data&&o.options.data.length&&(s=o.getFirstValidPoint(o.options.data),isNumber(s)||isArray(s)||error(12,!1,o.chart)),enterBoost(o)):exitBoost(o)}else t.apply(this,[].slice.call(arguments,1))}function wrapSeriesSearchPoint(t){t=t.apply(this,[].slice.call(arguments,1));return this.boost&&t?this.boost.getPoint(t):t}const BoostSeries={compose:compose,destroyGraphics:destroyGraphics,eachAsync:eachAsync,getPoint:getPoint};export default BoostSeries;