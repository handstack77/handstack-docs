"use strict";import Color from"../../Core/Color/Color.js";const color=Color["parse"];import H from"../../Core/Globals.js";const{doc,win}=H;import U from"../../Core/Utilities.js";const{isNumber,isObject,merge,objectEach,pick}=U;import WGLDrawMode from"./WGLDrawMode.js";import WGLShader from"./WGLShader.js";import WGLVertexBuffer from"./WGLVertexBuffer.js";const asBar={column:!0,columnrange:!0,bar:!0,area:!0,areaspline:!0,arearange:!0},asCircle={scatter:!0,bubble:!0},contexts=["webgl","experimental-webgl","moz-webgl","webkit-3d"];class WGLRenderer{static orthoMatrix(e,t){return[2/e,0,0,0,0,-2/t,0,0,0,0,-2,0,-1,1,-1,1]}static seriesPointCount(e){let t,s,i;return e.boosted?(t=!!e.options.stacking,s=e.xData||e.options.xData||e.processedXData,i=(t?e.data:s||e.options.data).length,"treemap"===e.type?i*=12:"heatmap"===e.type?i*=6:asBar[e.type]&&(i*=2),i):0}constructor(e){this.data=[],this.height=0,this.isInited=!1,this.markerData=[],this.series=[],this.textureHandles={},this.width=0,this.postRenderCallback=e,this.settings={pointSize:1,lineWidth:1,fillColor:"#AA00AA",useAlpha:!0,usePreallocated:!1,useGPUTranslations:!1,debug:{timeRendering:!1,timeSeriesProcessing:!1,timeSetup:!1,timeBufferCopy:!1,timeKDTree:!1,showSkipSummary:!1}}}getPixelRatio(){return this.settings.pixelRatio||win.devicePixelRatio||1}setOptions(e){"pixelRatio"in e||(e.pixelRatio=1),merge(!0,this.settings,e)}allocateBuffer(e){const t=this.vbuffer;let s=0;this.settings.usePreallocated&&(e.series.forEach(e=>{e.boosted&&(s+=WGLRenderer.seriesPointCount(e))}),t&&t.allocate(s))}allocateBufferForSingleSeries(e){const t=this.vbuffer;let s=0;this.settings.usePreallocated&&(e.boosted&&(s=WGLRenderer.seriesPointCount(e)),t&&t.allocate(s))}clear(){const e=this.gl;e&&e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT)}pushSeriesData(n,o){const a=this.data,l=this.settings,N=this.vbuffer,I=n.pointArrayMap&&"low,high"===n.pointArrayMap.join(","),{chart:h,options:e,sorted:O,xAxis:z,yAxis:d}=n,W=!!e.stacking,B=e.data,X=n.xAxis.getExtremes(),t=X.min-(n.xAxis.minPointOffset||0),s=X.max+(n.xAxis.minPointOffset||0),F=n.yAxis.getExtremes(),i=F.min-(n.yAxis.minPointOffset||0),H=F.max+(n.yAxis.minPointOffset||0),V=n.xData||e.xData||n.processedXData,j=n.yData||e.yData||n.processedYData,r=n.zData||e.zData||n.processedZData,Y=!V||0===V.length,q=e.connectNulls,m=n.points||!1,g=W?n.data:V||B,c={x:Number.MAX_VALUE,y:0},u={x:-Number.MAX_VALUE,y:0},Z=void 0===h.index,K=asBar[n.type],J=e.zoneAxis||"y",x=e.zones||!1,Q=e.threshold,p=this.getPixelRatio();let $=n.chart.plotWidth,f=!1,b=!1,A,T,ee=0,te=!1,P,E,y,se,R=-1,M=!1,k=!1,S,ie=!1,re=!1,U=!1,oe=!1,ae=!0,ne=!0,v,D=!1,le=!1,_=0;if(!(e.boostData&&0<e.boostData.length)){e.gapSize&&(le="value"!==e.gapUnit?e.gapSize*n.closestPointRange:e.gapSize),x&&(v=[],x.forEach((e,t)=>{if(e.color){const s=color(e.color).rgba;s[0]/=255,s[1]/=255,s[2]/=255,v[t]=s,D||void 0!==e.value||(D=s)}}),D||(L=n.pointAttribs&&n.pointAttribs().fill||n.color,(D=color(L).rgba)[0]/=255,D[1]/=255,D[2]/=255)),h.inverted&&($=n.chart.plotHeight),n.closestPointRangePx=Number.MAX_VALUE;const G=e=>{e&&(o.colorData.push(e[0]),o.colorData.push(e[1]),o.colorData.push(e[2]),o.colorData.push(e[3]))},w=(e,t,s,i=1,r)=>{G(r),1===p||l.useGPUTranslations&&!o.skipTranslation||(e*=p,t*=p,i*=p),l.usePreallocated&&N?(N.push(e,t,s?1:0,i),_+=4):(a.push(e),a.push(t),a.push(s?p:0),a.push(i))},de=()=>{o.segments.length&&(o.segments[o.segments.length-1].to=a.length||_)};var C=()=>{o.segments.length&&o.segments[o.segments.length-1].from===(a.length||_)||(de(),o.segments.push({from:a.length||_}))};const me=(e,t,s,i,r)=>{G(r),w(e+s,t),G(r),w(e,t),G(r),w(e,t+i),G(r),w(e,t+i),G(r),w(e+s,t+i),G(r),w(e+s,t)};if(C(),m&&0<m.length)return o.skipTranslation=!0,o.drawMode="TRIANGLES",m[0].node&&m[0].node.levelDynamic&&m.sort((e,t)=>{if(e.node){if(e.node.levelDynamic>t.node.levelDynamic)return 1;if(e.node.levelDynamic<t.node.levelDynamic)return-1}return 0}),m.forEach(r=>{var e=r.plotY;let o,a;if(void 0!==e&&!isNaN(e)&&null!==r.y&&r.shapeArgs){let{x:e=0,y:t=0,width:s=0,height:i=0}=r.shapeArgs;a=h.styledMode?r.series.colorAttribs(r):a=r.series.pointAttribs(r),o=a["stroke-width"]||0,(U=color(a.fill).rgba)[0]/=255,U[1]/=255,U[2]/=255,n.is("treemap")&&(o=o||1,(T=color(a.stroke).rgba)[0]/=255,T[1]/=255,T[2]/=255,me(e,t,s,i,T),o/=2),n.is("heatmap")&&h.inverted&&(e=z.len-e,t=d.len-t,s=-s,i=-i),me(e+o,t+o,s-2*o,i-2*o,U)}}),void de();for(;R<g.length-1;)if(void 0!==(y=g[++R])){if(Z)break;var he=B&&B[R];if(!Y&&isObject(he,!0)&&he.color&&((U=color(he.color).rgba)[0]/=255,U[1]/=255,U[2]/=255),Y?(P=y[0],E=y[1],g[R+1]&&(k=g[R+1][0]),g[R-1]&&(M=g[R-1][0]),3<=y.length&&(se=y[2],y[2]>o.zMax&&(o.zMax=y[2]),y[2]<o.zMin&&(o.zMin=y[2]))):(P=y,E=j[R],g[R+1]&&(k=g[R+1]),g[R-1]&&(M=g[R-1]),r&&r.length&&(se=r[R],r[R]>o.zMax&&(o.zMax=r[R]),r[R]<o.zMin&&(o.zMin=r[R]))),q||null!==P&&null!==E){if(k&&k>=t&&k<=s&&(ie=!0),M&&M>=t&&M<=s&&(re=!0),I?(Y&&(E=y.slice(1,3)),S=E[0],E=E[1]):W&&(P=y.x,E=y.stackY,S=E-y.y),null!=i&&null!=H&&(ae=E>=i&&E<=H),P>s&&u.x<s&&(u.x=P,u.y=E),P<t&&c.x>t&&(c.x=P,c.y=E),null!==E||!q)if(null!==E&&(ae||ie||re)){if((oe=O&&(k>=t||P>=t)&&(M<=s||P<=s)?!0:oe)||ie||re){if(le&&P-M>le&&C(),x){let i;x.some((e,t)=>{var s=x[t-1];return"x"===J?void 0!==e.value&&P<=e.value&&(v[t]&&(!s||P>=s.value)&&(i=v[t]),!0):void 0!==e.value&&E<=e.value&&(v[t]&&(!s||E>=s.value)&&(i=v[t]),!0)}),U=i||D||U}!l.useGPUTranslations&&(o.skipTranslation=!0,P=z.toPixels(P,!0),E=d.toPixels(E,!0),P>$&&"POINTS"===o.drawMode)||(o.hasMarkers&&oe&&!1!==f&&(n.closestPointRangePx=Math.min(n.closestPointRangePx,Math.abs(P-f))),!l.useGPUTranslations&&!l.usePreallocated&&f&&Math.abs(P-f)<1&&b&&Math.abs(E-b)<1?l.debug.showSkipSummary&&++ee:(K&&(!1!==(A=S)&&void 0!==S||(A=E<0?E:0),(I||W)&&!d.logarithmic||(A=Math.max(null===Q?i:Q,i)),l.useGPUTranslations||(A=d.toPixels(A,!0)),w(P,A,0,0,U)),e.step&&!ne&&w(P,b,0,2,U),w(P,E,0,"bubble"===n.type?se||1:2,U),f=P,b=E,te=!0,ne=!1))}}else C()}else C()}l.debug.showSkipSummary&&console.log("skipped points:",ee);var L=(e,t)=>{l.useGPUTranslations||(o.skipTranslation=!0,e.x=z.toPixels(e.x,!0),e.y=d.toPixels(e.y,!0)),t?this.data=[e.x,e.y,0,2].concat(this.data):w(e.x,e.y,0,2)};te||!1===q||"line_strip"!==n.drawMode||(c.x<Number.MAX_VALUE&&L(c,!0),u.x>-Number.MAX_VALUE&&L(u)),de()}}pushSeries(e){const t=this.markerData,s=this.series,i=this.settings;0<s.length&&s[s.length-1].hasMarkers&&(s[s.length-1].markerTo=t.length),i.debug.timeSeriesProcessing&&console.time("building "+e.type+" series");var r={segments:[],markerFrom:t.length,colorData:[],series:e,zMin:Number.MAX_VALUE,zMax:-Number.MAX_VALUE,hasMarkers:!!e.options.marker&&!1!==e.options.marker.enabled,showMarkers:!0,drawMode:WGLDrawMode[e.type]||"LINE_STRIP"};e.index>=s.length?s.push(r):s[e.index]=r,this.pushSeriesData(e,r),i.debug.timeSeriesProcessing&&console.timeEnd("building "+e.type+" series")}flush(){const e=this.vbuffer;this.data=[],this.markerData=[],this.series=[],e&&e.destroy()}setXAxis(e){const t=this.shader;var s;t&&(s=this.getPixelRatio(),t.setUniform("xAxisTrans",e.transA*s),t.setUniform("xAxisMin",e.min),t.setUniform("xAxisMinPad",e.minPixelPadding*s),t.setUniform("xAxisPointRange",e.pointRange),t.setUniform("xAxisLen",e.len*s),t.setUniform("xAxisPos",e.pos*s),t.setUniform("xAxisCVSCoord",!e.horiz),t.setUniform("xAxisIsLog",!!e.logarithmic),t.setUniform("xAxisReversed",!!e.reversed))}setYAxis(e){const t=this.shader;var s;t&&(s=this.getPixelRatio(),t.setUniform("yAxisTrans",e.transA*s),t.setUniform("yAxisMin",e.min),t.setUniform("yAxisMinPad",e.minPixelPadding*s),t.setUniform("yAxisPointRange",e.pointRange),t.setUniform("yAxisLen",e.len*s),t.setUniform("yAxisPos",e.pos*s),t.setUniform("yAxisCVSCoord",!e.horiz),t.setUniform("yAxisIsLog",!!e.logarithmic),t.setUniform("yAxisReversed",!!e.reversed))}setThreshold(e,t){const s=this.shader;s&&(s.setUniform("hasThreshold",e),s.setUniform("translatedThreshold",t))}renderChart(g){const c=this.gl,u=this.settings,x=this.shader,p=this.vbuffer,f=this.getPixelRatio();if(!g)return!1;this.width=g.chartWidth*f,this.height=g.chartHeight*f;var e=this.height,t=this.width;if(!(c&&x&&t&&e))return!1;u.debug.timeRendering&&console.time("gl rendering"),c.canvas.width=t,c.canvas.height=e,x.bind(),c.viewport(0,0,t,e),x.setPMatrix(WGLRenderer.orthoMatrix(t,e)),1<u.lineWidth&&!H.isMS&&c.lineWidth(u.lineWidth),p&&(p.build(this.data,"aVertexPosition",4),p.bind()),x.setInverted(g.inverted),this.series.forEach((e,t)=>{var s=e.series.options,i=s.marker,r=void 0!==s.lineWidth?s.lineWidth:1,o=s.threshold,a=isNumber(o),o=e.series.yAxis.getThreshold(o),n=pick(s.marker?s.marker.enabled:null,!!e.series.xAxis.isRadial||null,e.series.closestPointRangePx>2*((s.marker?s.marker.radius:10)||10)),i=this.textureHandles[i&&i.symbol||e.series.symbol]||this.textureHandles.circle;let l,h,d,m=[];if(0!==e.segments.length&&e.segments[0].from!==e.segments[0].to&&(i.isReady&&(c.bindTexture(c.TEXTURE_2D,i.handle),x.setTexture(i.handle)),g.styledMode?e.series.markerGroup===e.series.chart.boost?.markerGroup?(delete e.series.markerGroup,e.series.markerGroup=e.series.plotGroup("markerGroup","markers","visible",1,g.seriesGroup).addClass("highcharts-tracker"),d=e.series.markerGroup.getStyle("fill"),e.series.markerGroup.destroy(),e.series.markerGroup=e.series.chart.boost?.markerGroup):d=e.series.markerGroup?.getStyle("fill"):(d="POINTS"===e.drawMode&&e.series.pointAttribs&&e.series.pointAttribs().fill||e.series.color,s.colorByPoint&&(d=e.series.chart.options.colors[t])),e.series.fillOpacity&&s.fillOpacity&&(d=new Color(d).setOpacity(pick(s.fillOpacity,1)).get()),m=color(d).rgba,u.useAlpha||(m[3]=1),"add"===s.boostBlending?(c.blendFunc(c.SRC_ALPHA,c.ONE),c.blendEquation(c.FUNC_ADD)):"mult"===s.boostBlending||"multiply"===s.boostBlending?c.blendFunc(c.DST_COLOR,c.ZERO):"darken"===s.boostBlending?(c.blendFunc(c.ONE,c.ONE),c.blendEquation(c.FUNC_MIN)):c.blendFuncSeparate(c.SRC_ALPHA,c.ONE_MINUS_SRC_ALPHA,c.ONE,c.ONE_MINUS_SRC_ALPHA),x.reset(),0<e.colorData.length?(x.setUniform("hasColor",1),(h=new WGLVertexBuffer(c,x)).build(Array(e.segments[0].from).concat(e.colorData),"aColor",4),h.bind()):(x.setUniform("hasColor",0),c.disableVertexAttribArray(c.getAttribLocation(x.getProgram(),"aColor"))),x.setColor(m),this.setXAxis(e.series.xAxis),this.setYAxis(e.series.yAxis),this.setThreshold(a,o),"POINTS"===e.drawMode&&x.setPointSize(2*pick(s.marker&&s.marker.radius,.5)*f),x.setSkipTranslation(e.skipTranslation),"bubble"===e.series.type&&x.setBubbleUniforms(e.series,e.zMin,e.zMax,f),x.setDrawAsCircle(asCircle[e.series.type]||!1),p)){if(0<r||"LINE_STRIP"!==e.drawMode)for(l=0;l<e.segments.length;l++)p.render(e.segments[l].from,e.segments[l].to,e.drawMode);if(e.hasMarkers&&n)for(x.setPointSize(2*pick(s.marker&&s.marker.radius,5)*f),x.setDrawAsCircle(!0),l=0;l<e.segments.length;l++)p.render(e.segments[l].from,e.segments[l].to,"POINTS")}}),u.debug.timeRendering&&console.timeEnd("gl rendering"),this.postRenderCallback&&this.postRenderCallback(this),this.flush()}render(e){if(this.clear(),e.renderer.forExport)return this.renderChart(e);this.isInited?this.renderChart(e):setTimeout(()=>{this.render(e)},1)}setSize(e,t){const s=this.shader;!s||this.width===e&&this.height===t||(this.width=e,this.height=t,s.bind(),s.setPMatrix(WGLRenderer.orthoMatrix(e,t)))}init(t,e){var s=this.settings;if(this.isInited=!1,!t)return!1;s.debug.timeSetup&&console.time("gl setup");for(let e=0;e<contexts.length&&(this.gl=t.getContext(contexts[e],{}),!this.gl);++e);const r=this.gl;if(!r)return!1;e||this.flush(),r.enable(r.BLEND),r.blendFunc(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA),r.disable(r.DEPTH_TEST),r.depthFunc(r.LESS);e=this.shader=new WGLShader(r);if(!e)return!1;this.vbuffer=new WGLVertexBuffer(r,e);e=(e,t)=>{const s={isReady:!1,texture:doc.createElement("canvas"),handle:r.createTexture()},i=s.texture.getContext("2d");(this.textureHandles[e]=s).texture.width=512,s.texture.height=512,i.mozImageSmoothingEnabled=!1,i.webkitImageSmoothingEnabled=!1,i.msImageSmoothingEnabled=!1,i.imageSmoothingEnabled=!1,i.strokeStyle="rgba(255, 255, 255, 0)",i.fillStyle="#FFF",t(i);try{r.activeTexture(r.TEXTURE0),r.bindTexture(r.TEXTURE_2D,s.handle),r.texImage2D(r.TEXTURE_2D,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,s.texture),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.LINEAR),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.LINEAR),r.bindTexture(r.TEXTURE_2D,null),s.isReady=!0}catch(e){}};return e("circle",e=>{e.beginPath(),e.arc(256,256,256,0,2*Math.PI),e.stroke(),e.fill()}),e("square",e=>{e.fillRect(0,0,512,512)}),e("diamond",e=>{e.beginPath(),e.moveTo(256,0),e.lineTo(512,256),e.lineTo(256,512),e.lineTo(0,256),e.lineTo(256,0),e.fill()}),e("triangle",e=>{e.beginPath(),e.moveTo(0,512),e.lineTo(256,0),e.lineTo(512,512),e.lineTo(0,512),e.fill()}),e("triangle-down",e=>{e.beginPath(),e.moveTo(0,0),e.lineTo(256,512),e.lineTo(512,0),e.lineTo(0,0),e.fill()}),this.isInited=!0,s.debug.timeSetup&&console.timeEnd("gl setup"),!0}destroy(){const t=this.gl,e=this.shader,s=this.vbuffer;this.flush(),s&&s.destroy(),e&&e.destroy(),t&&(objectEach(this.textureHandles,e=>{e.handle&&t.deleteTexture(e.handle)}),t.canvas.width=1,t.canvas.height=1)}}export default WGLRenderer;