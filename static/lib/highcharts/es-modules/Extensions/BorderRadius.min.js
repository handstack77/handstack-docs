"use strict";import D from"../Core/Defaults.js";const defaultOptions=D["defaultOptions"];import H from"../Core/Globals.js";const noop=H["noop"];import U from"../Core/Utilities.js";const{addEvent,extend,isObject,merge,relativeLength}=U,defaultBorderRadiusOptions={radius:0,scope:"stack",where:void 0};let oldArc=noop,oldRoundedRect=noop;function applyBorderRadius(t,e,o){var s=t[e];let r=t[e+1];"Z"===r[0]&&(r=t[0]);let a,i,n;if("M"!==s[0]&&"L"!==s[0]||"A"!==r[0]?"A"!==s[0]||"M"!==r[0]&&"L"!==r[0]||(a=r,i=s):(a=s,i=r,n=!0),a&&i&&i.params){const c=i[1],l=i[5],p=i.params,{start:u,end:f,cx:b,cy:m}=p;var s=l?c-o:c+o,d=s?Math.asin(o/s):0,h=l?d:-d,d=Math.cos(d)*s;n?(p.start=u+h,a[1]=b+d*Math.cos(u),a[2]=m+d*Math.sin(u),t.splice(e+1,0,["A",o,o,0,0,1,b+c*Math.cos(p.start),m+c*Math.sin(p.start)])):(p.end=f-h,i[6]=b+c*Math.cos(p.end),i[7]=m+c*Math.sin(p.end),t.splice(e+1,0,["A",o,o,0,0,1,b+d*Math.cos(f),m+d*Math.sin(f)])),i[4]=Math.abs(p.end-p.start)<Math.PI?0:1}}function arc(t,e,o,s,r={}){var a=oldArc(t,e,o,s,r),{innerR:t=0,r:e=o,start:s=0,end:o=0}=r;if(r.open||!r.borderRadius)return a;var o=o-s,s=Math.sin(o/2),i=Math.max(Math.min(relativeLength(r.borderRadius||0,e-t),(e-t)/2,e*s/(1+s)),0),n=Math.min(i,o/Math.PI*2*t);let d=a.length-1;for(;d--;)applyBorderRadius(a,d,1<d?n:i);return a}function seriesOnAfterColumnTranslate(){if(this.options.borderRadius&&(!this.chart.is3d||!this.chart.is3d())){const{options:d,yAxis:h}=this,c="percent"===d.stacking,t=defaultOptions.plotOptions?.[this.type]?.borderRadius,l=optionsToObject(d.borderRadius,isObject(t)?t:{}),p=h.options.reversed;for(const u of this.points){var s=u["shapeArgs"];if("roundedRect"===u.shapeType&&s){var{width:r=0,height:a=0,y:i=0}=s;let t=i,e=a;"stack"===l.scope&&u.stackTotal&&(i=h.translate(c?100:u.stackTotal,!1,!0,!1,!0),n=h.translate(d.threshold||0,!1,!0,!1,!0),i=this.crispCol(0,Math.min(i,n),0,Math.abs(i-n)),t=i.y,e=i.height);var n=(u.negative?-1:1)*(p?-1:1)==-1;let o=l.where;o=(o=!o&&this.is("waterfall")&&Math.abs((u.yBottom||0)-(this.translatedThreshold||0))>this.borderWidth?"all":o)||"end";i=Math.min(relativeLength(l.radius,r),r/2,"all"===o?a/2:1/0)||0;"end"===o&&(n&&(t-=i),e+=i),extend(s,{brBoxHeight:e,brBoxY:t,r:i})}}}}function compose(t,e,o){var s=t.types.pie;if(!e.symbolCustomAttribs.includes("borderRadius")){const r=o.prototype.symbols;addEvent(t,"afterColumnTranslate",seriesOnAfterColumnTranslate,{order:9}),addEvent(s,"afterTranslate",pieSeriesOnAfterTranslate),e.symbolCustomAttribs.push("borderRadius","brBoxHeight","brBoxY"),oldArc=r.arc,oldRoundedRect=r.roundedRect,r.arc=arc,r.roundedRect=roundedRect}}function optionsToObject(t,e){return isObject(t)||(t={radius:t||0}),merge(defaultBorderRadiusOptions,e,t)}function pieSeriesOnAfterTranslate(){var t=optionsToObject(this.options.borderRadius);for(const e of this.points){const o=e.shapeArgs;o&&(o.borderRadius=relativeLength(t.radius,(o.r||0)-(o.innerR||0)))}}function roundedRect(t,e,o,s,r={}){const a=oldRoundedRect(t,e,o,s,r),{r:i=0,brBoxHeight:n=s,brBoxY:d=e}=r,h=e-d,c=d+n-(e+s),l=-.1<h-i?0:i,p=-.1<c-i?0:i,u=Math.max(l&&h,0),f=Math.max(p&&c,0),b=[t+l,e],m=[t+o-l,e],M=[t+o,e+l],R=[t+o,e+s-p],v=[t+o-p,e+s],A=[t+p,e+s],O=[t,e+s-p],g=[t,e+l];var x,r=(t,e)=>Math.sqrt(Math.pow(t,2)-Math.pow(e,2));return u&&(x=r(l,l-u),b[0]-=x,m[0]+=x,M[1]=g[1]=e+l-u),s<l-u&&(x=r(l,l-u-s),M[0]=R[0]=t+o-l+x,v[0]=Math.min(M[0],v[0]),A[0]=Math.max(R[0],A[0]),O[0]=g[0]=t+l-x,M[1]=g[1]=e+s),f&&(x=r(p,p-f),v[0]+=x,A[0]-=x,R[1]=O[1]=e+s-p+f),s<p-f&&(x=r(p,p-f-s),M[0]=R[0]=t+o-p+x,m[0]=Math.min(M[0],m[0]),b[0]=Math.max(R[0],b[0]),O[0]=g[0]=t+p-x,R[1]=O[1]=e),a.length=0,a.push(["M",...b],["L",...m],["A",l,l,0,0,1,...M],["L",...R],["A",p,p,0,0,1,...v],["L",...A],["A",p,p,0,0,1,...O],["L",...g],["A",l,l,0,0,1,...b],["Z"]),a}const BorderRadius={compose:compose,optionsToObject:optionsToObject};export default BorderRadius;