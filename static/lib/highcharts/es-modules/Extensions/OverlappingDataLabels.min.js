"use strict";import GeometryUtilities from"../Core/Geometry/GeometryUtilities.js";const pointInPolygon=GeometryUtilities["pointInPolygon"];import U from"../Core/Utilities.js";const{addEvent,fireEvent,objectEach,pick}=U;function chartHideOverlappingLabels(a){var i,o=a.length;let e,l,n,r,s,t=!1;for(let t=0;t<o;t++)(e=a[t])&&(e.oldOpacity=e.opacity,e.newOpacity=1,e.absoluteBox=function(t){var e,a,i;if(t&&(!t.alignAttr||t.placed))return e=!t.box&&t.padding||0,a=t.alignAttr||{x:t.attr("x"),y:t.attr("y")},i=t.getBBox(),t.width=i.width,t.height=i.height,{x:a.x+(t.parentGroup?.translateX||0)+e,y:a.y+(t.parentGroup?.translateY||0)+e,width:(t.width||0)-2*e,height:(t.height||0)-2*e,polygon:i?.polygon}}(e));a.sort((t,e)=>(e.labelrank||0)-(t.labelrank||0));for(let t=0;t<o;++t){var p=(r=(l=a[t])&&l.absoluteBox)?.polygon;for(let e=t+1;e<o;++e){n=a[e],s=n&&n.absoluteBox;let t=!1;if(r&&s&&l!==n&&0!==l.newOpacity&&0!==n.newOpacity&&"hidden"!==l.visibility&&"hidden"!==n.visibility){var c=s.polygon;if(p&&c&&p!==c?((t,e)=>{for(const a of t)if(pointInPolygon({x:a[0],y:a[1]},e))return!0;return!1})(p,c)&&(t=!0):(c=r,(i=s).x>=c.x+c.width||i.x+i.width<=c.x||i.y>=c.y+c.height||i.y+i.height<=c.y||(t=!0)),t){const h=l.labelrank<n.labelrank?l:n,d=h.text;h.newOpacity=0,d?.element.querySelector("textPath")&&d.hide()}}}}for(const e of a)hideOrShow(e,this)&&(t=!0);t&&fireEvent(this,"afterHideAllOverlappingLabels")}function compose(t){const e=t.prototype;e.hideOverlappingLabels||(e.hideOverlappingLabels=chartHideOverlappingLabels,addEvent(t,"render",onChartRender))}function hideOrShow(t,e){let a,i=!1;return t&&(a=t.newOpacity,t.oldOpacity!==a&&(t.hasClass("highcharts-data-label")?(t[a?"removeClass":"addClass"]("highcharts-data-label-hidden"),i=!0,t[t.isOld?"animate":"attr"]({opacity:a},void 0,function(){e.styledMode||t.css({pointerEvents:a?"auto":"none"})}),fireEvent(e,"afterHideOverlappingLabel")):t.attr({opacity:a})),t.isOld=!0),i}function onChartRender(){const i=this;let o=[];for(const e of i.labelCollectors||[])o=o.concat(e());for(const a of i.yAxis||[])a.stacking&&a.options.stackLabels&&!a.options.stackLabels.allowOverlap&&objectEach(a.stacking.stacks,t=>{objectEach(t,t=>{t.label&&o.push(t.label)})});for(const l of i.series||[]){var t;l.visible&&l.hasDataLabels?.()&&((t=t=>{for(const a of t)a.visible&&(a.dataLabels||[]).forEach(t=>{var e=t.options||{};t.labelrank=pick(e.labelrank,a.labelrank,a.shapeArgs?.height),e.allowOverlap??0<Number(e.distance)?(t.oldOpacity=t.opacity,t.newOpacity=1,hideOrShow(t,i)):o.push(t)})})(l.nodes||[]),t(l.points))}this.hideOverlappingLabels(o)}const OverlappingDataLabels={compose:compose};export default OverlappingDataLabels;