"use strict";import ControlTarget from"../ControlTarget.js";import U from"../../../Core/Utilities.js";const merge=U["merge"];class Controllable{constructor(t,i,s,o){this.annotation=t,this.chart=t.chart,this.collection="label"===o?"labels":"shapes",this.controlPoints=[],this.options=i,this.points=[],this.index=s,this.itemType=o,this.init(t,i,s)}attr(){this.graphic.attr.apply(this.graphic,arguments)}attrsFromOptions(t){const i=this.constructor.attrsMap,s={},o=this.chart.styledMode;let n,r;for(n in t)r=i[n],void 0===i[n]||o&&-1!==["fill","stroke","stroke-width"].indexOf(r)||(s[r]=t[n]);return s}destroy(){this.graphic&&(this.graphic=this.graphic.destroy()),this.tracker&&(this.tracker=this.tracker.destroy()),this.destroyControlTarget()}init(t,i,s){this.annotation=t,this.chart=t.chart,this.options=i,this.points=[],this.controlPoints=[],this.index=s,this.linkPoints(),this.addControlPoints()}redraw(t){this.redrawControlPoints(t)}render(t){this.options.className&&this.graphic&&this.graphic.addClass(this.options.className),this.renderControlPoints()}rotate(t,i,s){this.transform("rotate",t,i,s)}scale(t,i,s,o){this.transform("scale",t,i,s,o)}setControlPointsVisibility(i){this.controlPoints.forEach(t=>{t.setVisibility(i)})}shouldBeDrawn(){return!!this.points.length}translateShape(t,i,s){const o=this.annotation.chart,n=this.annotation.userOptions,r=o.annotations.indexOf(this.annotation),e=o.options.annotations[r];this.translatePoint(t,i,0),s&&this.translatePoint(t,i,1),e[this.collection][this.index].point=this.options.point,n[this.collection][this.index].point=this.options.point}update(t){const i=this.annotation,s=merge(!0,this.options,t),o=this.graphic.parentGroup,n=this.constructor;this.destroy();t=new n(i,s,this.index,this.itemType);merge(!0,this,t),this.render(o),this.redraw()}}ControlTarget.compose(Controllable);export default Controllable;