"use strict";import Annotation from"../Annotation.js";import CrookedLine from"./CrookedLine.js";import MockPoint from"../MockPoint.js";import U from"../../../Core/Utilities.js";const merge=U["merge"];class InfinityLine extends CrookedLine{static edgePoint(e,o){return function(i){var i=i.annotation,t=i.options.typeOptions.type;let n=i.points;return"horizontalLine"!==t&&"verticalLine"!==t||(n=[n[0],new MockPoint(i.chart,n[0].target,{x:n[0].x+ +("horizontalLine"===t),y:n[0].y+ +("verticalLine"===t),xAxis:n[0].options.xAxis,yAxis:n[0].options.yAxis})]),InfinityLine.findEdgePoint(n[e],n[o])}}static findEdgeCoordinate(i,t,n,e){var o="x"===n?"y":"x";return(t[n]-i[n])*(e-i[o])/(t[o]-i[o])+i[n]}static findEdgePoint(i,t){const n=i.series.chart,e=i.series.xAxis,o=t.series.yAxis,s=MockPoint.pointToPixels(i),r=MockPoint.pointToPixels(t),y=r.x-s.x,a=r.y-s.y,p=e.left,d=p+e.width,f=o.top,x=f+o.height,c=y<0?p:d,L=a<0?f:x,g={x:0==y?s.x:c,y:0==a?s.y:L};var l;return 0!=y&&0!=a&&(t=InfinityLine.findEdgeCoordinate(s,r,"y",c),l=InfinityLine.findEdgeCoordinate(s,r,"x",L),f<=t&&t<=x?(g.x=c,g.y=t):(g.x=l,g.y=L)),g.x-=n.plotLeft,g.y-=n.plotTop,i.series.chart.inverted&&(t=g.x,g.x=g.y,g.y=t),g}addShapes(){const i=this.options.typeOptions,t=[this.points[0],InfinityLine.endEdgePoint];i.type.match(/line/gi)&&(t[0]=InfinityLine.startEdgePoint);var n=this.initShape(merge(i.line,{type:"path",points:t,className:"highcharts-infinity-lines"}),0);i.line=n.options}}InfinityLine.endEdgePoint=InfinityLine.edgePoint(0,1),InfinityLine.startEdgePoint=InfinityLine.edgePoint(1,0),InfinityLine.prototype.defaultOptions=merge(CrookedLine.prototype.defaultOptions,{});export default Annotation.types.infinityLine=InfinityLine;