"use strict";import H from"../Globals.js";const composed=H["composed"];import Math3D from"../Math3D.js";const perspective=Math3D["perspective"];import Series from"../Series/Series.js";import U from"../Utilities.js";const{addEvent,extend,isNumber,merge,pick,pushUnique}=U;class Series3D extends Series{static compose(t){pushUnique(composed,"Core.Series3D")&&(addEvent(t,"afterTranslate",function(){this.chart.is3d()&&this.translate3dPoints()}),extend(t.prototype,{translate3dPoints:Series3D.prototype.translate3dPoints}))}translate3dPoints(){const s=this,t=s.options,e=s.chart,i=pick(s.zAxis,e.options.zAxis[0]),o=[],a=[],p=t.stacking?isNumber(t.stack)?t.stack:0:s.index||0;let r,n;s.zPadding=p*(t.depth||0+(t.groupZPadding||1)),s.data.forEach(t=>{i&&i.translate?(n=i.logarithmic&&i.val2lin?i.val2lin(t.z):t.z,t.plotZ=i.translate(n),t.isInside=!!t.isInside&&(n>=i.min&&n<=i.max)):t.plotZ=s.zPadding,t.axisXpos=t.plotX,t.axisYpos=t.plotY,t.axisZpos=t.plotZ,o.push({x:t.plotX,y:t.plotY,z:t.plotZ}),a.push(t.plotX||0)}),s.rawPointsX=a;const l=perspective(o,e,!0);s.data.forEach((t,s)=>{r=l[s],t.plotX=r.x,t.plotY=r.y,t.plotZ=r.z})}}Series3D.defaultOptions=merge(Series.defaultOptions);export default Series3D;