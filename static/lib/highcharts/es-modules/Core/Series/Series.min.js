"use strict";import A from"../Animation/AnimationUtilities.js";const{animObject,setAnimation}=A;import D from"../Defaults.js";const defaultOptions=D["defaultOptions"];import F from"../Foundation.js";const registerEventOptions=F["registerEventOptions"];import H from"../Globals.js";const{svg,win}=H;import LegendSymbol from"../Legend/LegendSymbol.js";import Point from"./Point.js";import SeriesDefaults from"./SeriesDefaults.js";import SeriesRegistry from"./SeriesRegistry.js";const seriesTypes=SeriesRegistry["seriesTypes"];import SVGElement from"../Renderer/SVG/SVGElement.js";import U from"../Utilities.js";const{arrayMax,arrayMin,clamp,correctFloat,crisp,defined,destroyObjectProperties,diffObjects,erase,error,extend,find,fireEvent,getClosestDistance,getNestedProperty,insertItem,isArray,isNumber,isString,merge,objectEach,pick,removeEvent,splat,syncTimeout}=U;class Series{constructor(){this.zoneAxis="y"}init(t,e){fireEvent(this,"init",{options:e});const i=this,s=t.series;this.eventsToUnbind=[],i.chart=t,i.options=i.setOptions(e);var e=i.options,r=!1!==e.visible,r=(i.linkedSeries=[],i.bindAxes(),extend(i,{name:e.name,state:"",visible:r,selected:!0===e.selected}),registerEventOptions(this,e),e.events);(r&&r.click||e.point&&e.point.events&&e.point.events.click||e.allowPointSelect)&&(t.runTrackerClick=!0),i.getColor(),i.getSymbol(),i.parallelArrays.forEach(function(t){i[t+"Data"]||(i[t+"Data"]=[])}),i.isCartesian&&(t.hasCartesianSeries=!0);let a;s.length&&(a=s[s.length-1]),i._i=pick(a&&a._i,-1)+1,i.opacity=i.options.opacity,t.orderItems("series",insertItem(this,s)),e.dataSorting&&e.dataSorting.enabled?i.setDataSortingOptions():i.points||i.data||i.setData(e.data,!1),fireEvent(this,"afterInit")}is(t){return seriesTypes[t]&&this instanceof seriesTypes[t]}bindAxes(){const i=this,s=i.options,t=i.chart;let r;fireEvent(this,"bindAxes",null,function(){(i.axisTypes||[]).forEach(function(e){(t[e]||[]).forEach(function(t){r=t.options,(pick(s[e],0)===t.index||void 0!==s[e]&&s[e]===r.id)&&(insertItem(i,t.series),(i[e]=t).isDirty=!0)}),i[e]||i.optionalAxis===e||error(18,!0,t)})}),fireEvent(this,"afterBindAxes")}updateParallelArrays(i,s,e){const r=i.series,t=isNumber(s)?function(t){var e="y"===t&&r.toYData?r.toYData(i):i[t];r[t+"Data"][s]=e}:function(t){Array.prototype[s].apply(r[t+"Data"],e)};r.parallelArrays.forEach(t)}hasData(){return this.visible&&void 0!==this.dataMax&&void 0!==this.dataMin||this.visible&&this.yData&&0<this.yData.length}hasMarkerChanged(t,e){t=t.marker,e=e.marker||{};return t&&(e.enabled&&!t.enabled||e.symbol!==t.symbol||e.height!==t.height||e.width!==t.width)}autoIncrement(t){const e=this.options,i=e.pointIntervalUnit,s=e.relativeXValue,r=this.chart.time;let a=this.xIncrement,o,n;return a=pick(a,e.pointStart,0),this.pointInterval=n=pick(this.pointInterval,e.pointInterval,1),s&&isNumber(t)&&(n*=t),i&&(o=new r.Date(a),"day"===i?r.set("Date",o,r.get("Date",o)+n):"month"===i?r.set("Month",o,r.get("Month",o)+n):"year"===i&&r.set("FullYear",o,r.get("FullYear",o)+n),n=o.getTime()-a),s&&isNumber(t)?a+n:(this.xIncrement=a+n,a)}setDataSortingOptions(){const t=this.options;extend(this,{requireSorting:!1,sorted:!1,enabledDataSorting:!0,allowDG:!1}),defined(t.pointRange)||(t.pointRange=1)}setOptions(t){var e=this.chart,i=e.options.plotOptions,s=e.userOptions||{},t=merge(t),r=e.styledMode,a={plotOptions:i,userOptions:t};let o;fireEvent(this,"setOptions",a);var n=a.plotOptions[this.type],s=s.plotOptions||{},l=s.series||{},h=defaultOptions.plotOptions[this.type]||{},p=s[this.type]||{};this.userOptions=a.userOptions;const d=merge(n,i.series,p,t),c=(this.tooltipOptions=merge(defaultOptions.tooltip,defaultOptions.plotOptions.series?.tooltip,h?.tooltip,e.userOptions.tooltip,s.series?.tooltip,p.tooltip,t.tooltip),this.stickyTracking=pick(t.stickyTracking,p.stickyTracking,l.stickyTracking,!(!this.tooltipOptions.shared||this.noSharedTooltip)||d.stickyTracking),null===n.marker&&delete d.marker,this.zoneAxis=d.zoneAxis||"y",this.zones=(d.zones||[]).map(t=>({...t})));return!d.negativeColor&&!d.negativeFillColor||d.zones||(o={value:d[this.zoneAxis+"Threshold"]||d.threshold||0,className:"highcharts-negative"},r||(o.color=d.negativeColor,o.fillColor=d.negativeFillColor),c.push(o)),c.length&&defined(c[c.length-1].value)&&c.push(r?{}:{color:this.color,fillColor:this.fillColor}),fireEvent(this,"afterSetOptions",{options:d}),d}getName(){return pick(this.options.name,"Series "+(this.index+1))}getCyclic(t,e,i){const s=this.chart,r=t+"Index",a=t+"Counter",o=i?.length||s.options.chart.colorCount;let n,l;e||(l=pick("color"===t?this.options.colorIndex:void 0,this[r]),defined(l)?n=l:(s.series.length||(s[a]=0),n=s[a]%o,s[a]+=1),i&&(e=i[n])),void 0!==n&&(this[r]=n),this[t]=e}getColor(){this.chart.styledMode?this.getCyclic("color"):this.options.colorByPoint?this.color="#cccccc":this.getCyclic("color",this.options.color||defaultOptions.plotOptions[this.type].color,this.chart.options.colors)}getPointsCollection(){return(this.hasGroupedData?this.points:this.data)||[]}getSymbol(){var t=this.options.marker;this.getCyclic("symbol",t.symbol,this.chart.options.symbols)}findPointIndex(e,t){var i=e.id,s=e.x,r=this.points,a=this.options.dataSorting;let o,n,l;if(i){i=this.chart.get(i);i instanceof Point&&(o=i)}else if(this.linkedParent||this.enabledDataSorting||this.options.relativeXValue){let t=t=>!t.touched&&t.index===e.index;if(a&&a.matchByName?t=t=>!t.touched&&t.name===e.name:this.options.relativeXValue&&(t=t=>!t.touched&&t.options.x===e.x),!(o=find(r,t)))return}return o&&void 0!==(l=o&&o.index)&&(n=!0),-1!==(l=void 0===l&&isNumber(s)?this.xData.indexOf(s,t):l)&&void 0!==l&&this.cropped&&(l=l>=this.cropStart?l-this.cropStart:l),l=!n&&isNumber(l)&&r[l]&&r[l].touched?void 0:l}updateData(t,e){const r=this.options,a=r.dataSorting,o=this.points,n=[],l=this.requireSorting,h=t.length===o.length;let p,i,s,d,c=!0;if(this.xIncrement=null,t.forEach(function(t,e){var i=defined(t)&&this.pointClass.prototype.optionsToObject.call({series:this},t)||{},s=i.x;i.id||isNumber(s)?(-1===(s=this.findPointIndex(i,d))||void 0===s?n.push(t):o[s]&&t!==r.data[s]?(o[s].update(t,!1,null,!1),o[s].touched=!0,l&&(d=s+1)):o[s]&&(o[s].touched=!0),(!h||e!==s||a&&a.enabled||this.hasDerivedData)&&(p=!0)):n.push(t)},this),p)for(i=o.length;i--;)(s=o[i])&&!s.touched&&s.remove&&s.remove(!1,e);else!h||a&&a.enabled?c=!1:(t.forEach(function(t,e){t===o[e].y||o[e].destroyed||o[e].update(t,!1,null,!1)}),n.length=0);return o.forEach(function(t){t&&(t.touched=!1)}),!!c&&(n.forEach(function(t){this.addPoint(t,!1,null,null,!1)},this),null===this.xIncrement&&this.xData&&this.xData.length&&(this.xIncrement=arrayMax(this.xData),this.autoIncrement()),!0)}setData(e,t=!0,i,s){const r=this,a=r.points,o=a&&a.length||0,n=r.options,l=r.chart,h=n.dataSorting,p=r.xAxis,d=n.turboThreshold,c=this.xData,u=this.yData,g=r.pointArrayMap,m=g&&g.length,f=n.keys;let y,v,x,b=0,k=1,D;l.options.chart.allowMutatingData||(n.data&&delete r.options.data,r.userOptions.data&&delete r.userOptions.data,D=merge(!0,e));var S=(e=D||e||[]).length;if(h&&h.enabled&&(e=this.sortData(e)),!(x=l.options.chart.allowMutatingData&&!1!==s&&S&&o&&!r.cropped&&!r.hasGroupedData&&r.visible&&!r.boosted?this.updateData(e,i):x)){r.xIncrement=null,r.colorCounter=0,this.parallelArrays.forEach(function(t){r[t+"Data"].length=0});let t=d&&d<S;if(t){var s=r.getFirstValidPoint(e),A=r.getFirstValidPoint(e,S-1,-1),E=t=>Boolean(isArray(t)&&(f||isNumber(t[0])));if(isNumber(s)&&isNumber(A))for(y=0;y<S;y++)c[y]=this.autoIncrement(),u[y]=e[y];else if(E(s)&&E(A))if(m)if(s.length===m)for(y=0;y<S;y++)c[y]=this.autoIncrement(),u[y]=e[y];else for(y=0;y<S;y++)v=e[y],c[y]=v[0],u[y]=v.slice(1,m+1);else if(f&&(b=f.indexOf("x"),k=f.indexOf("y"),b=0<=b?b:0,k=0<=k?k:1),1===s.length&&(k=0),b===k)for(y=0;y<S;y++)c[y]=this.autoIncrement(),u[y]=e[y][k];else for(y=0;y<S;y++)v=e[y],c[y]=v[b],u[y]=v[k];else t=!1}if(!t)for(y=0;y<S;y++)v={series:r},r.pointClass.prototype.applyOptions.apply(v,[e[y]]),r.updateParallelArrays(v,y);for(u&&isString(u[0])&&error(14,!0,l),r.data=[],r.options.data=r.userOptions.data=e,y=o;y--;)a[y]?.destroy();p&&(p.minRange=p.userMinRange),r.isDirty=l.isDirtyBox=!0,r.isDirtyData=!!a,i=!1}"point"===n.legendType&&(this.processData(),this.generatePoints()),t&&l.redraw(i)}sortData(r){function a(t,e){return defined(e)&&t.pointClass.prototype.optionsToObject.call({series:t},e)||{}}const i=this,t=i.options,e=t.dataSorting,s=e.sortKey||"y",o=(r.forEach(function(t,e){r[e]=a(i,t),r[e].index=e},this),r.concat().sort((t,e)=>{t=getNestedProperty(s,t),e=getNestedProperty(s,e);return e<t?-1:t<e?1:0}));return o.forEach(function(t,e){t.x=e},this),i.linkedSeries&&i.linkedSeries.forEach(function(i){const t=i.options,s=t.data;t.dataSorting&&t.dataSorting.enabled||!s||(s.forEach(function(t,e){s[e]=a(i,t),r[e]&&(s[e].x=r[e].x,s[e].index=e)}),i.setData(s,!1))}),r}getProcessedData(t){const e=this,i=e.xAxis,s=e.options,r=s.cropThreshold,a=i?.logarithmic,o=e.isCartesian;let n,l,h=0,p,d,c,u=e.xData,g=e.yData,m=!1;var f=u.length,t=(i&&(p=i.getExtremes(),d=p.min,c=p.max,m=!(!i.categories||i.names.length)),o&&e.sorted&&!t&&(!r||r<f||e.forceCrop)&&(u[f-1]<d||u[0]>c?(u=[],g=[]):e.yData&&(u[0]<d||u[f-1]>c)&&(n=this.cropData(e.xData,e.yData,d,c),u=n.xData,g=n.yData,h=n.start,l=!0)),getClosestDistance([a?u.map(a.log2lin):u],()=>e.requireSorting&&!m&&error(15,!1,e.chart)));return{xData:u,yData:g,cropped:l,cropStart:h,closestPointRange:t}}processData(t){var e=this,i=e.xAxis;if(e.isCartesian&&!e.isDirty&&!i.isDirty&&!e.yAxis.isDirty&&!t)return!1;i=e.getProcessedData();e.cropped=i.cropped,e.cropStart=i.cropStart,e.processedXData=i.xData,e.processedYData=i.yData,e.closestPointRange=e.basePointRange=i.closestPointRange,fireEvent(e,"afterProcessData")}cropData(t,e,i,s){var r=t.length;let a,o,n=0,l=r;for(a=0;a<r;a++)if(t[a]>=i){n=Math.max(0,a-1);break}for(o=a;o<r;o++)if(t[o]>s){l=o+1;break}return{xData:t.slice(n,l),yData:e.slice(n,l),start:n,end:l}}generatePoints(){const t=this,e=t.options,i=t.processedData||e.data,s=t.processedXData,r=t.processedYData,a=t.pointClass,o=s.length,n=t.cropStart||0,l=t.hasGroupedData,h=e.keys,p=[],d=e.dataGrouping&&e.dataGrouping.groupAll?n:0;let c,u,g,m,f=t.data;if(!f&&!l){const y=[];y.length=i.length,f=t.data=y}for(h&&l&&(t.options.keys=!1),m=0;m<o;m++)u=n+m,l?((g=new a(t,[s[m]].concat(splat(r[m])))).dataGroup=t.groupMap[d+m],g.dataGroup.options&&(g.options=g.dataGroup.options,extend(g,g.dataGroup.options),delete g.dataLabels)):(g=f[u])||void 0===i[u]||(f[u]=g=new a(t,i[u],s[m])),g&&(g.index=l?d+m:u,p[m]=g);if(t.options.keys=h,f&&(o!==(c=f.length)||l))for(m=0;m<c;m++)m!==n||l||(m+=o),f[m]&&(f[m].destroyElements(),f[m].plotX=void 0);t.data=f,t.points=p,fireEvent(this,"afterGeneratePoints")}getXExtremes(t){return{min:arrayMin(t),max:arrayMax(t)}}getExtremes(t,e){const i=this.xAxis,s=this.yAxis,r=[],a=this.requireSorting&&!this.is("column")?1:0,o=!!s&&s.positiveValuesOnly,n=e||this.getExtremesFromAll||this.options.getExtremesFromAll;let{processedXData:l,processedYData:h}=this,p,d,c,u,g,m,f,y=0,v=0,x=0;this.cropped&&n&&(D=this.getProcessedData(!0),l=D.xData,h=D.yData);var b=(t=t||this.stackedYData||h||[]).length,k=l||this.xData;for(i&&(p=i.getExtremes(),y=p.min,v=p.max),m=0;m<b;m++)if(u=k[m],g=t[m],d=(isNumber(g)||isArray(g))&&((isNumber(g)?0<g:g.length)||!o),c=e||this.getExtremesFromAll||this.options.getExtremesFromAll||this.cropped||!i||(k[m+a]||u)>=y&&(k[m-a]||u)<=v,d&&c)if(f=g.length)for(;f--;)isNumber(g[f])&&(r[x++]=g[f]);else r[x++]=g;var D={activeYData:r,dataMin:arrayMin(r),dataMax:arrayMax(r)};return fireEvent(this,"afterGetExtremes",{dataExtremes:D}),D}applyExtremes(){var t=this.getExtremes();return this.dataMin=t.dataMin,this.dataMax=t.dataMax,t}getFirstValidPoint(t,e=0,i=1){var s=t.length;let r=e;for(;0<=r&&r<s;){if(defined(t[r]))return t[r];r+=i}}translate(){this.processedXData||this.processData(),this.generatePoints();const a=this,t=a.options,o=t.stacking,n=a.xAxis,l=n.categories,h=a.enabledDataSorting,p=a.yAxis,d=a.points,e=d.length,c=a.pointPlacementToXValue(),u=Boolean(c),g=t.threshold,m=t.startFromThreshold?g:0;let f,y,v,x,b=Number.MAX_VALUE;function k(t){return clamp(t,-1e9,1e9)}for(f=0;f<e;f++){const S=d[f],A=S.x;let t,e,i=S.y,s=S.low;var D=o&&p.stacking?.stacks[(a.negStacks&&i<(m?0:g)?"-":"")+a.stackKey];y=n.translate(A,!1,!1,!1,!0,c),S.plotX=isNumber(y)?correctFloat(k(y)):void 0,o&&a.visible&&D&&D[A]&&(x=a.getStackIndicator(x,A,a.index),!S.isNull&&x.key&&(t=D[A],e=t.points[x.key]),t&&isArray(e)&&(s=e[0],i=e[1],s===m&&x.key===D[A].base&&(s=pick(isNumber(g)?g:p.min)),p.positiveValuesOnly&&defined(s)&&s<=0&&(s=void 0),S.total=S.stackTotal=pick(t.total),S.percentage=defined(S.y)&&t.total?S.y/t.total*100:void 0,S.stackY=i,a.irregularWidths||t.setOffset(a.pointXOffset||0,a.barW||0,void 0,void 0,void 0,a.xAxis))),S.yBottom=defined(s)?k(p.translate(s,!1,!0,!1,!0)):void 0,a.dataModify&&(i=a.dataModify.modifyValue(i,f));let r;isNumber(i)&&void 0!==S.plotX&&(r=p.translate(i,!1,!0,!1,!0),r=isNumber(r)?k(r):void 0),S.plotY=r,S.isInside=this.isPointInside(S),S.clientX=u?correctFloat(n.translate(A,!1,!1,!1,!0,c)):y,S.negative=(S.y||0)<(g||0),S.category=pick(l&&l[S.x],S.x),S.isNull||!1===S.visible||(void 0!==v&&(b=Math.min(b,Math.abs(y-v))),v=y),S.zone=this.zones.length?S.getZone():void 0,!S.graphic&&a.group&&h&&(S.isNew=!0)}a.closestPointRangePx=b,fireEvent(this,"afterTranslate")}getValidPoints(t,s,r){const a=this.chart;return(t||this.points||[]).filter(function(t){var{plotX:e,plotY:i}=t;return!(!(r||!t.isNull&&isNumber(i))||s&&!a.isInsidePlot(e,i,{inverted:a.inverted}))&&!1!==t.visible})}getClipBox(){var{chart:t,xAxis:e,yAxis:i}=this;let{x:s,y:r,width:a,height:o}=merge(t.clipBox);return e&&e.len!==t.plotSizeX&&(a=e.len),i&&i.len!==t.plotSizeY&&(o=i.len),t.inverted&&!this.invertible&&([a,o]=[o,a]),{x:s,y:r,width:a,height:o}}getSharedClipKey(){return this.sharedClipKey=(this.options.xAxis||0)+","+(this.options.yAxis||0),this.sharedClipKey}setClip(){const{chart:t,group:e,markerGroup:i}=this,s=t.sharedClips,r=t.renderer,a=this.getClipBox(),o=this.getSharedClipKey();let n=s[o];n?n.animate(a):s[o]=n=r.clipRect(a),e&&e.clip(!1===this.options.clip?void 0:n),i&&i.clip()}animate(t){const{chart:e,group:i,markerGroup:s}=this,r=e.inverted,a=animObject(this.options.animation),o=[this.getSharedClipKey(),a.duration,a.easing,a.defer].join(",");let n=e.sharedClips[o],l=e.sharedClips[o+"m"];if(t&&i){const h=this.getClipBox();n?n.attr("height",h.height):(h.width=0,r&&(h.x=e.plotHeight),n=e.renderer.clipRect(h),e.sharedClips[o]=n,t={x:(r,-99),y:(r,-99),width:r?e.plotWidth+199:99,height:r?99:e.plotHeight+199},l=e.renderer.clipRect(t),e.sharedClips[o+"m"]=l),i.clip(n),s?.clip(l)}else if(n&&!n.hasClass("highcharts-animating")){const p=this.getClipBox(),d=a.step;(s?.element.childNodes.length||1<e.series.length)&&(a.step=function(t,e){d&&d.apply(e,arguments),"width"===e.prop&&l?.element&&l.attr(r?"height":"width",t+99)}),n.addClass("highcharts-animating").animate(p,a)}}afterAnimate(){this.setClip(),objectEach(this.chart.sharedClips,(t,e,i)=>{t&&!this.chart.container.querySelector(`[clip-path="url(#${t.id})"]`)&&(t.destroy(),delete i[e])}),this.finishedAnimating=!0,fireEvent(this,"afterAnimate")}drawPoints(t=this.points){const e=this,i=e.chart,s=i.styledMode,{colorAxis:r,options:a}=e,o=a.marker,n=e[e.specialGroup||"markerGroup"],l=e.xAxis,h=pick(o.enabled,!(l&&!l.isRadial)||null,e.closestPointRangePx>=o.enabledThreshold*o.radius);let p,d,c,u,g,m,f;if(!1!==o.enabled||e._hasPointMarkers)for(p=0;p<t.length;p++){var y,v;d=t[p],c=d.graphic,u=c?"animate":"attr",g=d.marker||{},m=!!d.marker,(h&&void 0===g.enabled||g.enabled)&&!d.isNull&&!1!==d.visible?(v=pick(g.symbol,e.symbol,"rect"),f=e.markerAttribs(d,d.selected&&"select"),e.enabledDataSorting&&(d.startXPos=l.reversed?-(f.width||0):l.width),y=!1!==d.isInside,!c&&y&&(0<(f.width||0)||d.hasImage)&&(d.graphic=c=i.renderer.symbol(v,f.x,f.y,f.width,f.height,m?g:o).add(n),e.enabledDataSorting&&i.hasRendered&&(c.attr({x:d.startXPos}),u="animate")),c&&"animate"===u&&c[y?"show":"hide"](y).animate(f),c&&(v=e.pointAttribs(d,s||!d.selected?void 0:"select"),s?r&&c.css({fill:v.fill}):c[u](v)),c&&c.addClass(d.getClassName(),!0)):c&&(d.graphic=c.destroy())}}markerAttribs(t,e){const i=this.options,s=i.marker,r=t.marker||{},a=r.symbol||s.symbol,o={};let n,l,h=pick(r.radius,s&&s.radius);e&&(n=s.states[e],l=r.states&&r.states[e],h=pick(l&&l.radius,n&&n.radius,h&&h+(n&&n.radiusPlus||0))),t.hasImage=a&&0===a.indexOf("url"),t.hasImage&&(h=0);const p=t.pos();return isNumber(h)&&p&&(i.crisp&&(p[0]=crisp(p[0],t.hasImage?0:"rect"===a?s?.lineWidth||0:1)),o.x=p[0]-h,o.y=p[1]-h),h&&(o.width=o.height=2*h),o}pointAttribs(t,e){var i=this.options.marker,s=t&&t.options,r=s&&s.marker||{},s=s&&s.color,a=t&&t.color,t=t&&t.zone&&t.zone.color;let o,n,l=this.color,h,p,d=pick(r.lineWidth,i.lineWidth),c=1;return l=s||t||a||l,h=r.fillColor||i.fillColor||l,p=r.lineColor||i.lineColor||l,(e=e||"normal")&&(o=i.states[e]||{},n=r.states&&r.states[e]||{},d=pick(n.lineWidth,o.lineWidth,d+pick(n.lineWidthPlus,o.lineWidthPlus,0)),h=n.fillColor||o.fillColor||h,p=n.lineColor||o.lineColor||p,c=pick(n.opacity,o.opacity,c)),{stroke:p,"stroke-width":d,fill:h,opacity:c}}destroy(i){const s=this,t=s.chart,r=/AppleWebKit\/533/.test(win.navigator.userAgent),e=s.data||[];let a,o,n,l;for(fireEvent(s,"destroy",{keepEventsForUpdate:i}),this.removeEvents(i),(s.axisTypes||[]).forEach(function(t){(l=s[t])&&l.series&&(erase(l.series,s),l.isDirty=l.forceRedraw=!0)}),s.legendItem&&s.chart.legend.destroyItem(s),o=e.length;o--;)(n=e[o])&&n.destroy&&n.destroy();for(const h of s.zones)destroyObjectProperties(h,void 0,!0);U.clearTimeout(s.animationTimeout),objectEach(s,function(t,e){t instanceof SVGElement&&!t.survive&&t[a=r&&"group"===e?"hide":"destroy"]()}),t.hoverSeries===s&&(t.hoverSeries=void 0),erase(t.series,s),t.orderItems("series"),objectEach(s,function(t,e){i&&"hcEvents"===e||delete s[e]})}applyZones(){const{area:u,chart:t,graph:g,zones:e,points:i,xAxis:m,yAxis:f,zoneAxis:s}=this,{inverted:y,renderer:v}=t,r=this[s+"Axis"],{isXAxis:x,len:o=0}=r||{},n=(g?.strokeWidth()||0)/2+1,a=(t,e=0,i=0)=>{const{translated:s=0,lineClip:r}=t,a=(i=y?o-i:i)-s;r?.push(["L",e,Math.abs(a)<n?i-n*(a<=0?-1:1):s])};if(e.length&&(g||u)&&r&&isNumber(r.min)){const k=r.getExtremes().max,D=i=>{i.forEach((t,e)=>{"M"!==t[0]&&"L"!==t[0]||(i[e]=[t[0],x?o-t[1]:t[1],x?t[2]:o-t[2]])})};if(e.forEach(t=>{t.lineClip=[],t.translated=clamp(r.toPixels(pick(t.value,k),!0)||0,0,o)}),g&&!this.showLine&&g.hide(),u&&u.hide(),"y"===s&&i.length<m.len)for(const S of i){var{plotX:l,plotY:h,zone:p}=S,b=p&&e[e.indexOf(p)-1];p&&a(p,l,h),b&&a(b,l,h)}let d=[],c=r.toPixels(r.getExtremes().min,!0);e.forEach(t=>{const e=t.lineClip||[],i=Math.round(t.translated||0);m.reversed&&e.reverse();let{clip:s,simpleClip:r}=t,a=0,o=0,n=m.len,l=f.len;x?(a=i,n=c):(o=i,l=c);var h=[["M",a,o],["L",n,o],["L",n,l],["L",a,l],["Z"]],p=[h[0],...e,h[1],h[2],...d,h[3],h[4]];d=e.reverse(),c=i,y&&(D(p),u&&D(h)),s?(s.animate({d:p}),r?.animate({d:h})):(s=t.clip=v.path(p),u&&(r=t.simpleClip=v.path(h))),g&&t.graph?.clip(s),u&&t.area?.clip(r)})}else this.visible&&(g&&g.show(),u&&u.show())}plotGroup(t,e,i,s,r){let a=this[t];const o=!a,n={visibility:i,zIndex:s||.1};return defined(this.opacity)&&!this.chart.styledMode&&"inactive"!==this.state&&(n.opacity=this.opacity),a||(this[t]=a=this.chart.renderer.g().add(r)),a.addClass("highcharts-"+e+" highcharts-series-"+this.index+" highcharts-"+this.type+"-series "+(defined(this.colorIndex)?"highcharts-color-"+this.colorIndex+" ":"")+(this.options.className||"")+(a.hasClass("highcharts-tracker")?" highcharts-tracker":""),!0),a.attr(n)[o?"attr":"animate"](this.getPlotBox(e)),a}getPlotBox(t){let e=this.xAxis,i=this.yAxis;var s=this.chart,t=s.inverted&&!s.polar&&e&&this.invertible&&"series"===t;return s.inverted&&(e=i,i=this.xAxis),{translateX:e?e.left:s.plotLeft,translateY:i?i.top:s.plotTop,rotation:t?90:0,rotationOriginX:t?(e.len-i.len)/2:0,rotationOriginY:t?(e.len+i.len)/2:0,scaleX:t?-1:1,scaleY:1}}removeEvents(t){const e=this["eventsToUnbind"];t||removeEvent(this),e.length&&(e.forEach(t=>{t()}),e.length=0)}render(){const t=this,{chart:e,options:i,hasRendered:s}=t,r=animObject(i.animation),a=t.visible?"inherit":"hidden",o=i.zIndex,n=e.seriesGroup;let l=t.finishedAnimating?0:r.duration;fireEvent(this,"render"),t.plotGroup("group","series",a,o,n),t.markerGroup=t.plotGroup("markerGroup","markers",a,o,n),!1!==i.clip&&t.setClip(),l&&t.animate?.(!0),t.drawGraph&&(t.drawGraph(),t.applyZones()),t.visible&&t.drawPoints(),t.drawDataLabels?.(),t.redrawPoints?.(),i.enableMouseTracking&&t.drawTracker?.(),l&&t.animate?.(),s||(l&&r.defer&&(l+=r.defer),t.animationTimeout=syncTimeout(()=>{t.afterAnimate()},l||0)),t.isDirty=!1,t.hasRendered=!0,fireEvent(t,"afterRender")}redraw(){var t=this.isDirty||this.isDirtyData;this.translate(),this.render(),t&&delete this.kdTree}reserveSpace(){return this.visible||!this.chart.options.chart.ignoreHiddenSeries}searchPoint(t,e){var{xAxis:i,yAxis:s}=this,r=this.chart.inverted;return this.searchKDTree({clientX:r?i.len-t.chartY+i.pos:t.chartX-i.pos,plotY:r?s.len-t.chartX+s.pos:t.chartY-s.pos},e,t)}buildKDTree(t){this.buildingKdTree=!0;const n=this,e=-1<n.options.findNearestPointBy.indexOf("y")?2:1;delete n.kdTree,syncTimeout(function(){n.kdTree=function t(e,i,s){var r=e?.length;let a,o;if(r)return a=n.kdAxisArray[i%s],e.sort((t,e)=>(t[a]||0)-(e[a]||0)),{point:e[o=Math.floor(r/2)],left:t(e.slice(0,o),i+1,s),right:t(e.slice(o+1),i+1,s)}}(n.getValidPoints(void 0,!n.directTouch),e,e),n.buildingKdTree=!1},n.options.kdNow||"touchstart"===t?.type?0:1)}searchKDTree(t,e,i){const u=this,[g,m]=this.kdAxisArray,f=e?"distX":"dist",s=-1<(u.options.findNearestPointBy||"").indexOf("y")?2:1,y=!!u.isBubble;function v(t,e,i,s){var r,a=e.point,o=u.kdAxisArray[i%s];let n,l,h=a;d=a,c=(r=t)[g],p=d[g],c=defined(c)&&defined(p)?c-p:null,p=r[m],r=d[m],p=defined(p)&&defined(r)?p-r:0,r=y&&d.marker?.radius||0,d.dist=Math.sqrt((c&&c*c||0)+p*p)-r,d.distX=defined(c)?Math.abs(c)-r:Number.MAX_VALUE;var p=(t[o]||0)-(a[o]||0)+(y&&a.marker?.radius||0),d=p<0?"left":"right",c=p<0?"right":"left";return e[d]&&(n=v(t,e[d],i+1,s),h=n[f]<h[f]?n:a),e[c]&&Math.sqrt(p*p)<h[f]&&(l=v(t,e[c],i+1,s),h=l[f]<h[f]?l:h),h}if(this.kdTree||this.buildingKdTree||this.buildKDTree(i),this.kdTree)return v(t,this.kdTree,s,s)}pointPlacementToXValue(){var{options:t,xAxis:e}=this;let i=t.pointPlacement;return"between"===i&&(i=e.reversed?-.5:.5),isNumber(i)?i*(t.pointRange||e.pointRange):0}isPointInside(t){var{chart:e,xAxis:i,yAxis:s}=this,{plotX:t=-1,plotY:r=-1}=t;return 0<=r&&r<=(s?s.len:e.plotHeight)&&0<=t&&t<=(i?i.len:e.plotWidth)}drawTracker(){const t=this,e=t.options,i=e.trackByArea,s=[].concat((i?t.areaPath:t.graphPath)||[]),r=t.chart,a=r.pointer,o=r.renderer,n=r.options.tooltip?.snap||0,l=()=>{e.enableMouseTracking&&r.hoverSeries!==t&&t.onMouseOver()},h="rgba(192,192,192,"+(svg?1e-4:.002)+")";let p=t.tracker;p?p.attr({d:s}):t.graph&&(t.tracker=p=o.path(s).attr({visibility:t.visible?"inherit":"hidden",zIndex:2}).addClass(i?"highcharts-tracker-area":"highcharts-tracker-line").add(t.group),r.styledMode||p.attr({"stroke-linecap":"round","stroke-linejoin":"round",stroke:h,fill:i?h:"none","stroke-width":t.graph.strokeWidth()+(i?0:2*n)}),[t.tracker,t.markerGroup,t.dataLabelsGroup].forEach(t=>{t&&(t.addClass("highcharts-tracker").on("mouseover",l).on("mouseout",t=>{a?.onTrackerMouseOut(t)}),e.cursor&&!r.styledMode&&t.css({cursor:e.cursor}),t.on("touchstart",l))})),fireEvent(this,"afterDrawTracker")}addPoint(t,e,i,s,r){const a=this,o=a.options,n=a.data,l=a.chart,h=a.xAxis,p=h&&h.hasNames&&h.names,d=o.data,c=a.xData;let u,g;e=pick(e,!0);var m={series:a},f=(a.pointClass.prototype.applyOptions.apply(m,[t]),m.x);if(g=c.length,a.requireSorting&&f<c[g-1])for(u=!0;g&&c[g-1]>f;)g--;a.updateParallelArrays(m,"splice",[g,0,0]),a.updateParallelArrays(m,g),p&&m.name&&(p[f]=m.name),d.splice(g,0,t),(u||a.processedData)&&(a.data.splice(g,0,null),a.processData()),"point"===o.legendType&&a.generatePoints(),i&&(n[0]&&n[0].remove?n[0].remove(!1):(n.shift(),a.updateParallelArrays(m,"shift"),d.shift())),!1!==r&&fireEvent(a,"addPoint",{point:m}),a.isDirty=!0,a.isDirtyData=!0,e&&l.redraw(s)}removePoint(t,e,i){function s(){n&&n.length===a.length&&n.splice(t,1),a.splice(t,1),r.options.data.splice(t,1),r.updateParallelArrays(o||{series:r},"splice",[t,1]),o&&o.destroy(),r.isDirty=!0,r.isDirtyData=!0,e&&l.redraw()}const r=this,a=r.data,o=a[t],n=r.points,l=r.chart;setAnimation(i,l),e=pick(e,!0),o?o.firePointEvent("remove",null,s):s()}remove(t,e,i,s){const r=this,a=r.chart;function o(){r.destroy(s),a.isDirtyLegend=a.isDirtyBox=!0,a.linkSeries(s),pick(t,!0)&&a.redraw(e)}!1!==i?fireEvent(r,"remove",null,o):o()}update(t,e){t=diffObjects(t,this.userOptions),fireEvent(this,"update",{options:t});const i=this,s=i.chart,r=i.userOptions,a=i.initialType||i.type,o=s.options.plotOptions,n=seriesTypes[a].prototype,l=i.finishedAnimating&&{animation:!1},h={};let p,d,c=["colorIndex","eventOptions","navigatorSeries","symbolIndex","baseSeries"],u=t.type||r.type||s.options.chart.type;var g=!(this.hasDerivedData||u&&u!==this.type||void 0!==t.pointStart||void 0!==t.pointInterval||void 0!==t.relativeXValue||t.joinBy||t.mapData||["dataGrouping","pointStart","pointInterval","pointIntervalUnit","keys"].some(t=>i.hasOptionChanged(t)));u=u||a,g&&(c.push("data","isDirtyData","isDirtyCanvas","points","processedData","processedXData","processedYData","xIncrement","cropped","_hasPointMarkers","hasDataLabels","nodes","layout","level","mapMap","mapData","minY","maxY","minX","maxX","transformGroups"),!1!==t.visible&&c.push("area","graph"),i.parallelArrays.forEach(function(t){c.push(t+"Data")}),t.data&&(t.dataSorting&&extend(i.options.dataSorting,t.dataSorting),this.setData(t.data,!1))),t=merge(r,{index:(void 0===r.index?i:r).index,pointStart:o?.series?.pointStart??r.pointStart??i.xData?.[0]},!g&&{data:i.options.data},t,l),g&&t.data&&(t.data=i.options.data),(c=["group","markerGroup","dataLabelsGroup","transformGroup"].concat(c)).forEach(function(t){c[t]=i[t],delete i[t]});let m=!1;if(seriesTypes[u]){if(m=u!==i.type,i.remove(!1,!1,!1,!0),m)if(s.propFromSeries(),Object.setPrototypeOf)Object.setPrototypeOf(i,seriesTypes[u].prototype);else{var f=Object.hasOwnProperty.call(i,"hcEvents")&&i.hcEvents;for(d in n)i[d]=void 0;extend(i,seriesTypes[u].prototype),f?i.hcEvents=f:delete i.hcEvents}}else error(17,!0,s,{missingModuleFor:u});if(c.forEach(function(t){i[t]=c[t]}),i.init(s,t),g&&this.points){!1===(p=i.options).visible?(h.graphic=1,h.dataLabel=1):(this.hasMarkerChanged(p,r)&&(h.graphic=1),i.hasDataLabels?.()||(h.dataLabel=1));for(const y of this.points)y&&y.series&&(y.resolveColor(),Object.keys(h).length&&y.destroyElements(h),!1===p.showInLegend&&y.legendItem&&s.legend.destroyItem(y))}i.initialType=a,s.linkSeries(),s.setSortedData(),m&&i.linkedSeries.length&&(i.isDirtyData=!0),fireEvent(this,"afterUpdate"),pick(e,!0)&&s.redraw(g&&void 0)}setName(t){this.name=this.options.name=this.userOptions.name=t,this.chart.isDirtyLegend=!0}hasOptionChanged(t){var e=this.chart,i=this.options[t],e=e.options.plotOptions,s=this.userOptions[t],e=pick(e?.[this.type]?.[t],e?.series?.[t]);return s&&!defined(e)?i!==s:i!==pick(e,i)}onMouseOver(){const t=this,e=t.chart,i=e.hoverSeries,s=e.pointer;s?.setHoverChartIndex(),i&&i!==t&&i.onMouseOut(),t.options.events.mouseOver&&fireEvent(t,"mouseOver"),t.setState("hover"),e.hoverSeries=t}onMouseOut(){const t=this,e=t.options,i=t.chart,s=i.tooltip,r=i.hoverPoint;i.hoverSeries=null,r&&r.onMouseOut(),t&&e.events.mouseOut&&fireEvent(t,"mouseOut"),!s||t.stickyTracking||s.shared&&!t.noSharedTooltip||s.hide(),i.series.forEach(function(t){t.setState("",!0)})}setState(e,t){const i=this,s=i.options,r=i.graph,a=s.inactiveOtherPoints,o=s.states,n=pick(o[e||"normal"]&&o[e||"normal"].animation,i.chart.options.chart.animation);let l=s.lineWidth,h=s.opacity;if(e=e||"",i.state!==e&&([i.group,i.markerGroup,i.dataLabelsGroup].forEach(function(t){t&&(i.state&&t.removeClass("highcharts-series-"+i.state),e&&t.addClass("highcharts-series-"+e))}),i.state=e,!i.chart.styledMode)){if(o[e]&&!1===o[e].enabled)return;if(e&&(l=o[e].lineWidth||l+(o[e].lineWidthPlus||0),h=pick(o[e].opacity,h)),r&&!r.dashstyle&&isNumber(l))for(const p of[r,...this.zones.map(t=>t.graph)])p?.animate({"stroke-width":l},n);a||[i.group,i.markerGroup,i.dataLabelsGroup,i.labelBySeries].forEach(function(t){t&&t.animate({opacity:h},n)})}t&&a&&i.points&&i.setAllPointsToState(e||void 0)}setAllPointsToState(e){this.points.forEach(function(t){t.setState&&t.setState(e)})}setVisible(e,t){const i=this,s=i.chart,r=s.options.chart.ignoreHiddenSeries,a=i.visible,o=(i.visible=e=i.options.visible=i.userOptions.visible=void 0===e?!a:e,e?"show":"hide");["group","dataLabelsGroup","markerGroup","tracker","tt"].forEach(t=>{i[t]?.[o]()}),s.hoverSeries!==i&&s.hoverPoint?.series!==i||i.onMouseOut(),i.legendItem&&s.legend.colorizeItem(i,e),i.isDirty=!0,i.options.stacking&&s.series.forEach(t=>{t.options.stacking&&t.visible&&(t.isDirty=!0)}),i.linkedSeries.forEach(t=>{t.setVisible(e,!1)}),r&&(s.isDirtyBox=!0),fireEvent(i,o),!1!==t&&s.redraw()}show(){this.setVisible(!0)}hide(){this.setVisible(!1)}select(t){var e=this;e.selected=t=this.options.selected=void 0===t?!e.selected:t,e.checkbox&&(e.checkbox.checked=t),fireEvent(e,t?"select":"unselect")}shouldShowTooltip(t,e,i={}){return i.series=this,i.visiblePlotOnly=!0,this.chart.isInsidePlot(t,e,i)}drawLegendSymbol(t,e){LegendSymbol[this.options.legendSymbol||"rectangle"]?.call(this,t,e)}}Series.defaultOptions=SeriesDefaults,Series.types=SeriesRegistry.seriesTypes,Series.registerType=SeriesRegistry.registerSeriesType,extend(Series.prototype,{axisTypes:["xAxis","yAxis"],coll:"series",colorCounter:0,directTouch:!1,invertible:!0,isCartesian:!0,kdAxisArray:["clientX","plotY"],parallelArrays:["x","y"],pointClass:Point,requireSorting:!0,sorted:!0});export default SeriesRegistry.series=Series;