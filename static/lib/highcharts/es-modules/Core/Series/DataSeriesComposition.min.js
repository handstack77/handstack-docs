"use strict";import DataTable from"../../Data/DataTable.js";import H from"../Globals.js";const composed=H["composed"];import U from"../Utilities.js";const{addEvent,fireEvent,isNumber,merge,pushUnique,wrap}=U;function wrapSeriesGeneratePoints(t){if(this.hasGroupedData)return t.call(this);const s=this.pointClass,a=this.cropStart||0,n=this.data||[],i=[],o=this.processedXData,r=this.processedYData;let l,h;for(let t=0,e=o.length;t<e;++t)l=a+t,(h=(h=n[l])||(n[l]=new s(this,r[l],o[t]))).index=l,i[t]=h;this.data=n,this.points=i,fireEvent(this,"afterGeneratePoints")}function wrapSeriesSetData(t,s=[],e=!0,a){const n=this.datas;if(this.hasGroupedData||!this.options.dataAsColumns)return t.call(this,s,e,a);s=this.options.data=this.userOptions.data=this.chart.options.chart.allowMutatingData?s||[]:merge(!0,s);const i={},o=(this.options.keys||this.parallelArrays).slice();if(isNumber(s[0])||1===o.length){const r=i.x=[];for(let t=0,e=s.length;t<e;++t)r.push(this.autoIncrement());i[o[1]||"y"]=s}else{if(-1===o.indexOf("x")&&o.length>s.length){const l=i.x=[];for(let t=0,e=s.length;t<e;++t)l.push(this.autoIncrement())}for(let t=0,e=Math.min(s.length,o.length);t<e;++t)s[t]instanceof Array&&(i[o[t]]=s[t])}n.setTable(new DataTable({columns:i,id:this.name}))}class DataSeriesAdditions{static compose(t){var e;pushUnique(composed,"Core.DataSeries")&&(e=t.prototype,addEvent(t,"init",function(){this.datas=new DataSeriesAdditions(this)}),wrap(e,"generatePoints",wrapSeriesGeneratePoints),wrap(e,"setData",wrapSeriesSetData))}constructor(t){this.unlisteners=[];const s={},a=t.parallelArrays;for(let t=0,e=a.length;t<e;++t)s[a[t]]=[];this.series=t,this.table=new DataTable}processTable(t,e){const s=this.series;if("point"===s.options.legendType&&(s.processData(),s.generatePoints()),t){const a=s.chart;s.isDirty=a.isDirtyBox=!0,s.isDirtyData=!0,a.redraw(e)}}setTable(a,t=!0,e){const s=this.series,n=s,i=s.points,o=s.parallelArrays,r=a.getRowCount();let l;if(i){const p=s.xAxis;s.colorCounter=0,s.data=[],delete n.points,delete n.processedXData,delete n.processedYData,delete n.xIncrement;for(let t=0,e=o.length;t<e;++t)l=o[t],n[l+"Data"]=[];for(let t=0,e=i.length;t<e;++t)i[t]&&i[t].destroy&&i[t].destroy();p&&(p.minRange=p.userMinRange)}let h,c=!1,f=!1;for(let t=0,e=o.length;t<e;++t){if(l=o[t],!(h=a.getColumn(l,!0))){if("x"===l){f=!0;continue}c=!0;break}n[l+"Data"]=h}if(c){const d=a.getColumnNames(),u=[];u.length=r;let s=0;d.length===o.length-1&&(s=1,f=!0);for(let t=s,e=o.length;t<e;++t)h=a.getColumn(d[t],!0),l=o[t],n[l+"Data"]=h||u.slice()}if((this.indexAsX=f)&&-1!==o.indexOf("x")){h=[];for(let t=0;t<r;++t)h.push(s.autoIncrement());n.xData=h}this.syncOff(),this.table=a,t&&this.syncOn(),this.processTable(t,i&&e)}syncOff(){const s=this.unlisteners;for(let t=0,e=s.length;t<e;++t)s[t]();s.length=0}syncOn(){if(!this.unlisteners.length){const a=this.series,t=this.table,n=a,e=s=>{if("afterDeleteColumns"===s.type)this.setTable(t,!0);else{if("afterDeleteRows"===s.type){if(0<s.rowIndex&&s.rowIndex+s.rowCount<a.points.length)return void this.setTable(t,!0);for(let t=s.rowIndex,e=t+s.rowCount;t<e;++t)a.removePoint(t,!1)}if(this.indexAsX)if("afterSetCell"===s.type)n.xData[s.rowIndex]=s.rowIndex;else if("afterSetRows"===s.type)for(let t=s.rowIndex,e=t+s.rowCount;t<e;++t)n.xData[t]=a.autoIncrement();this.processTable(!0)}};this.unlisteners.push(t.on("afterDeleteColumns",e),t.on("afterDeleteRows",e),t.on("afterSetCell",e),t.on("afterSetRows",e))}}}export default DataSeriesAdditions;