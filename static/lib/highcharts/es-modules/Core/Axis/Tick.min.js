"use strict";import F from"../Templating.js";import H from"../Globals.js";const deg2rad=H["deg2rad"];import U from"../Utilities.js";const{clamp,correctFloat,defined,destroyObjectProperties,extend,fireEvent,isNumber,merge,objectEach,pick}=U;class Tick{constructor(t,e,i,a,s){this.isNew=!0,this.isNewLabel=!0,this.axis=t,this.pos=e,this.type=i||"",this.parameters=s||{},this.tickmarkOffset=this.parameters.tickmarkOffset,this.options=this.parameters.options,fireEvent(this,"init"),i||a||this.addLabel()}addLabel(){const t=this,e=t.axis,i=e.options,a=e.chart,s=e.categories,r=e.logarithmic,o=e.names,l=t.pos,d=pick(t.options&&t.options.labels,i.labels),n=e.tickPositions,h=l===n[0],c=l===n[n.length-1],b=(!d.step||1===d.step)&&1===e.tickInterval,m=n.info;let p=t.label,f,L,g,k=this.parameters.category||(s?pick(s[l],o[l],l):l);r&&isNumber(k)&&(k=correctFloat(r.lin2log(k))),e.dateTime&&(m?(L=a.time.resolveDTLFormat(i.dateTimeLabelFormats[!i.grid&&m.higherRanks[l]||m.unitName]),f=L.main):isNumber(k)&&(f=e.dateTime.getXDateFormat(k,i.dateTimeLabelFormats||{}))),t.isFirst=h,t.isLast=c;const x={axis:e,chart:a,dateTimeLabelFormat:f,isFirst:h,isLast:c,pos:l,tick:t,tickPositionInfo:m,value:k},y=(fireEvent(this,"labelFormat",x),t=>d.formatter?d.formatter.call(t,t):d.format?(t.text=e.defaultLabelFormatter.call(t),F.format(d.format,t,a)):e.defaultLabelFormatter.call(t));var v=y.call(x,x);const u=L&&L.list;u?t.shortenLabel=function(){for(g=0;g<u.length;g++)if(extend(x,{dateTimeLabelFormat:u[g]}),p.attr({text:y.call(x,x)}),p.getBBox().width<e.getSlotWidth(t)-2*(d.padding||0))return;p.attr({text:""})}:t.shortenLabel=void 0,b&&e._addedPlotLB&&t.moveLabel(v,d),defined(p)||t.movedLabel?p&&p.textStr!==v&&!b&&(!p.textWidth||d.style.width||p.styles.width||p.css({width:null}),p.attr({text:v}),p.textPxLength=p.getBBox().width):(t.label=p=t.createLabel(v,d),t.rotation=0)}createLabel(t,e,i){const a=this.axis,s=a.chart,r=defined(t)&&e.enabled?s.renderer.text(t,i?.x,i?.y,e.useHTML).add(a.labelGroup):void 0;return r&&(s.styledMode||r.css(merge(e.style)),r.textPxLength=r.getBBox().width),r}destroy(){destroyObjectProperties(this,this.axis)}getPosition(t,e,i,a){const s=this.axis,r=s.chart,o=a&&r.oldChartHeight||r.chartHeight,l={x:t?correctFloat(s.translate(e+i,void 0,void 0,a)+s.transB):s.left+s.offset+(s.opposite?(a&&r.oldChartWidth||r.chartWidth)-s.right-s.left:0),y:t?o-s.bottom+s.offset-(s.opposite?s.height:0):correctFloat(o-s.translate(e+i,void 0,void 0,a)-s.transB)};return l.y=clamp(l.y,-1e9,1e9),fireEvent(this,"afterGetPosition",{pos:l}),l}getLabelPosition(t,e,i,a,s,r,o,l){const d=this.axis,n=d.transA,h=(d.isLinked&&d.linkedParent?d.linkedParent:d).reversed,c=d.staggerLines,b=d.tickRotCorr||{x:0,y:0},m=a||d.reserveSpaceDefault?0:-d.labelOffset*("center"===d.labelAlign?.5:1),p=s.distance,f={};let L,g;return L=0===d.side?i.rotation?-p:-i.getBBox().height:2===d.side?b.y+p:Math.cos(i.rotation*deg2rad)*(b.y-i.getBBox(!1,0).height/2),defined(s.y)&&(L=0===d.side&&d.horiz?s.y+L:s.y),t=t+pick(s.x,[0,1,0,-1][d.side]*p)+m+b.x-(r&&a?r*n*(h?-1:1):0),e=e+L-(r&&!a?r*n*(h?1:-1):0),c&&(g=o/(l||1)%c,e+=(g=d.opposite?c-g-1:g)*(d.labelOffset/c)),f.x=t,f.y=Math.round(e),fireEvent(this,"afterGetLabelPosition",{pos:f,tickmarkOffset:r,index:o}),f}getLabelSize(){return this.label?this.label.getBBox()[this.axis.horiz?"height":"width"]:0}getMarkPath(t,e,i,a,s=!1,r){return r.crispLine([["M",t,e],["L",t+(s?0:-i),e+(s?i:0)]],a)}handleOverflow(t){const e=this.axis,i=e.options.labels,a=t.x,s=e.chart.chartWidth,r=e.chart.spacing,o=pick(e.labelLeft,Math.min(e.pos,r[3])),l=pick(e.labelRight,Math.max(e.isRadial?0:e.pos+e.len,s-r[1])),d=this.label,n=this.rotation,h={left:0,center:.5,right:1}[e.labelAlign||d.attr("align")],c=d.getBBox().width,b=e.getSlotWidth(this),m=h,p={};let f=b,L=1,g;n||"justify"!==i.overflow?n<0&&a-h*c<o?g=Math.round(a/Math.cos(n*deg2rad)-o):0<n&&l<a+h*c&&(g=Math.round((s-a)/Math.cos(n*deg2rad))):(a-h*c<o?f=t.x+f*(1-h)-o:l<a+(1-h)*c&&(f=l-t.x+f*h,L=-1),(f=Math.min(b,f))<b&&"center"===e.labelAlign&&(t.x+=L*(b-f-m*(b-Math.min(c,f)))),(c>f||e.autoRotation&&(d.styles||{}).width)&&(g=f)),g&&(this.shortenLabel?this.shortenLabel():(p.width=Math.floor(g)+"px",(i.style||{}).textOverflow||(p.textOverflow="ellipsis"),d.css(p)))}moveLabel(e,t){const i=this,a=i.label,s=i.axis;let r=!1,o;a&&a.textStr===e?(i.movedLabel=a,r=!0,delete i.label):objectEach(s.ticks,function(t){r||t.isNew||t===i||!t.label||t.label.textStr!==e||(i.movedLabel=t.label,r=!0,t.labelPos=i.movedLabel.xy,delete t.label)}),r||!i.labelPos&&!a||(o=i.labelPos||a.xy,i.movedLabel=i.createLabel(e,t,o),i.movedLabel&&i.movedLabel.attr({opacity:0}))}render(t,e,i){var a=this,s=a.axis,r=s.horiz,o=a.pos,l=pick(a.tickmarkOffset,s.tickmarkOffset),o=a.getPosition(r,o,l,e),l=o.x,d=o.y,n=s.pos,h=n+s.len,r=r?l:d,l=(!s.chart.polar&&a.isNew&&(correctFloat(r)<n||h<r)&&(i=0),pick(i,a.label&&a.label.newOpacity,1));i=pick(i,1),this.isActive=!0,this.renderGridLine(e,i),this.renderMark(o,i),this.renderLabel(o,e,l,t),a.isNew=!1,fireEvent(this,"afterRender")}renderGridLine(t,e){const i=this,a=i.axis,s=a.options,r={},o=i.pos,l=i.type,d=pick(i.tickmarkOffset,a.tickmarkOffset),n=a.chart.renderer;let h=i.gridLine,c,b=s.gridLineWidth,m=s.gridLineColor,p=s.gridLineDashStyle;"minor"===i.type&&(b=s.minorGridLineWidth,m=s.minorGridLineColor,p=s.minorGridLineDashStyle),h||(a.chart.styledMode||(r.stroke=m,r["stroke-width"]=b||0,r.dashstyle=p),l||(r.zIndex=1),t&&(e=0),i.gridLine=h=n.path().attr(r).addClass("highcharts-"+(l?l+"-":"")+"grid-line").add(a.gridGroup)),h&&(c=a.getPlotLinePath({value:o+d,lineWidth:h.strokeWidth(),force:"pass",old:t,acrossPanes:!1}))&&h[t||i.isNew?"attr":"animate"]({d:c,opacity:e})}renderMark(t,e){const i=this,a=i.axis,s=a.options,r=a.chart.renderer,o=i.type,l=a.tickSize(o?o+"Tick":"tick"),d=t.x,n=t.y,h=pick(s["minor"!==o?"tickWidth":"minorTickWidth"],!o&&a.isXAxis?1:0),c=s["minor"!==o?"tickColor":"minorTickColor"];let b=i.mark;t=!b;l&&(a.opposite&&(l[0]=-l[0]),b||(i.mark=b=r.path().addClass("highcharts-"+(o?o+"-":"")+"tick").add(a.axisGroup),a.chart.styledMode||b.attr({stroke:c,"stroke-width":h})),b[t?"attr":"animate"]({d:i.getMarkPath(d,n,l[0],b.strokeWidth(),a.horiz,r),opacity:e}))}renderLabel(t,e,i,a){const s=this,r=s.axis,o=r.horiz,l=r.options,d=s.label,n=l.labels,h=n.step,c=pick(s.tickmarkOffset,r.tickmarkOffset),b=t.x,m=t.y;let p=!0;d&&isNumber(b)&&(d.xy=t=s.getLabelPosition(b,m,d,o,n,c,a,h),s.isFirst&&!s.isLast&&!l.showFirstLabel||s.isLast&&!s.isFirst&&!l.showLastLabel?p=!1:!o||n.step||n.rotation||e||0===i||s.handleOverflow(t),(p=h&&a%h?!1:p)&&isNumber(t.y)?(t.opacity=i,d[s.isNewLabel?"attr":"animate"](t).show(!0),s.isNewLabel=!1):(d.hide(),s.isNewLabel=!0))}replaceMovedLabel(){const t=this,e=t.label,i=t.axis;e&&!t.isNew&&(e.animate({opacity:0},void 0,e.destroy),delete t.label),i.isDirty=!0,t.label=t.movedLabel,delete t.movedLabel}}export default Tick;