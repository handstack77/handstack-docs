"use strict";import A from"../../Animation/AnimationUtilities.js";const getDeferredAnimation=A["getDeferredAnimation"];import Axis from"../Axis.js";import SeriesRegistry from"../../Series/SeriesRegistry.js";const{prototype:seriesProto}=SeriesRegistry["series"];import StackItem from"./StackItem.js";import U from"../../Utilities.js";const{addEvent,correctFloat,defined,destroyObjectProperties,fireEvent,isArray,isNumber,objectEach,pick}=U;function chartGetStacks(){const t=this,e=t.inverted;t.axes.forEach(t=>{t.stacking&&t.stacking.stacks&&t.hasVisibleSeries&&(t.stacking.oldStacks=t.stacking.stacks)}),t.series.forEach(t=>{const s=t.xAxis&&t.xAxis.options||{};t.options.stacking&&t.reserveSpace()&&(t.stackKey=[t.type,pick(t.options.stack,""),e?s.top:s.left,e?s.height:s.width].join(","))})}function onAxisDestroy(){const t=this.stacking;if(t){const e=t.stacks;objectEach(e,(t,s)=>{destroyObjectProperties(t),delete e[s]}),t.stackTotalGroup?.destroy()}}function onAxisInit(){this.stacking||(this.stacking=new AxisAdditions(this))}function seriesGetStackIndicator(t,s,e,i){return!defined(t)||t.x!==s||i&&t.stackKey!==i?t={x:s,index:0,key:i,stackKey:i}:t.index++,t.key=[e,s,t.index].join(","),t}function seriesModifyStacks(){const a=this,t=a.yAxis,s=a.stackKey||"",c=t.stacking.stacks,n=a.processedXData,e=a.options.stacking,r=a[e+"Stacker"];let k;r&&[s,"-"+s].forEach(t=>{let s=n.length,e,i,o;for(;s--;)e=n[s],k=a.getStackIndicator(k,e,a.index,t),(o=(i=c[t]?.[e])?.points[k.key||""])&&r.call(a,o,i,s)})}function seriesPercentStacker(t,s,e){s=s.total?100/s.total:0;t[0]=correctFloat(t[0]*s),t[1]=correctFloat(t[1]*s),this.stackedYData[e]=t[1]}function seriesSetGroupedPoints(t){(this.is("column")||this.is("columnrange"))&&(this.options.centerInCategory&&!this.options.stacking&&1<this.chart.series.length?seriesProto.setStackedPoints.call(this,t,"group"):t.stacking.resetStacks())}function seriesSetStackedPoints(d,t){var l=t||this.options.stacking;if(l&&this.reserveSpace()&&({group:"xAxis"}[l]||"yAxis")===d.coll){const h=this,p=h.processedXData,u=h.processedYData,S=[],g=u.length,f=h.options,x=f.threshold||0,m=f.startFromThreshold?x:0,y=f.stack,A=t?h.type+","+l:h.stackKey||"",b="-"+A,v=h.negStacks,P=d.stacking,j=P.stacks,E=P.oldStacks;let s,e,i,o,a,c,n,r,k;for(P.stacksTouched+=1,n=0;n<g;n++){r=p[n],k=u[n],c=(s=h.getStackIndicator(s,r,h.index)).key||"",a=(e=v&&k<(m?0:x))?b:A,j[a]||(j[a]={}),j[a][r]||(E[a]?.[r]?(j[a][r]=E[a][r],j[a][r].total=null):j[a][r]=new StackItem(d,d.options.stackLabels,!!e,r,y)),i=j[a][r],null!==k?(i.points[c]=i.points[h.index]=[pick(i.cumulative,m)],defined(i.cumulative)||(i.base=c),i.touched=P.stacksTouched,0<s.index&&!1===h.singleStacks&&(i.points[c][0]=i.points[h.index+","+r+",0"][0])):(delete i.points[c],delete i.points[h.index]);let t=i.total||0;"percent"===l?(o=e?A:b,t=v&&j[o]?.[r]?(o=j[o][r]).total=Math.max(o.total||0,t)+Math.abs(k)||0:correctFloat(t+(Math.abs(k)||0))):"group"===l?null!==(k=isArray(k)?k[0]:k)&&t++:t=correctFloat(t+(k||0)),i.cumulative="group"===l?(t||1)-1:correctFloat(pick(i.cumulative,m)+(k||0)),i.total=t,null!==k&&(i.points[c].push(i.cumulative),S[n]=i.cumulative,i.hasValidPoints=!0)}"percent"===l&&(P.usePercentage=!0),"group"!==l&&(this.stackedYData=S),P.oldStacks={}}}class AxisAdditions{constructor(t){this.oldStacks={},this.stacks={},this.stacksTouched=0,this.axis=t}buildStacks(){const t=this.axis,s=t.series,e="xAxis"===t.coll,i=t.options.reversedStacks,o=s.length;let a,c;for(this.resetStacks(),this.usePercentage=!1,c=o;c--;)a=s[i?c:o-c-1],e&&a.setGroupedPoints(t),a.setStackedPoints(t);if(!e)for(c=0;c<o;c++)s[c].modifyStacks();fireEvent(t,"afterBuildStacks")}cleanStacks(){this.oldStacks&&(this.stacks=this.oldStacks,objectEach(this.stacks,t=>{objectEach(t,t=>{t.cumulative=t.total})}))}resetStacks(){objectEach(this.stacks,e=>{objectEach(e,(t,s)=>{isNumber(t.touched)&&t.touched<this.stacksTouched?(t.destroy(),delete e[s]):(t.total=null,t.cumulative=null)})})}renderStackTotals(){const t=this.axis,s=t.chart,e=s.renderer,i=this.stacks,o=t.options.stackLabels?.animation,a=getDeferredAnimation(s,o||!1),c=this.stackTotalGroup=this.stackTotalGroup||e.g("stack-labels").attr({zIndex:6,opacity:0}).add();c.translate(s.plotLeft,s.plotTop),objectEach(i,t=>{objectEach(t,t=>{t.render(c)})}),c.animate({opacity:1},a)}}var StackingAxis;(StackingAxis||(StackingAxis={})).compose=function(t,s,e){const i=s.prototype,o=e.prototype;i.getStacks||(addEvent(t,"init",onAxisInit),addEvent(t,"destroy",onAxisDestroy),i.getStacks=chartGetStacks,o.getStackIndicator=seriesGetStackIndicator,o.modifyStacks=seriesModifyStacks,o.percentStacker=seriesPercentStacker,o.setGroupedPoints=seriesSetGroupedPoints,o.setStackedPoints=seriesSetStackedPoints)};export default StackingAxis;