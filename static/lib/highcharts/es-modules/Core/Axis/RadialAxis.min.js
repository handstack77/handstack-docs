"use strict";import RadialAxisDefaults from"./RadialAxisDefaults.js";import D from"../Defaults.js";const defaultOptions=D["defaultOptions"];import H from"../Globals.js";const{composed,noop}=H;import U from"../Utilities.js";const{addEvent,correctFloat,defined,extend,fireEvent,isObject,merge,pick,pushUnique,relativeLength,wrap}=U;var RadialAxis;!function(r){function i(){this.autoConnect=this.isCircular&&void 0===pick(this.userMax,this.options.max)&&correctFloat(this.endAngleRad-this.startAngleRad)===correctFloat(2*Math.PI),!this.isCircular&&this.chart.inverted&&this.max++,this.autoConnect&&(this.max+=(this.categories?1:this.pointRange)||this.closestPointRange||0)}function s(){return()=>{if(this.isRadial&&this.tickPositions&&this.options.labels&&!0!==this.options.labels.allowOverlap)return this.tickPositions.map(t=>this.ticks[t]&&this.ticks[t].label).filter(t=>Boolean(t))}}function c(){return noop}function e(t,i,s){var e=this.pane.center;let a=t.value,n,o,r;return this.isCircular?(defined(a)?t.point&&(t.point.shapeArgs||{}).start&&(a=this.chart.inverted?this.translate(t.point.rectPlotY,!0):t.point.x):(o=t.chartX||0,r=t.chartY||0,a=this.translate(Math.atan2(r-s,o-i)-this.startAngleRad,!0)),n=this.getPosition(a),o=n.x,r=n.y):(defined(a)||(o=t.chartX,r=t.chartY),defined(o)&&defined(r)&&(s=e[1]+this.chart.plotTop,a=this.translate(Math.min(Math.sqrt(Math.pow(o-i,2)+Math.pow(r-s,2)),e[2]/2)-e[3]/2,!0))),[a,o||0,r||0]}function a(t,i,s){var e=this.pane.center,a=this.chart,n=this.left||0,o=this.top||0;let r,h=pick(i,e[2]/2-this.offset),l;return(s=void 0===s?this.horiz?0:this.center&&-this.center[3]/2:s)&&(h+=s),this.isCircular||void 0!==i?((l=this.chart.renderer.symbols.arc(n+e[0],o+e[1],h,h,{start:this.startAngleRad,end:this.endAngleRad,open:!0,innerR:0})).xBounds=[n+e[0]],l.yBounds=[o+e[1]-h]):(r=this.postTranslate(this.angleRad,h),l=[["M",this.center[0]+a.plotLeft,this.center[1]+a.plotTop],["L",r.x,r.y]]),l}function n(){const t=this.constructor.prototype;t.getOffset.call(this),this.chart.axisOffset[this.side]=0}function o(t,i,s){const e=this.chart,a=i=>{if("string"!=typeof i)return i;{let t=parseInt(i,10);return t=d.test(i)?t*r/100:t}},n=this.center,o=this.startAngleRad,r=n[2]/2,h=Math.min(this.offset,0),l=this.left||0,c=this.top||0,d=/%$/,p=this.isCircular;let u,f,g,x,A,P,R=pick(a(s.outerRadius),r),m=a(s.innerRadius),v=pick(a(s.thickness),10);return"polygon"===this.options.gridLineInterpolation?P=this.getPlotLinePath({value:t}).concat(this.getPlotLinePath({value:i,reverse:!0})):(t=Math.max(t,this.min),i=Math.min(i,this.max),t=this.translate(t),i=this.translate(i),p||(R=t||0,m=i||0),"circle"!==s.shape&&p?(u=o+(t||0),f=o+(i||0)):(u=-Math.PI/2,f=1.5*Math.PI,A=!0),R-=h,v-=h,P=e.renderer.symbols.arc(l+n[0],c+n[1],R,R,{start:Math.min(u,f),end:Math.max(u,f),innerR:pick(m,R-v),open:A,borderRadius:s.borderRadius}),p&&(g=(f+u)/2,x=l+n[0]+n[2]/2*Math.cos(g),P.xBounds=g>-Math.PI/2&&g<Math.PI/2?[x,e.plotWidth]:[0,x],P.yBounds=[c+n[1]+n[2]/2*Math.sin(g)],P.yBounds[0]+=g>-Math.PI&&g<0||g>Math.PI?-10:10)),P}function h(t){const i=this.pane.center,s=this.chart,e=s.inverted,a=t.reverse,n=this.pane.options.background?this.pane.options.background[0]||this.pane.options.background:{},o=n.innerRadius||"0%",r=n.outerRadius||"100%",h=i[0]+s.plotLeft,l=i[1]+s.plotTop,c=this.height,d=t.isCrosshair,p=i[3]/2;let u=t.value,f,g,x,A,P,R,m,v,M;var y=this.getPosition(u);let b=y.x,C=y.y;if(d&&(v=this.getCrosshairPosition(t,h,l),u=v[0],b=v[1],C=v[2]),this.isCircular)g=Math.sqrt(Math.pow(b-h,2)+Math.pow(C-l,2)),x="string"==typeof o?relativeLength(o,1):o/g,A="string"==typeof r?relativeLength(r,1):r/g,i&&p&&(f=p/g,x<f&&(x=f),A<f&&(A=f)),M=[["M",h+x*(b-h),l-x*(l-C)],["L",b-(1-A)*(b-h),C+(1-A)*(l-C)]];else if((u=this.translate(u))&&(u<0||u>c)&&(u=0),"circle"===this.options.gridLineInterpolation)M=this.getLinePath(0,u,p);else if(M=[],s[e?"yAxis":"xAxis"].forEach(t=>{t.pane===this.pane&&(P=t)}),P){m=P.tickPositions,P.autoConnect&&(m=m.concat([m[0]])),a&&(m=m.slice().reverse()),u&&(u+=p);for(let t=0;t<m.length;t++)R=P.getPosition(m[t],u),M.push(t?["L",R.x,R.y]:["M",R.x,R.y])}return M}function l(t,i){t=this.translate(t);return this.postTranslate(this.isCircular?t:this.angleRad,pick(this.isCircular?i:t<0?0:t,this.center[2]/2)-this.offset)}function d(){var t=this.center,i=this.chart,s=this.options.title;return{x:i.plotLeft+t[0]+(s.x||0),y:i.plotTop+t[1]-{high:.5,middle:.25,low:0}[s.align]*t[2]+(s.y||0)}}function p(t){t.beforeSetTickPositions=i,t.createLabelCollector=s,t.getCrosshairPosition=e,t.getLinePath=a,t.getOffset=n,t.getPlotBandPath=o,t.getPlotLinePath=h,t.getPosition=l,t.getTitlePosition=d,t.postTranslate=v,t.setAxisSize=y,t.setAxisTranslation=b,t.setOptions=C}function u(){var s=this.chart,e=this.options,a=s.angular&&this.isXAxis,n=this.pane,o=n&&n.options;if(!a&&n&&(s.angular||s.polar)){a=2*Math.PI,n=(pick(o.startAngle,0)-90)*Math.PI/180,s=(pick(o.endAngle,pick(o.startAngle,0)+360)-90)*Math.PI/180;this.angleRad=(e.angle||0)*Math.PI/180,this.startAngleRad=n,this.endAngleRad=s,this.offset=e.offset||0;let t=(n%a+a)%a,i=(s%a+a)%a;t>Math.PI&&(t-=a),i>Math.PI&&(i-=a),this.normalizedStartAngleRad=t,this.normalizedEndAngleRad=i}}function f(t){this.isRadial&&(t.align=void 0,t.preventDefault())}function g(){var t;this.chart&&this.chart.labelCollectors&&(0<=(t=this.labelCollector?this.chart.labelCollectors.indexOf(this.labelCollector):-1)&&this.chart.labelCollectors.splice(t,1))}function x(t){const i=this.chart,s=i.angular,e=i.polar,a=this.isXAxis,n=this.coll,o=s&&a,r=t.userOptions.pane||0,h=this.pane=i.pane&&i.pane[r];let l;"colorAxis"===n?this.isRadial=!1:(s?(o?((t=this).isHidden=!0,t.createLabelCollector=c,t.getOffset=noop,t.redraw=M,t.render=M,t.setScale=noop,t.setCategories=noop,t.setTitle=noop):p(this),l=!a):e&&(p(this),l=this.horiz),s||e?(this.isRadial=!0,this.labelCollector||(this.labelCollector=this.createLabelCollector()),this.labelCollector&&i.labelCollectors.push(this.labelCollector)):this.isRadial=!1,h&&l&&(h.axis=this),this.isCircular=l)}function A(){this.isRadial&&this.beforeSetTickPositions()}function P(l){const c=this.label;if(c){const d=this.axis,p=c.getBBox(),u=d.options.labels,f=(d.translate(this.pos)+d.startAngleRad+Math.PI/2)/Math.PI*180%360,g=Math.round(f),x=defined(u.y)?0:.3*-p.height;let t=u.y,i,s=20,e=u.align,a="end",n=g<0?g+360:g,o=n,r=0,h=0;d.isRadial&&(i=d.getPosition(this.pos,d.center[2]/2+relativeLength(pick(u.distance,-25),d.center[2]/2,-d.center[2]/2)),"auto"===u.rotation?c.attr({rotation:f}):defined(t)||(t=d.chart.renderer.fontMetrics(c).b-p.height/2),defined(e)||(e=d.isCircular?f>(s=p.width>d.len*d.tickInterval/(d.max-d.min)?0:s)&&f<180-s?"left":f>180+s&&f<360-s?"right":"center":"center",c.attr({align:e})),"auto"===e&&2===d.tickPositions.length&&d.isCircular&&(90<n&&n<180?n=180-n:270<n&&n<=360&&(n=540-n),180<o&&o<=360&&(o=360-o),d.pane.options.startAngle!==g&&d.pane.options.startAngle!==g+360&&d.pane.options.startAngle!==g-360||(a="start"),e=-90<=g&&g<=90||-360<=g&&g<=-270||270<=g&&g<=360?"start"===a?"right":"left":"start"===a?"left":"right",70<o&&o<110&&(e="center"),n<15||180<=n&&n<195?r=.3*p.height:15<=n&&n<=35?r="start"===a?0:.75*p.height:195<=n&&n<=215?r="start"===a?.75*p.height:0:35<n&&n<=90?r="start"===a?.25*-p.height:p.height:215<n&&n<=270&&(r="start"===a?p.height:.25*-p.height),o<15?h="start"===a?.15*-p.height:.15*p.height:165<o&&o<=180&&(h="start"===a?.15*p.height:.15*-p.height),c.attr({align:e}),c.translate(h,r+x)),l.pos.x=i.x+(u.x||0),l.pos.y=i.y+(t||0))}}function R(t){this.axis.getPosition&&extend(t.pos,this.axis.getPosition(this.pos))}function m({options:t}){t.xAxis&&merge(!0,r.radialDefaultOptions.circular,t.xAxis),t.yAxis&&merge(!0,r.radialDefaultOptions.radialGauge,t.yAxis)}function v(t,i){var s=this.chart,e=this.center;return t=this.startAngleRad+t,{x:s.plotLeft+e[0]+Math.cos(t)*i,y:s.plotTop+e[1]+Math.sin(t)*i}}function M(){this.isDirty=!1}function y(){const t=this.constructor.prototype;let i,s;t.setAxisSize.call(this),this.isRadial&&(this.pane.updateCenter(this),i=this.center=this.pane.center.slice(),this.isCircular?this.sector=this.endAngleRad-this.startAngleRad:(s=this.postTranslate(this.angleRad,i[3]/2),i[0]=s.x-this.chart.plotLeft,i[1]=s.y-this.chart.plotTop),this.len=this.width=this.height=(i[2]-i[3])*pick(this.sector,1)/2)}function b(){const t=this.constructor.prototype;t.setAxisTranslation.call(this),this.center&&(this.isCircular?this.transA=(this.endAngleRad-this.startAngleRad)/(this.max-this.min||1):this.transA=(this.center[2]-this.center[3])/2/(this.max-this.min||1),this.isXAxis?this.minPixelPadding=this.transA*this.minPointOffset:this.minPixelPadding=0)}function C(t){var i=this["coll"],{angular:s,inverted:e,polar:a}=this.chart;let n={};s?this.isXAxis||(n=merge(defaultOptions.yAxis,r.radialDefaultOptions.radialGauge)):a&&(n=this.horiz?merge(defaultOptions.xAxis,r.radialDefaultOptions.circular):merge("xAxis"===i?defaultOptions.xAxis:defaultOptions.yAxis,r.radialDefaultOptions.radial)),e&&"yAxis"===i&&(n.stackLabels=isObject(defaultOptions.yAxis,!0)?defaultOptions.yAxis.stackLabels:{},n.reversedStacks=!0);const o=this.options=merge(n,t);o.plotBands||(o.plotBands=[]),fireEvent(this,"afterSetOptions")}function k(t,i,s,e,a,n,o){const r=this.axis;let h,l;return l=r.isRadial?["M",i,s,"L",(h=r.getPosition(this.pos,r.center[2]/2+e)).x,h.y]:t.call(this,i,s,e,a,n,o)}r.radialDefaultOptions=merge(RadialAxisDefaults),r.compose=function(t,i){return pushUnique(composed,"Axis.Radial")&&(addEvent(t,"afterInit",u),addEvent(t,"autoLabelAlign",f),addEvent(t,"destroy",g),addEvent(t,"init",x),addEvent(t,"initialAxisTranslation",A),addEvent(i,"afterGetLabelPosition",P),addEvent(i,"afterGetPosition",R),addEvent(H,"setOptions",m),wrap(i.prototype,"getMarkPath",k)),t}}(RadialAxis=RadialAxis||{});export default RadialAxis;