"use strict";import H from"../Core/Globals.js";import U from"../Core/Utilities.js";const{defined,error,merge,objectEach}=U,deg2rad=H.deg2rad,max=Math.max,min=Math.min;class Connection{constructor(t,r,e){this.init(t,r,e)}init(t,r,e){this.fromPoint=t,this.toPoint=r,this.options=e,this.chart=t.series.chart,this.pathfinder=this.chart.pathfinder}renderPath(t,r){const e=this.chart,i=e.styledMode,a=this.pathfinder,s={};let o=this.graphics&&this.graphics.path;a.group||(a.group=e.renderer.g().addClass("highcharts-pathfinder-group").attr({zIndex:-1}).add(e.seriesGroup)),a.group.translate(e.plotLeft,e.plotTop),o&&o.renderer||(o=e.renderer.path().add(a.group),i||o.attr({opacity:0})),o.attr(r),s.d=t,i||(s.opacity=1),o.animate(s),this.graphics=this.graphics||{},this.graphics.path=o}addMarker(t,r,e){const i=this,a=i.fromPoint.series.chart,s=a.pathfinder,o=a.renderer,n="start"===t?i.fromPoint:i.toPoint,h=n.getPathfinderAnchorPoint(r);let c,d,l,g,p,m,f,M;r.enabled&&((M="start"===t?e[1]:e[e.length-2])&&"M"===M[0]||"L"===M[0])&&(f={x:M[1],y:M[2]},d=n.getRadiansToVector(f,h),c=n.getMarkerVector(d,r.radius,h),l=-d/deg2rad,r.width&&r.height?(p=r.width,m=r.height):p=m=2*r.radius,i.graphics=i.graphics||{},g={x:c.x-p/2,y:c.y-m/2,width:p,height:m,rotation:l,rotationOriginX:c.x,rotationOriginY:c.y},i.graphics[t]?i.graphics[t].animate(g):(i.graphics[t]=o.symbol(r.symbol).addClass("highcharts-point-connecting-path-"+t+"-marker highcharts-color-"+this.fromPoint.colorIndex).attr(g).add(s.group),o.styledMode||i.graphics[t].attr({fill:r.color||i.fromPoint.color,stroke:r.lineColor,"stroke-width":r.lineWidth,opacity:0}).animate({opacity:1},n.series.options.animation)))}getPath(t){const r=this.pathfinder,e=this.chart,i=r.algorithms[t.type];let a=r.chartObstacles;return"function"!=typeof i?(error('"'+t.type+'" is not a Pathfinder algorithm.'),{path:[],obstacles:[]}):(i.requiresObstacles&&!a&&(a=r.chartObstacles=r.getChartObstacles(t),e.options.connectors.algorithmMargin=t.algorithmMargin,r.chartObstacleMetrics=r.getObstacleMetrics(a)),i(this.fromPoint.getPathfinderAnchorPoint(t.startMarker),this.toPoint.getPathfinderAnchorPoint(t.endMarker),merge({chartObstacles:a,lineObstacles:r.lineObstacles||[],obstacleMetrics:r.chartObstacleMetrics,hardBounds:{xMin:0,xMax:e.plotWidth,yMin:0,yMax:e.plotHeight},obstacleOptions:{margin:t.algorithmMargin},startDirectionX:r.getAlgorithmStartDirection(t.startMarker)},t)))}render(){const t=this,r=t.fromPoint,e=r.series,i=e.chart,a=i.pathfinder,s={};let o=merge(i.options.connectors,e.options.connectors,r.options.connectors,t.options);i.styledMode||(s.stroke=o.lineColor||r.color,s["stroke-width"]=o.lineWidth,o.dashStyle&&(s.dashstyle=o.dashStyle)),s.class="highcharts-point-connecting-path highcharts-color-"+r.colorIndex,o=merge(s,o),defined(o.marker.radius)||(o.marker.radius=min(max(Math.ceil((o.algorithmMargin||8)/2)-1,1),5));var n=t.getPath(o),h=n.path;n.obstacles&&(a.lineObstacles=a.lineObstacles||[],a.lineObstacles=a.lineObstacles.concat(n.obstacles)),t.renderPath(h,s),t.addMarker("start",merge(o.marker,o.startMarker),h),t.addMarker("end",merge(o.marker,o.endMarker),h)}destroy(){this.graphics&&(objectEach(this.graphics,function(t){t.destroy()}),delete this.graphics)}}export default Connection;