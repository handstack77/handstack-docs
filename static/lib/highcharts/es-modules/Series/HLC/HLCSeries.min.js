"use strict";import HLCPoint from"./HLCPoint.js";import HLCSeriesDefaults from"./HLCSeriesDefaults.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const ColumnSeries=SeriesRegistry.seriesTypes["column"];import U from"../../Core/Utilities.js";const{crisp,extend,merge}=U;class HLCSeries extends ColumnSeries{extendStem(t,e,i){const s=t[0],o=t[1];"number"==typeof s[2]&&(s[2]=Math.max(i+e,s[2])),"number"==typeof o[2]&&(o[2]=Math.min(i-e,o[2]))}getPointPath(t,e){const i=e.strokeWidth(),s=t.series,o=crisp(t.plotX||0,i),r=Math.round(t.shapeArgs.width/2),n=[["M",o,Math.round(t.yBottom)],["L",o,Math.round(t.plotHigh)]];return null!==t.close&&(e=crisp(t.plotClose,i),n.push(["M",o,e],["L",o+r,e]),s.extendStem(n,i/2,e)),n}drawSinglePoint(t){const e=t.series,i=e.chart;let s,o=t.graphic;void 0!==t.plotY&&(o||(t.graphic=o=i.renderer.path().add(e.group)),i.styledMode||o.attr(e.pointAttribs(t,t.selected&&"select")),s=e.getPointPath(t,o),o[o?"animate":"attr"]({d:s}).addClass(t.getClassName(),!0))}drawPoints(){this.points.forEach(this.drawSinglePoint)}init(){super.init.apply(this,arguments),this.options.stacking=void 0}pointAttribs(t,e){const i=super.pointAttribs.call(this,t,e);return delete i.fill,i}toYData(t){return[t.high,t.low,t.close]}translate(){const o=this,r=o.yAxis,t=this.pointArrayMap&&this.pointArrayMap.slice()||[],n=t.map(t=>"plot"+(t.charAt(0).toUpperCase()+t.slice(1)));n.push("yBottom"),t.push("low"),super.translate.apply(o),o.points.forEach(function(s){t.forEach(function(t,e){let i=s[t];null!==i&&(o.dataModify&&(i=o.dataModify.modifyValue(i)),s[n[e]]=r.toPixels(i,!0))}),s.tooltipPos[1]=s.plotHigh+r.pos-o.chart.plotTop})}}HLCSeries.defaultOptions=merge(ColumnSeries.defaultOptions,HLCSeriesDefaults),extend(HLCSeries.prototype,{pointClass:HLCPoint,animate:null,directTouch:!1,pointArrayMap:["high","low","close"],pointAttrToOptions:{stroke:"color","stroke-width":"lineWidth"},pointValKey:"close"}),SeriesRegistry.registerSeriesType("hlc",HLCSeries);export default HLCSeries;