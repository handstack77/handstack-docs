"use strict";import H from"../../Core/Globals.js";const noop=H["noop"];import MapPointPoint from"./MapPointPoint.js";import MapPointSeriesDefaults from"./MapPointSeriesDefaults.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{map:MapSeries,scatter:ScatterSeries}=SeriesRegistry.seriesTypes;import SVGRenderer from"../../Core/Renderer/SVG/SVGRenderer.js";import U from"../../Core/Utilities.js";const{extend,fireEvent,isNumber,merge}=U;import"../../Core/Defaults.js";import"../Scatter/ScatterSeries.js";class MapPointSeries extends ScatterSeries{constructor(){super(...arguments),this.clearBounds=MapSeries.prototype.clearBounds}drawDataLabels(){super.drawDataLabels(),this.dataLabelsGroup&&this.dataLabelsGroup.clip(this.chart.clipRect)}projectPoint(t){const r=this.chart.mapView;if(r){var{geometry:t,lon:s,lat:o}=t;let e=t&&"Point"===t.type&&t.coordinates;if(e=isNumber(s)&&isNumber(o)?[s,o]:e)return r.lonLatToProjectedUnits({lon:e[0],lat:e[1]})}}translate(){const a=this.chart.mapView;if(this.processedXData||this.processData(),this.generatePoints(),this.getProjectedBounds&&this.isDirtyData&&(delete this.bounds,this.getProjectedBounds()),a){const n=a.getSVGTransform(),p=a.projection["hasCoordinates"];this.points.forEach(e=>{let{x:t=void 0,y:r=void 0}=e;var s=isNumber(e.insetIndex)&&a.insets[e.insetIndex].getSVGTransform()||n,o=this.projectPoint(e.options)||e.properties&&this.projectPoint(e.properties);let i;o?(t=o.x,r=o.y):e.bounds&&(t=e.bounds.midX,r=e.bounds.midY,s&&isNumber(t)&&isNumber(r)&&(e.plotX=t*s.scaleX+s.translateX,e.plotY=r*s.scaleY+s.translateY,i=!0)),isNumber(t)&&isNumber(r)?i||(o=a.projectedUnitsToPixels({x:t,y:r}),e.plotX=o.x,e.plotY=p?o.y:this.chart.plotHeight-o.y):e.y=e.plotX=e.plotY=void 0,e.isInside=this.isPointInside(e),e.zone=this.zones.length?e.getZone():void 0})}fireEvent(this,"afterTranslate")}}MapPointSeries.defaultOptions=merge(ScatterSeries.defaultOptions,MapPointSeriesDefaults);const mapmarker=(e,t,r,s,o)=>{var i=o&&"legend"===o.context;let a,n;i?(a=e+r/2,n=t+s):o&&"number"==typeof o.anchorX&&"number"==typeof o.anchorY?(a=o.anchorX,n=o.anchorY):(a=e+r/2,n=t+s/2,t-=s);o=i?s/3:s/2;return[["M",a,n],["C",a,n,a-o,t+1.5*o,a-o,t+o],["A",o,o,1,1,1,a+o,t+o],["C",a+o,t+1.5*o,a,n,a,n],["Z"]]};SVGRenderer.prototype.symbols.mapmarker=mapmarker,extend(MapPointSeries.prototype,{type:"mappoint",axisTypes:["colorAxis"],forceDL:!0,isCartesian:!1,pointClass:MapPointPoint,searchPoint:noop,useMapGeometry:!0}),SeriesRegistry.registerSeriesType("mappoint",MapPointSeries);export default MapPointSeries;