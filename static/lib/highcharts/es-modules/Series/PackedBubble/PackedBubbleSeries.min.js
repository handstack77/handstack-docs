"use strict";import Color from"../../Core/Color/Color.js";const color=Color["parse"];import DragNodesComposition from"../DragNodesComposition.js";import GraphLayout from"../GraphLayoutComposition.js";import H from"../../Core/Globals.js";const noop=H["noop"];import PackedBubblePoint from"./PackedBubblePoint.js";import PackedBubbleSeriesDefaults from"./PackedBubbleSeriesDefaults.js";import PackedBubbleLayout from"./PackedBubbleLayout.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{series:{prototype:seriesProto},seriesTypes:{bubble:BubbleSeries}}=SeriesRegistry;import D from"../SimulationSeriesUtilities.js";const{initDataLabels,initDataLabelsDefer}=D;import U from"../../Core/Utilities.js";const{addEvent,clamp,defined,extend,fireEvent,isArray,isNumber,merge,pick}=U;import SVGElement from"../../Core/Renderer/SVG/SVGElement.js";import TextPath from"../../Extensions/TextPath.js";TextPath.compose(SVGElement);class PackedBubbleSeries extends BubbleSeries{constructor(){super(...arguments),this.parentNodeMass=0,this.deferDataLabels=!0}static compose(t,e,o){BubbleSeries.compose(t,e,o),DragNodesComposition.compose(e),PackedBubbleLayout.compose(e)}accumulateAllPoints(){const t=this.chart,e=[];var o;for(const a of t.series)if(a.is("packedbubble")&&a.reserveSpace()){o=a.yData||[];for(let t=0;t<o.length;t++)e.push([null,null,o[t],a.index,t,{id:t,marker:{radius:0}}])}return e}addLayout(){const t=this.options.layoutAlgorithm=this.options.layoutAlgorithm||{},e=t.type||"packedbubble",o=this.chart.options.chart;let a=this.chart.graphLayoutsStorage,s=this.chart.graphLayoutsLookup,i;a||(this.chart.graphLayoutsStorage=a={},this.chart.graphLayoutsLookup=s=[]),(i=a[e])||(t.enableSimulation=defined(o.forExport)?!o.forExport:t.enableSimulation,a[e]=i=new GraphLayout.layouts[e],i.init(t),s.splice(i.index,0,i)),this.layout=i,this.points.forEach(t=>{t.mass=2,t.degree=1,t.collisionNmb=1}),i.setArea(0,0,this.chart.plotWidth,this.chart.plotHeight),i.addElementsToCollection([this],i.series),i.addElementsToCollection(this.points,i.nodes)}addSeriesLayout(){const t=this.options.layoutAlgorithm=this.options.layoutAlgorithm||{},e=t.type||"packedbubble",o=this.chart.graphLayoutsStorage,a=this.chart.graphLayoutsLookup,s=merge(t,t.parentNodeOptions,{enableSimulation:this.layout.options.enableSimulation});let i=o[e+"-series"];i||(o[e+"-series"]=i=new GraphLayout.layouts[e],i.init(s),a.splice(i.index,0,i)),this.parentNodeLayout=i,this.createParentNodes()}calculateParentRadius(){var t=this.seriesBox();this.parentNodeRadius=clamp(Math.sqrt(2*this.parentNodeMass/Math.PI)+20,20,t?Math.max(Math.sqrt(Math.pow(t.width,2)+Math.pow(t.height,2))/2+20,20):Math.sqrt(2*this.parentNodeMass/Math.PI)+20),this.parentNode&&(this.parentNode.marker.radius=this.parentNode.radius=this.parentNodeRadius)}calculateZExtremes(){const t=this.chart,e=t.series;let o=this.options.zMin,a=this.options.zMax,s=1/0,i=-1/0;return o&&a||(e.forEach(t=>{t.yData.forEach(t=>{defined(t)&&(t>i&&(i=t),t<s&&(s=t))})}),o=pick(o,s),a=pick(a,i)),[o,a]}checkOverlap(t,e){var o=t[0]-e[0],a=t[1]-e[1],t=t[2]+e[2];return Math.sqrt(o*o+a*a)-Math.abs(t)<-.001}createParentNodes(){const t=this.pointClass,e=this.chart,o=this.parentNodeLayout,a=this.layout.options;let s,i=this.parentNode,r={radius:this.parentNodeRadius,lineColor:this.color,fillColor:color(this.color).brighten(.4).get()};a.parentNodeOptions&&(r=merge(a.parentNodeOptions.marker||{},r)),this.parentNodeMass=0,this.points.forEach(t=>{this.parentNodeMass+=Math.PI*Math.pow(t.marker.radius,2)}),this.calculateParentRadius(),o.nodes.forEach(t=>{t.seriesIndex===this.index&&(s=!0)}),o.setArea(0,0,e.plotWidth,e.plotHeight),s||(i=i||new t(this,{mass:this.parentNodeRadius/2,marker:r,dataLabels:{inside:!1},states:{normal:{marker:r},hover:{marker:r}},dataLabelOnNull:!0,degree:this.parentNodeRadius,isParentNode:!0,seriesIndex:this.index}),this.parentNode&&(i.plotX=this.parentNode.plotX,i.plotY=this.parentNode.plotY),this.parentNode=i,o.addElementsToCollection([this],o.series),o.addElementsToCollection([i],o.nodes))}deferLayout(){var t=this.options.layoutAlgorithm;this.visible&&(this.addLayout(),t.splitSeries&&this.addSeriesLayout())}destroy(){this.chart.graphLayoutsLookup&&this.chart.graphLayoutsLookup.forEach(t=>{t.removeElementFromCollection(this,t.series)},this),this.parentNode&&this.parentNodeLayout&&(this.parentNodeLayout.removeElementFromCollection(this.parentNode,this.parentNodeLayout.nodes),this.parentNode.dataLabel&&(this.parentNode.dataLabel=this.parentNode.dataLabel.destroy())),seriesProto.destroy.apply(this,arguments)}drawDataLabels(){this.deferDataLabels||(seriesProto.drawDataLabels.call(this,this.points),this.parentNode&&(this.parentNode.formatPrefix="parentNode",seriesProto.drawDataLabels.call(this,[this.parentNode])))}drawGraph(){if(this.layout&&this.layout.options.splitSeries){const e=this.chart,o=this.layout.options.parentNodeOptions.marker,a={fill:o.fillColor||color(this.color).brighten(.4).get(),opacity:o.fillOpacity,stroke:o.lineColor||this.color,"stroke-width":pick(o.lineWidth,this.options.lineWidth)};var t;this.parentNodesGroup=this.plotGroup("parentNodesGroup","parentNode",this.visible?"inherit":"hidden",.1,e.seriesGroup),this.group?.attr({zIndex:2}),this.calculateParentRadius(),this.parentNode&&defined(this.parentNode.plotX)&&defined(this.parentNode.plotY)&&defined(this.parentNodeRadius)&&(t=merge({x:this.parentNode.plotX-this.parentNodeRadius,y:this.parentNode.plotY-this.parentNodeRadius,width:2*this.parentNodeRadius,height:2*this.parentNodeRadius},a),this.parentNode.graphic||(this.graph=this.parentNode.graphic=e.renderer.symbol(a.symbol).add(this.parentNodesGroup)),this.parentNode.graphic.attr(t))}}drawTracker(){const e=this.parentNode;let t;super.drawTracker(),e&&(t=isArray(e.dataLabels)?e.dataLabels:e.dataLabel?[e.dataLabel]:[],e.graphic&&(e.graphic.element.point=e),t.forEach(t=>{(t.div||t.element).point=e}))}getPointRadius(){const t=this.chart,e=t.plotWidth,o=t.plotHeight,a=this.options,s=a.useSimulation,i=Math.min(e,o),r={},n=[],l=t.allDataPoints||[],h=l.length;let p,d,u,c;["minSize","maxSize"].forEach(t=>{var e=parseInt(a[t],10),o=/%$/.test(a[t]);r[t]=o?i*e/100:e*Math.sqrt(h)}),t.minRadius=p=r.minSize/Math.sqrt(h),t.maxRadius=d=r.maxSize/Math.sqrt(h);const m=s?this.calculateZExtremes():[p,d];l.forEach((t,e)=>{u=s?clamp(t[2],m[0],m[1]):t[2],0===(c=this.getRadius(m[0],m[1],p,d,u))&&(c=null),l[e][2]=c,n.push(c)}),this.radii=n}init(){return seriesProto.init.apply(this,arguments),initDataLabelsDefer.call(this),this.eventsToUnbind.push(addEvent(this,"updatedData",function(){this.chart.series.forEach(t=>{t.type===this.type&&(t.isDirty=!0)},this)})),this}onMouseUp(t){const a=t;if(a.fixedPosition&&!a.removed){const s=this.layout,i=this.parentNodeLayout;let e,o;i&&s.options.dragBetweenSeries&&i.nodes.forEach(t=>{a&&a.marker&&t!==a.series.parentNode&&(e=s.getDistXY(a,t),(o=s.vectorLength(e)-t.marker.radius-a.marker.radius)<0&&(t.series.addPoint(merge(a.options,{plotX:a.plotX,plotY:a.plotY}),!1),s.removeElementFromCollection(a,s.nodes),a.remove()))}),DragNodesComposition.onMouseUp.apply(this,arguments)}}placeBubbles(t){const e=this.checkOverlap,o=this.positionBubble,a=[];let s=1,i=0,r=0,n,l=[],h;const p=t.sort((t,e)=>e[2]-t[2]);if(p.length){if(a.push([[0,0,p[0][2],p[0][3],p[0][4]]]),1<p.length)for(a.push([[0,0-p[1][2]-p[0][2],p[1][2],p[1][3],p[1][4]]]),h=2;h<p.length;h++)p[h][2]=p[h][2]||1,n=o(a[s][i],a[s-1][r],p[h]),e(n,a[s][0])?(a.push([]),r=0,a[s+1].push(o(a[s][i],a[s][0],p[h])),s++,i=0):1<s&&a[s-1][r+1]&&e(n,a[s-1][r+1])?(r++,a[s].push(o(a[s][i],a[s-1][r],p[h])),i++):(i++,a[s].push(n));this.chart.stages=a,this.chart.rawPositions=[].concat.apply([],a),this.resizeRadius(),l=this.chart.rawPositions}return l}pointAttribs(t,e){var o=this.options,a=t&&t.isParentNode;let s=o.marker;const i=(s=a&&o.layoutAlgorithm&&o.layoutAlgorithm.parentNodeOptions?o.layoutAlgorithm.parentNodeOptions.marker:s).fillOpacity,r=seriesProto.pointAttribs.call(this,t,e);return 1!==i&&(r["fill-opacity"]=i),r}positionBubble(t,e,o){const a=Math.sqrt,s=Math.asin,i=Math.acos,r=Math.pow,n=Math.abs,l=a(r(t[0]-e[0],2)+r(t[1]-e[1],2)),h=i((r(l,2)+r(o[2]+e[2],2)-r(o[2]+t[2],2))/(2*(o[2]+e[2])*l)),p=s(n(t[0]-e[0])/l),d=t[1]-e[1]<0?0:Math.PI,u=(t[0]-e[0])*(t[1]-e[1])<0?1:-1,c=d+h+p*u,m=Math.cos(c),b=Math.sin(c),f=e[0]+(e[2]+o[2])*b,N=e[1]-(e[2]+o[2])*m;return[f,N,o[2],o[3],o[4]]}render(){const e=[];seriesProto.render.apply(this,arguments),this.options.dataLabels.allowOverlap||(this.data.forEach(t=>{isArray(t.dataLabels)&&t.dataLabels.forEach(t=>{e.push(t)})}),this.options.useSimulation&&this.chart.hideOverlappingLabels(e))}resizeRadius(){const t=this.chart,e=t.rawPositions,o=Math.min,a=Math.max,s=t.plotLeft,i=t.plotTop,r=t.plotHeight,n=t.plotWidth;let l,h,p,d,u;l=p=Number.POSITIVE_INFINITY,h=d=Number.NEGATIVE_INFINITY;for(const b of e)u=b[2],l=o(l,b[0]-u),h=a(h,b[0]+u),p=o(p,b[1]-u),d=a(d,b[1]+u);var c=[h-l,d-p],m=o.apply([],[(n-s)/c[0],(r-i)/c[1]]);if(1e-10<Math.abs(m-1)){for(const f of e)f[2]*=m;this.placeBubbles(e)}else t.diffY=r/2+i-p-(d-p)/2,t.diffX=n/2+s-l-(h-l)/2}seriesBox(){const t=this.chart,e=this.data,o=Math.max,a=Math.min,s=[t.plotLeft,t.plotLeft+t.plotWidth,t.plotTop,t.plotTop+t.plotHeight];let i;return e.forEach(t=>{defined(t.plotX)&&defined(t.plotY)&&t.marker.radius&&(i=t.marker.radius,s[0]=a(s[0],t.plotX-i),s[1]=o(s[1],t.plotX+i),s[2]=a(s[2],t.plotY-i),s[3]=o(s[3],t.plotY+i))}),isNumber(s.width/s.height)?s:null}setVisible(){const e=this;seriesProto.setVisible.apply(e,arguments),e.parentNodeLayout&&e.graph?e.visible?(e.graph.show(),e.parentNode.dataLabel&&e.parentNode.dataLabel.show()):(e.graph.hide(),e.parentNodeLayout.removeElementFromCollection(e.parentNode,e.parentNodeLayout.nodes),e.parentNode.dataLabel&&e.parentNode.dataLabel.hide()):e.layout&&(e.visible?e.layout.addElementsToCollection(e.points,e.layout.nodes):e.points.forEach(t=>{e.layout.removeElementFromCollection(t,e.layout.nodes)}))}translate(){const t=this.chart,e=this.data,o=this.index,a=this.options.useSimulation;let s,i,r;this.processedXData=this.xData,this.generatePoints(),defined(t.allDataPoints)||(t.allDataPoints=this.accumulateAllPoints(),this.getPointRadius()),a?r=t.allDataPoints:(r=this.placeBubbles(t.allDataPoints),this.options.draggable=!1);for(const n of r)n[3]===o&&(s=e[n[4]],i=pick(n[2],void 0),a||(s.plotX=n[0]-t.plotLeft+t.diffX,s.plotY=n[1]-t.plotTop+t.diffY),isNumber(i)&&(s.marker=extend(s.marker,{radius:i,width:2*i,height:2*i}),s.radius=i));a&&this.deferLayout(),fireEvent(this,"afterTranslate")}}PackedBubbleSeries.defaultOptions=merge(BubbleSeries.defaultOptions,PackedBubbleSeriesDefaults),extend(PackedBubbleSeries.prototype,{pointClass:PackedBubblePoint,axisTypes:[],directTouch:!0,forces:["barycenter","repulsive"],hasDraggableNodes:!0,invertible:!1,isCartesian:!1,noSharedTooltip:!0,pointArrayMap:["value"],pointValKey:"value",requireSorting:!1,trackerGroups:["group","dataLabelsGroup","parentNodesGroup"],initDataLabels:initDataLabels,alignDataLabel:seriesProto.alignDataLabel,indexateNodes:noop,onMouseDown:DragNodesComposition.onMouseDown,onMouseMove:DragNodesComposition.onMouseMove,redrawHalo:DragNodesComposition.redrawHalo,searchPoint:noop}),SeriesRegistry.registerSeriesType("packedbubble",PackedBubbleSeries);export default PackedBubbleSeries;