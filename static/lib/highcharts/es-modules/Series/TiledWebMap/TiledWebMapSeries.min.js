"use strict";import H from"../../Core/Globals.js";const composed=H["composed"];import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const MapSeries=SeriesRegistry.seriesTypes["map"];import TilesProvidersRegistry from"../../Maps/TilesProviders/TilesProviderRegistry.js";import TiledWebMapSeriesDefaults from"./TiledWebMapSeriesDefaults.js";import U from"../../Core/Utilities.js";const{addEvent,defined,error,merge,pick,pushUnique}=U;function onRecommendMapView(e){const{geoBounds:t,chart:i}=e,o=(i.options.series||[]).filter(e=>"tiledwebmap"===e.type)[0];if(o&&o.provider&&o.provider.type&&!o.provider.url){const l=TilesProvidersRegistry[o.provider.type];var r,s,a,n;if(defined(l))return e=(new l)["initialProjectionName"],t?({x1:r,y1:s,x2:a,y2:n}=t,this.recommendedMapView={projection:{name:e,parallels:[s,n],rotation:[-(r+a)/2]}}):this.recommendedMapView={projection:{name:e},minZoom:0},!1;error("Highcharts warning: Tiles Provider not defined in the Provider Registry.",!1)}return!0}class TiledWebMapSeries extends MapSeries{constructor(){super(...arguments),this.redrawTiles=!1,this.isAnimating=!1}static compose(e){pushUnique(composed,"TiledWebMapSeries")&&addEvent(e,"onRecommendMapView",onRecommendMapView)}lonLatToTile(e,t){var{lon:e,lat:i}=e;return{x:Math.floor((e+180)/360*Math.pow(2,t)),y:Math.floor((1-Math.log(Math.tan(i*Math.PI/180)+1/Math.cos(i*Math.PI/180))/Math.PI)/2*Math.pow(2,t))}}tileToLonLat(e,t,i){e=e/Math.pow(2,i)*360-180,t=Math.PI-2*Math.PI*t/Math.pow(2,i);return{lon:e,lat:180/Math.PI*Math.atan(.5*(Math.exp(t)-Math.exp(-t)))}}drawPoints(){const d=this.chart,p=d.mapView;if(p){const h=this.tiles=this.tiles||{},c=this.transformGroups=this.transformGroups||[],m=this,E=this.options,f=E.provider,t=p["zoom"],a=pick(p.projection.options.rotation&&p.projection.options.rotation[0],0),u=400.979322,y=256,M=d.renderer.forExport?0:200,T=i=>{for(const o of Object.keys(h))parseFloat(o)===(p.zoom<0?0:Math.floor(p.zoom))||m.minZoom&&(p.zoom<0?0:Math.floor(p.zoom))<m.minZoom&&parseFloat(o)===m.minZoom||m.maxZoom&&(p.zoom<0?0:Math.floor(p.zoom))>m.maxZoom&&parseFloat(o)===m.maxZoom?Object.keys(h[o].tiles).forEach((e,t)=>{h[o].tiles[e].animate({opacity:1},{duration:i},()=>{t===Object.keys(h[o].tiles).length-1&&(h[o].isActive=!0)})}):Object.keys(h[o].tiles).forEach((e,t)=>{h[o].tiles[e].animate({opacity:0},{duration:i,defer:i/2},()=>{h[o].tiles[e].destroy(),delete h[o].tiles[e],t===Object.keys(h[o].tiles).length-1&&(h[o].isActive=!1,h[o].loaded=!1)})})};let o=t<0?0:Math.floor(t),n=Math.pow(2,o),e=y/u*Math.pow(2,t)/(y/u*Math.pow(2,o)),l=256*e;if(f&&(f.type||f.url)){if(f.type&&!f.url){const g=TilesProvidersRegistry[f.type];if(!defined(g))return void error("Highcharts warning: Tiles Provider '"+f.type+"' not defined in the ProviderRegistry.",!1);const w=new g,G=w.initialProjectionName;let e,t="";f.theme&&defined(w.themes[f.theme])?e=w.themes[f.theme]:(i=Object.keys(w.themes)[0],e=w.themes[i],error("Highcharts warning: The Tiles Provider's Theme '"+f.theme+"' is not defined in the Provider definition - falling back to '"+i+"'.",!1)),f.subdomain&&w.subdomains&&-1!==w.subdomains.indexOf(f.subdomain)?t=f.subdomain:defined(w.subdomains)&&-1!==e.url.indexOf("{s}")&&(t=pick(w.subdomains&&w.subdomains[0],""),error("Highcharts warning: The Tiles Provider's Subdomain '"+f.subdomain+"' is not defined in the Provider definition - falling back to '"+t+"'.",!1)),w.requiresApiKey&&(f.apiKey?e.url=e.url.replace("{apikey}",f.apiKey):(error("Highcharts warning: The Tiles Provider requires API Key to use tiles, use provider.apiKey to provide a token.",!1),e.url=e.url.replace("?apikey={apikey}",""))),f.url=e.url.replace("{s}",t),this.minZoom=e.minZoom,this.maxZoom=e.maxZoom;var i=pick(d.userOptions.credits&&d.userOptions.credits.text,"Highcharts.com "+pick(e.credits,w.defaultCredits));d.credits?d.credits.update({text:i}):d.addCredits({text:i,style:pick(d.options.credits?.style,{})}),p.projection.options.name!==G&&error("Highcharts warning: The set projection is different than supported by Tiles Provider.",!1)}else p.projection.options.name||error("Highcharts warning: The set projection is different than supported by Tiles Provider.",!1);if(defined(this.minZoom)&&o<this.minZoom?(o=this.minZoom,n=Math.pow(2,o),e=y/u*Math.pow(2,t)/(y/u*Math.pow(2,o)),l=256*e):defined(this.maxZoom)&&o>this.maxZoom&&(o=this.maxZoom,n=Math.pow(2,o),e=y/u*Math.pow(2,t)/(y/u*Math.pow(2,o)),l=256*e),p.projection&&p.projection.def){p.projection.hasCoordinates=!0,c[o]||(c[o]=d.renderer.g().add(this.group));const K=(e,t,i,o)=>e.replace("{x}",t.toString()).replace("{y}",i.toString()).replace("{zoom}",o.toString()).replace("{z}",o.toString());const x=p.pixelsToProjectedUnits({x:0,y:0}),j=p.projection.def.inverse([x.x,x.y]),v={lon:j[0]-a,lat:j[1]},b=p.pixelsToProjectedUnits({x:d.plotWidth,y:d.plotHeight}),P=p.projection.def.inverse([b.x,b.y]),k={lon:P[0]-a,lat:P[1]};(v.lat>p.projection.maxLatitude||k.lat<-1*p.projection.maxLatitude)&&(v.lat=p.projection.maxLatitude,k.lat=-1*p.projection.maxLatitude);var r=this.lonLatToTile(v,o),s=this.lonLatToTile(k,o),i=this.tileToLonLat(r.x,r.y,o),i=p.projection.def.forward([i.lon+a,i.lat]),i=p.projectedUnitsToPixels({x:i[0],y:i[1]}),F=r.x*l-i.x,N=r.y*l-i.y;h[""+o]||(h[""+o]={tiles:{},isActive:!1,howManyTiles:0,actualTilesCount:0,loaded:!1}),h[""+o].howManyTiles=(s.x-r.x+1)*(s.y-r.y+1),h[""+o].actualTilesCount=0;for(let t=r.x;t<=s.x;t++)for(let e=r.y;e<=s.y;e++)((e,t,i,o,r)=>{var s=e%n,a=t%n,s=s<0?s+n:s,a=a<0?a+n:a;h[""+i].tiles[e+","+t]||f.url&&(s=K(f.url,s,a,i),h[i].loaded=!1,h[""+i].tiles[e+","+t]=d.renderer.image(s,e*l-o,t*l-r,l,l).attr({zIndex:2,opacity:0}).on("load",function(){f.onload&&f.onload.apply(this),i!==(p.zoom<0?0:Math.floor(p.zoom))&&i!==m.minZoom||(h[""+i].actualTilesCount++,h[""+i].howManyTiles===h[""+i].actualTilesCount&&(h[i].loaded=!0,m.isAnimating?m.redrawTiles=!0:(m.redrawTiles=!1,T(M)),h[""+i].actualTilesCount=0))}).add(c[i]),h[""+i].tiles[e+","+t].posX=e,h[""+i].tiles[e+","+t].posY=t,h[""+i].tiles[e+","+t].originalURL=s)})(t,e,o,F,N)}for(const S of Object.keys(h))for(const O of Object.keys(h[S].tiles))if(p.projection&&p.projection.def){const e=y/u*Math.pow(2,t)/(y/u*Math.pow(2,parseFloat(S))),i=256*e,Z=h[S].tiles[Object.keys(h[S].tiles)[0]],{posX:R,posY:L}=h[S].tiles[O];if(defined(R)&&defined(L)&&defined(Z.posX)&&defined(Z.posY)){const z=this.tileToLonLat(Z.posX,Z.posY,parseFloat(S)),H=p.projection.def.forward([z.lon+a,z.lat]),A=p.projectedUnitsToPixels({x:H[0],y:H[1]}),C=Z.posX*i-A.x,U=Z.posY*i-A.y;if(d.renderer.globalAnimation&&d.hasRendered){const W=Number(h[S].tiles[O].attr("x")),I=Number(h[S].tiles[O].attr("y")),V=Number(h[S].tiles[O].attr("width")),X=Number(h[S].tiles[O].attr("height"));m.isAnimating=!0,h[S].tiles[O].attr({animator:0}).animate({animator:1},{step:(e,t)=>{h[S].tiles[O].attr({x:W+(R*i-C-W)*t.pos,y:I+(L*i-U-I)*t.pos,width:V+(Math.ceil(i)+1-V)*t.pos,height:X+(Math.ceil(i)+1-X)*t.pos})}},function(){m.isAnimating=!1,m.redrawTiles&&(m.redrawTiles=!1,T(M))})}else(m.redrawTiles||parseFloat(S)!==o||(h[S].isActive||parseFloat(S)===o)&&Object.keys(h[S].tiles).map(e=>h[S].tiles[e]).some(e=>0===e.opacity))&&(m.redrawTiles=!1,T(M)),h[S].tiles[O].attr({x:R*i-C,y:L*i-U,width:Math.ceil(i)+1,height:Math.ceil(i)+1})}}}else error("Highcharts warning: Tiles Provider not defined in the Provider Registry.",!1)}}update(){const e=this["transformGroups"],t=this.chart,i=t.mapView,o=arguments[0],r=o["provider"];if(e&&(e.forEach(e=>{0!==Object.keys(e).length&&e.destroy()}),this.transformGroups=[]),i&&!defined(t.userOptions.mapView?.projection)&&r&&r.type){const a=TilesProvidersRegistry[r.type];var s;a&&(s=(new a)["initialProjectionName"],i.update({projection:{name:s}}))}super.update.apply(this,arguments)}}TiledWebMapSeries.defaultOptions=merge(MapSeries.defaultOptions,TiledWebMapSeriesDefaults),SeriesRegistry.registerSeriesType("tiledwebmap",TiledWebMapSeries);export default TiledWebMapSeries;