"use strict";import Color from"../../Core/Color/Color.js";import ColorMapComposition from"../ColorMapComposition.js";import HeatmapPoint from"./HeatmapPoint.js";import HeatmapSeriesDefaults from"./HeatmapSeriesDefaults.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{series:Series,seriesTypes:{column:ColumnSeries,scatter:ScatterSeries}}=SeriesRegistry;import SVGRenderer from"../../Core/Renderer/SVG/SVGRenderer.js";const{symbols}=SVGRenderer["prototype"];import U from"../../Core/Utilities.js";const{addEvent,extend,fireEvent,isNumber,merge,pick}=U;import IU from"../InterpolationUtilities.js";const{colorFromPoint,getContext}=IU;class HeatmapSeries extends ScatterSeries{constructor(){super(...arguments),this.valueMax=NaN,this.valueMin=NaN,this.isDirtyCanvas=!0}drawPoints(){const t=this,e=t.options,r=e.interpolation,I=e.marker||{};if(r){const{image:i,chart:o,xAxis:a,yAxis:l}=t,{reversed:n=!1,len:p}=a,{reversed:m=!1,len:h}=l,d={width:p,height:h};if(!i||t.isDirtyData||t.isDirtyCanvas){const c=getContext(t),{canvas:g,options:{colsize:y=1,rowsize:u=1},points:b,points:{length:x}}=t,C=x-1,M=o.colorAxis&&o.colorAxis[0];if(g&&c&&M){const{min:S,max:f}=a.getExtremes(),{min:k,max:D}=l.getExtremes(),v=f-S,w=D-k,A=Math.round(v/y/8*8),P=Math.round(w/u/8*8),[R,H]=[[A,A/v,n,"ceil"],[P,P/w,!m,"floor"]].map(([t,r,e,s])=>e?e=>Math[s](t-r*e):e=>Math[s](r*e)),E=g.width=A+1,N=g.height=P+1,T=E*N,U=C/T,j=new Uint8ClampedArray(4*T);t.buildKDTree();for(let e=0;e<T;e++){var s=b[Math.ceil(U*e)],{x:G,y:V}=s;j.set(colorFromPoint(s.value,s),(s=G,4*Math.ceil(E*H(V-k)+R(s-S))))}c.putImageData(new ImageData(j,E),0,0),i?i.attr({...d,href:g.toDataURL("image/png",1)}):(t.directTouch=!1,t.image=o.renderer.image(g.toDataURL("image/png",1)).attr(d).add(t.group))}t.isDirtyCanvas=!1}else i.width===p&&i.height===h||i.attr(d)}else(I.enabled||t._hasPointMarkers)&&(Series.prototype.drawPoints.call(t),t.points.forEach(e=>{e.graphic&&(e.graphic[t.chart.styledMode?"css":"animate"](t.colorAttribs(e)),null===e.value&&e.graphic.addClass("highcharts-null-point"))}))}getExtremes(){var{dataMin:e,dataMax:t}=Series.prototype.getExtremes.call(this,this.valueData);return isNumber(e)&&(this.valueMin=e),isNumber(t)&&(this.valueMax=t),Series.prototype.getExtremes.call(this)}getValidPoints(e,t){return Series.prototype.getValidPoints.call(this,e,t,!0)}hasData(){return!!this.xData}init(){super.init.apply(this,arguments);const e=this.options;e.pointRange=pick(e.pointRange,e.colsize||1),this.yAxis.axisPointRange=e.rowsize||1,symbols.ellipse=symbols.circle,e.marker&&isNumber(e.borderRadius)&&(e.marker.r=e.borderRadius)}markerAttribs(e,t){var r,s=e.shapeArgs||{};return e.hasImage?{x:e.plotX,y:e.plotY}:t&&"normal"!==t?(e=e.options.marker||{},r=(r=this.options.marker||{}).states&&r.states[t]||{},t=((e=e.states&&e.states[t]||{}).width||r.width||s.width||0)+(e.widthPlus||r.widthPlus||0),e=(e.height||r.height||s.height||0)+(e.heightPlus||r.heightPlus||0),{x:(s.x||0)+((s.width||0)-t)/2,y:(s.y||0)+((s.height||0)-e)/2,width:t,height:e}):s}pointAttribs(e,t){const r=Series.prototype.pointAttribs.call(this,e,t),s=this.options||{},i=this.chart.options.plotOptions||{},o=i.series||{},a=i.heatmap||{},l=e&&e.options.borderColor||s.borderColor||a.borderColor||o.borderColor,n=e&&e.options.borderWidth||s.borderWidth||a.borderWidth||o.borderWidth||r["stroke-width"];return r.stroke=e&&e.marker&&e.marker.lineColor||s.marker&&s.marker.lineColor||l||this.color,r["stroke-width"]=n,t&&"normal"!==t&&(e=merge(s.states&&s.states[t],s.marker&&s.marker.states&&s.marker.states[t],e&&e.options.states&&e.options.states[t]||{}),r.fill=e.color||Color.parse(r.fill).brighten(e.brightness||0).get(),r.stroke=e.lineColor||r.stroke),r}translate(){const e=this,t=e.options,{borderRadius:i,marker:r}=t,o=r&&r.symbol||"rect",a=symbols[o]?o:"rect",l=-1!==["circle","square"].indexOf(a);var s,n;e.processedXData||({xData:s,yData:n}=e.getProcessedData(),e.processedXData=s,e.processedYData=n),e.generatePoints();for(const h of e.points){var p,m=h.getCellAttributes();let e=Math.min(m.x1,m.x2),t=Math.min(m.y1,m.y2),r=Math.max(Math.abs(m.x2-m.x1),0),s=Math.max(Math.abs(m.y2-m.y1),0);h.hasImage=0===(h.marker&&h.marker.symbol||o||"").indexOf("url"),l&&(p=Math.abs(r-s),e=Math.min(m.x1,m.x2)+(r<s?0:p/2),t=Math.min(m.y1,m.y2)+(r<s?p/2:0),r=s=Math.min(r,s)),h.hasImage&&(h.marker={width:r,height:s}),h.plotX=h.clientX=(m.x1+m.x2)/2,h.plotY=(m.y1+m.y2)/2,h.shapeType="path",h.shapeArgs=merge(!0,{x:e,y:t,width:r,height:s},{d:symbols[a](e,t,r,s,{r:isNumber(i)?i:0})})}fireEvent(e,"afterTranslate")}}HeatmapSeries.defaultOptions=merge(ScatterSeries.defaultOptions,HeatmapSeriesDefaults),addEvent(HeatmapSeries,"afterDataClassLegendClick",function(){this.isDirtyCanvas=!0,this.drawPoints()}),extend(HeatmapSeries.prototype,{axisTypes:ColorMapComposition.seriesMembers.axisTypes,colorKey:ColorMapComposition.seriesMembers.colorKey,directTouch:!0,getExtremesFromAll:!0,parallelArrays:ColorMapComposition.seriesMembers.parallelArrays,pointArrayMap:["y","value"],pointClass:HeatmapPoint,specialGroup:"group",trackerGroups:ColorMapComposition.seriesMembers.trackerGroups,alignDataLabel:ColumnSeries.prototype.alignDataLabel,colorAttribs:ColorMapComposition.seriesMembers.colorAttribs,getSymbol:Series.prototype.getSymbol}),ColorMapComposition.compose(HeatmapSeries),SeriesRegistry.registerSeriesType("heatmap",HeatmapSeries);export default HeatmapSeries;