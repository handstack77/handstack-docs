"use strict";import Color from"../../Core/Color/Color.js";const color=Color["parse"];import F from"../../Core/Templating.js";import H from"../../Core/Globals.js";const noop=H["noop"];import U from"../../Core/Utilities.js";const{arrayMax,arrayMin,isNumber,merge,pick,stableSort}=U;class BubbleLegendItem{constructor(e,t){this.setState=noop,this.init(e,t)}init(e,t){this.options=e,this.visible=!0,this.chart=t.chart,this.legend=t}addToLegend(e){e.splice(this.options.legendIndex,0,this)}drawLegendSymbol(e){const t=pick(e.options.itemDistance,20),s=this.legendItem||{},i=this.options,o=i.ranges,r=i.connectorDistance;let n;var a,l,h;o&&o.length&&isNumber(o[0].value)?(stableSort(o,function(e,t){return t.value-e.value}),this.ranges=o,this.setOptions(),this.render(),a=this.getMaxLabelSize(),h=2*(l=this.ranges[0].radius),n=0<(n=r-l+a.width)?n:0,this.maxLabel=a,this.movementX="left"===i.labels.align?n:0,s.labelWidth=h+n+t,s.labelHeight=h+a.height/2):e.options.bubbleLegend.autoRanges=!0}setOptions(){const s=this.ranges,i=this.options,o=this.chart.series[i.seriesIndex],r=this.legend.baseline,n={zIndex:i.zIndex,"stroke-width":i.borderWidth},a={zIndex:i.zIndex,"stroke-width":i.connectorWidth},l={align:this.legend.options.rtl||"left"===i.labels.align?"right":"left",zIndex:i.zIndex},h=o.options.marker.fillOpacity,c=this.chart.styledMode;s.forEach(function(e,t){c||(n.stroke=pick(e.borderColor,i.borderColor,o.color),n.fill=pick(e.color,i.color,1!==h?color(o.color).setOpacity(h).get("rgba"):o.color),a.stroke=pick(e.connectorColor,i.connectorColor,o.color)),s[t].radius=this.getRangeRadius(e.value),s[t]=merge(s[t],{center:s[0].radius-s[t].radius+r}),c||merge(!0,s[t],{bubbleAttribs:merge(n),connectorAttribs:merge(a),labelAttribs:l})},this)}getRangeRadius(e){const t=this.options,s=this.options.seriesIndex,i=this.chart.series[s],o=t.ranges[0].value,r=t.ranges[t.ranges.length-1].value,n=t.minSize,a=t.maxSize;return i.getRadius.call(this,r,o,n,a,e)}render(){const e=this.legendItem||{},t=this.chart.renderer,s=this.options.zThreshold;this.symbols||(this.symbols={connectors:[],bubbleItems:[],labels:[]}),e.symbol=t.g("bubble-legend"),e.label=t.g("bubble-legend-item").css(this.legend.itemStyle||{}),e.symbol.translateX=0,e.symbol.translateY=0,e.symbol.add(e.label),e.label.add(e.group);for(const i of this.ranges)i.value>=s&&this.renderRange(i);this.hideOverlappingLabels()}renderRange(e){const t=this.ranges[0],s=this.legend,i=this.options,o=i.labels,r=this.chart,n=r.series[i.seriesIndex],a=r.renderer,l=this.symbols,h=l.labels,c=e.center,b=Math.abs(e.radius),d=i.connectorDistance||0,g=o.align,m=s.options.rtl,p=i.borderWidth,u=i.connectorWidth,x=t.radius||0,f=c-b-p/2+u/2,y=(f%1?1:.5)-(u%2?0:.5),z=a.styledMode;let M=m||"left"===g?-d:d;"center"===g&&(M=0,i.connectorDistance=0,e.labelAttribs.align="center"),l.bubbleItems.push(a.circle(x,c+y,b).attr(z?{}:e.bubbleAttribs).addClass((z?"highcharts-color-"+n.colorIndex+" ":"")+"highcharts-bubble-legend-symbol "+(i.className||"")).add(this.legendItem.symbol)),l.connectors.push(a.path(a.crispLine([["M",x,f],["L",x+M,f]],i.connectorWidth)).attr(z?{}:e.connectorAttribs).addClass((z?"highcharts-color-"+this.options.seriesIndex+" ":"")+"highcharts-bubble-legend-connectors "+(i.connectorClassName||"")).add(this.legendItem.symbol));const I=a.text(this.formatLabel(e)).attr(z?{}:e.labelAttribs).css(z?{}:o.style).addClass("highcharts-bubble-legend-labels "+(i.labels.className||"")).add(this.legendItem.symbol);e={x:x+M+i.labels.x,y:f+i.labels.y+.4*I.getBBox().height};I.attr(e),h.push(I),I.placed=!0,I.alignAttr=e}getMaxLabelSize(){const e=this.symbols.labels;let t,s;return e.forEach(function(e){s=e.getBBox(!0),t=!t||s.width>t.width?s:t}),t||{}}formatLabel(e){const t=this.options,s=t.labels.formatter,i=t.labels.format,o=this.chart["numberFormatter"];return i?F.format(i,e):s?s.call(e):o(e.value,1)}hideOverlappingLabels(){const e=this.chart,t=this.options.labels.allowOverlap,s=this.symbols;!t&&s&&(e.hideOverlappingLabels(s.labels),s.labels.forEach(function(e,t){e.newOpacity?e.newOpacity!==e.oldOpacity&&s.connectors[t].show():s.connectors[t].hide()}))}getRanges(){const e=this.legend.bubbleLegend,t=e.chart.series,s=e.options.ranges;let i,o,r=Number.MAX_VALUE,n=-Number.MAX_VALUE;return t.forEach(function(e){e.isBubble&&!e.ignoreSeries&&(o=e.zData.filter(isNumber)).length&&(r=pick(e.options.zMin,Math.min(r,Math.max(arrayMin(o),!1===e.options.displayNegative?e.options.zThreshold:-Number.MAX_VALUE))),n=pick(e.options.zMax,Math.max(n,arrayMax(o))))}),i=r===n?[{value:n}]:[{value:r},{value:(r+n)/2},{value:n,autoRanges:!0}],s.length&&s[0].radius&&i.reverse(),i.forEach(function(e,t){s&&s[t]&&(i[t]=merge(s[t],e))}),i}predictBubbleSizes(){const e=this.chart,t=e.legend.options,s=t.floating,i="horizontal"===t.layout,o=i?e.legend.lastLineHeight:0,r=e.plotSizeX,n=e.plotSizeY,a=e.series[this.options.seriesIndex],l=a.getPxExtremes(),h=Math.ceil(l.minPxSize),c=Math.ceil(l.maxPxSize),b=Math.min(n,r);let d,g=a.options.maxSize;return s||!/%$/.test(g)?d=c:(g=parseFloat(g),d=(b+o)*g/100/(g/100+1),(i&&n-d>=r||!i&&r-d>=n)&&(d=c)),[h,Math.ceil(d)]}updateRanges(e,t){const s=this.legend.options.bubbleLegend;s.minSize=e,s.maxSize=t,s.ranges=this.getRanges()}correctSizes(){const e=this.legend,t=this.chart,s=t.series[this.options.seriesIndex],i=s.getPxExtremes(),o=i.maxPxSize,r=this.options.maxSize;1<Math.abs(Math.ceil(o)-r)&&(this.updateRanges(this.options.minSize,i.maxPxSize),e.render())}}export default BubbleLegendItem;