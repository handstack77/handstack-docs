"use strict";import H from"../../Core/Globals.js";import NodesComposition from"../NodesComposition.js";import SankeyPoint from"./SankeyPoint.js";import SankeySeriesDefaults from"./SankeySeriesDefaults.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";import SankeyColumnComposition from"./SankeyColumnComposition.js";const{column:ColumnSeries,line:LineSeries}=SeriesRegistry.seriesTypes;import Color from"../../Core/Color/Color.js";const color=Color["parse"];import TU from"../TreeUtilities.js";const{getLevelOptions,getNodeWidth}=TU;import U from"../../Core/Utilities.js";const{clamp,crisp,extend,isObject,merge,pick,relativeLength,stableSort}=U;import SVGElement from"../../Core/Renderer/SVG/SVGElement.js";import TextPath from"../../Extensions/TextPath.js";TextPath.compose(SVGElement);class SankeySeries extends ColumnSeries{static getDLOptions(o){var e=isObject(o.optionsPoint)?o.optionsPoint.dataLabels:{},o=isObject(o.level)?o.level.dataLabels:{};return merge({style:{}},o,e)}createNodeColumns(){const e=[];for(const o of this.nodes)o.setNodeColumn(),e[o.column]||(e[o.column]=SankeyColumnComposition.compose([],this)),e[o.column].push(o);for(let o=0;o<e.length;o++)void 0===e[o]&&(e[o]=SankeyColumnComposition.compose([],this));return e}order(o,e){if(void 0===o.level){o.level=e;for(const t of o.linksFrom)t.toNode&&this.order(t.toNode,e+1)}}generatePoints(){if(NodesComposition.generatePoints.apply(this,arguments),this.orderNodes){for(const o of this.nodes)0===o.linksTo.length&&this.order(o,0);stableSort(this.nodes,(o,e)=>o.level-e.level)}}getNodePadding(){let o=this.options.nodePadding||0;var e;return o=this.nodeColumns&&(e=this.nodeColumns.reduce((o,e)=>Math.max(o,e.length),0))*o>this.chart.plotSizeY?this.chart.plotSizeY/e:o}hasData(){return!!this.processedXData.length}pointAttribs(o,e){if(!o)return{};const t=this,i=(o.isNode?o:o.fromNode).level,s=t.mapOptionsToLevel[i||0]||{},r=o.options,n=s.states&&s.states[e||""]||{},l=["colorByPoint","borderColor","borderWidth","linkOpacity","opacity"].reduce((o,e)=>(o[e]=pick(n[e],r[e],s[e],t.options[e]),o),{}),a=pick(n.color,r.color,(l.colorByPoint?o:s).color);return o.isNode?{fill:a,stroke:l.borderColor,"stroke-width":l.borderWidth,opacity:l.opacity}:{fill:Color.parse(a).setOpacity(l.linkOpacity).get()}}drawTracker(){ColumnSeries.prototype.drawTracker.call(this,this.points),ColumnSeries.prototype.drawTracker.call(this,this.nodes)}drawPoints(){ColumnSeries.prototype.drawPoints.call(this,this.points),ColumnSeries.prototype.drawPoints.call(this,this.nodes)}drawDataLabels(){ColumnSeries.prototype.drawDataLabels.call(this,this.points),ColumnSeries.prototype.drawDataLabels.call(this,this.nodes)}translate(){this.processedXData||this.processData(),this.generatePoints(),this.nodeColumns=this.createNodeColumns();const t=this,o=this.chart,e=this.options,i=this.nodeColumns,s=i.length;this.nodeWidth=getNodeWidth(this,s),this.nodePadding=this.getNodePadding(),this.translationFactor=i.reduce((o,e)=>Math.min(o,e.sankeyColumn.getTranslationFactor(t)),1/0),this.colDistance=(o.plotSizeX-this.nodeWidth-e.borderWidth)/Math.max(1,i.length-1),t.mapOptionsToLevel=getLevelOptions({from:1,levels:e.levels,to:i.length-1,defaults:{borderColor:e.borderColor,borderRadius:e.borderRadius,borderWidth:e.borderWidth,color:t.color,colorByPoint:e.colorByPoint,levelIsConstant:!0,linkColor:e.linkColor,linkLineWidth:e.linkLineWidth,linkOpacity:e.linkOpacity,states:e.states}});for(const r of i)for(const n of r)t.translateNode(n,r);for(const l of this.nodes)for(const a of l.linksFrom)(a.weight||a.isNull)&&a.to&&(t.translateLink(a),a.allowShadow=!1)}translateLink(t){var o,e,i,s,r,n,l,a,d,p,h,c,m,S,y,C,u,g,f=(o,e)=>{e=o.offset(t,e)*P;return Math.min(o.nodeY+e,o.nodeY+(o.shapeArgs&&o.shapeArgs.height||0)-W)};const k=t.fromNode,v=t.toNode,L=this.chart,b=L["inverted"],P=this.translationFactor,N=this.options,x=pick(t.linkColorMode,N.linkColorMode),T=(L.inverted?-this.colDistance:this.colDistance)*N.curveFactor,w=k.nodeX,O=v.nodeX,D=t.outgoing;let W=Math.max(t.weight*P,this.options.minLinkWidth),j=f(k,"linksFrom"),M=f(v,"linksTo"),z=this.nodeWidth,Y=O>w+z;L.inverted&&(j=L.plotSizeY-j,M=(L.plotSizeY||0)-M,z=-z,W=-W,Y=O<w),t.shapeType="path",t.linkBase=[j,j+W,M,M+W],Y&&"number"==typeof M?t.shapeArgs={d:[["M",w+z,j],["C",w+z+T,j,O-T,M,O,M],["L",O+(D?z:0),M+W/2],["L",O,M+W],["C",O-T,M+W,w+z+T,j+W,w+z,j+W],["Z"]]}:"number"==typeof M&&(f=L.plotHeight-j-W,o=O-20-W,e=O-20,r=(s=(i=w+z)+20)+W,d=(a=(f=(l=(n=(u=j)+W)+20)+f)+20)+W,c=(h=(p=M)+W)+20,g=n-.7*W,m=a+.7*W,S=h-.7*W,y=O-.7*W,C=i+.7*W,t.shapeArgs={d:[["M",i,u],["C",C,u,r,g,r,l],["L",r,f],["C",r,m,C,d,i,d],["L",O,d],["C",y,d,o,m,o,f],["L",o,c],["C",o,S,y,p,O,p],["L",O,h],["C",e,h,e,h,e,c],["L",e,f],["C",e,a,e,a,O,a],["L",i,a],["C",s,a,s,a,s,f],["L",s,l],["C",s,n,s,n,i,n],["Z"]]}),t.dlBox={x:w+(O-w+z)/2,y:j+(M-j)/2,height:W,width:0},t.tooltipPos=L.inverted?[L.plotSizeY-t.dlBox.y-W/2,L.plotSizeX-t.dlBox.x]:[t.dlBox.x,t.dlBox.y+W/2],t.y=t.plotY=1,t.x=t.plotX=1,t.options.color||("from"===x?t.color=k.color:"to"===x?t.color=v.color:"gradient"===x&&(u=color(k.color).get(),g=color(v.color).get(),t.color={linearGradient:{x1:1,x2:0,y1:0,y2:0},stops:[[0,b?u:g],[1,b?g:u]]}))}translateNode(s,r){var o=this.translationFactor,n=this.chart,l=this.options,{borderRadius:a,borderWidth:d=0}=l,e=s.getSum(),p=Math.max(Math.round(e*o),this.options.minLinkWidth),h=Math.round(this.nodeWidth),c=r.sankeyColumn.offset(s,o),r=crisp(pick(c.absoluteTop,r.sankeyColumn.top(o)+c.relativeTop),d),o=crisp(this.colDistance*s.column+d/2,d)+relativeLength(s.options[n.inverted?"offsetVertical":"offsetHorizontal"]||0,h),c=n.inverted?n.plotSizeX-o:o;if(s.sum=e){s.shapeType="roundedRect";let o=s.nodeX=c,e=s.nodeY=r,t=s.options.width||l.width||h,i=s.options.height||l.height||p;d=clamp(relativeLength("object"==typeof a?a.radius:a||0,t),0,p/2);n.inverted&&(o=c-h,e=n.plotSizeY-r-p,t=s.options.height||l.height||h,i=s.options.width||l.width||p),s.dlOptions=SankeySeries.getDLOptions({level:this.mapOptionsToLevel[s.level],optionsPoint:s.options}),s.plotX=1,s.plotY=1,s.tooltipPos=n.inverted?[n.plotSizeY-e-i/2,n.plotSizeX-o-t/2]:[o+t/2,e+i/2],s.shapeArgs={x:o,y:e,width:t,height:i,r:d,display:s.hasShape()?"":"none"}}else s.dlOptions={enabled:!1}}}SankeySeries.defaultOptions=merge(ColumnSeries.defaultOptions,SankeySeriesDefaults),NodesComposition.compose(SankeyPoint,SankeySeries),extend(SankeySeries.prototype,{animate:LineSeries.prototype.animate,createNode:NodesComposition.createNode,forceDL:!0,invertible:!0,isCartesian:!1,orderNodes:!0,noSharedTooltip:!0,pointArrayMap:["from","to","weight"],pointClass:SankeyPoint,searchPoint:H.noop}),SeriesRegistry.registerSeriesType("sankey",SankeySeries);export default SankeySeries;