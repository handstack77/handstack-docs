"use strict";import A from"../../Core/Animation/AnimationUtilities.js";const animObject=A["animObject"];import Color from"../../Core/Color/Color.js";const color=Color["parse"];import CU from"../../Core/Geometry/CircleUtilities.js";const{getAreaOfIntersectionBetweenCircles,getCirclesIntersectionPolygon,isCircle1CompletelyOverlappingCircle2,isPointInsideAllCircles,isPointOutsideAllCircles}=CU;import DPU from"../DrawPointUtilities.js";import GU from"../../Core/Geometry/GeometryUtilities.js";const getCenterOfPoints=GU["getCenterOfPoints"];import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const ScatterSeries=SeriesRegistry.seriesTypes["scatter"];import VennPoint from"./VennPoint.js";import VennSeriesDefaults from"./VennSeriesDefaults.js";import VennUtils from"./VennUtils.js";import U from"../../Core/Utilities.js";const{addEvent,extend,isArray,isNumber,isObject,merge}=U;class VennSeries extends ScatterSeries{static getLabelPosition(r,s){let e=r.reduce((e,t)=>{var i=t.r/2;return[{x:t.x,y:t.y},{x:t.x+i,y:t.y},{x:t.x-i,y:t.y},{x:t.x,y:t.y+i},{x:t.x,y:t.y-i}].reduce((e,t)=>{var i=VennUtils.getMarginFromCircles(t,r,s);return e.margin<i&&(e.point=t,e.margin=i),e},e)},{point:void 0,margin:-Number.MAX_VALUE}).point;var t=VennUtils.nelderMead(e=>-VennUtils.getMarginFromCircles({x:e[0],y:e[1]},r,s),[e.x,e.y]);return e={x:t[0],y:t[1]},e=isPointInsideAllCircles(e,r)&&isPointOutsideAllCircles(e,s)?e:1<r.length?getCenterOfPoints(getCirclesIntersectionPolygon(r)):{x:r[0].x,y:r[0].y}}static getLabelValues(e,t){const r=e.sets,i=t.reduce((e,t)=>{var i=-1<r.indexOf(t.sets[0]);return t.circle&&e[i?"internal":"external"].push(t.circle),e},{internal:[],external:[]});i.external=i.external.filter(t=>i.internal.some(e=>!isCircle1CompletelyOverlappingCircle2(t,e)));e=VennSeries.getLabelPosition(i.internal,i.external);return{position:e,width:VennUtils.getLabelWidth(e,i.internal,i.external)}}static layout(e){const t={},i={};if(0<e.length){const o=VennUtils.layoutGreedyVenn(e);var r=e.filter(VennUtils.isSet);for(const a of e){const l=a.sets;var s=l.join(),n=VennUtils.isSet(a)?o[s]:getAreaOfIntersectionBetweenCircles(l.map(e=>o[e]));n&&(t[s]=n,i[s]=VennSeries.getLabelValues(a,r))}}return{mapOfIdToShape:t,mapOfIdToLabelValues:i}}static getScale(e,t,i){var r=i.bottom-i.top,s=i.right-i.left,n=(i.right+i.left)/2,i=(i.top+i.bottom)/2,s=Math.min(0<s?1/s*e:1,0<r?1/r*t:1);return{scale:s,centerX:e/2-n*s,centerY:t/2-i*s}}static updateFieldBoundaries(e,t){var i=t.x-t.r,r=t.x+t.r,s=t.y+t.r,t=t.y-t.r;return(!isNumber(e.left)||e.left>i)&&(e.left=i),(!isNumber(e.right)||e.right<r)&&(e.right=r),(!isNumber(e.top)||e.top>t)&&(e.top=t),(!isNumber(e.bottom)||e.bottom<s)&&(e.bottom=s),e}animate(e){if(!e){var t=animObject(this.options.animation);for(const r of this.points){var i=r.shapeArgs;if(r.graphic&&i){const s={},n={};i.d?s.opacity=.001:(s.r=0,n.r=i.r),r.graphic.attr(s).animate(n,t),i.d&&setTimeout(()=>{r&&r.graphic&&r.graphic.animate({opacity:1})},t.duration)}}}}drawPoints(){var e=this.chart,t=this.group,i=this.points||[],r=e.renderer;for(const o of i){var s={zIndex:isArray(o.sets)?o.sets.length:0},n=o.shapeArgs;e.styledMode||extend(s,this.pointAttribs(o,o.state)),DPU.draw(o,{isNew:!o.graphic,animatableAttribs:n,attribs:s,group:t,renderer:r,shapeType:n&&n.d?"path":"circle"})}}init(){ScatterSeries.prototype.init.apply(this,arguments),delete this.opacity}pointAttribs(e,t){var i=this.options||{},r=e&&e.options||{},t=t&&i.states[t]||{},i=merge(i,{color:e&&e.color},r,t);return{fill:color(i.color).brighten(i.brightness).get(),opacity:i.opacity,stroke:i.borderColor,"stroke-width":i.borderWidth,dashstyle:i.borderDashStyle}}translate(){var e=this.chart,t=(this.processedXData=this.xData,this.generatePoints(),VennUtils.processVennData(this.options.data,VennSeries.splitter));const{mapOfIdToShape:r,mapOfIdToLabelValues:s}=VennSeries.layout(t),i=Object.keys(r).filter(e=>{e=r[e];return e&&isNumber(e.r)}).reduce((e,t)=>VennSeries.updateFieldBoundaries(e,r[t]),{top:0,bottom:0,left:0,right:0}),n=VennSeries.getScale(e.plotWidth,e.plotHeight,i),o=n.scale,a=n.centerX,l=n.centerY;for(const c of this.points){const p=isArray(c.sets)?c.sets:[],m=p.join(),d=r[m],h=s[m]||{},g=c.options&&c.options.dataLabels;let e,t=h.width,i=h.position;if(d){if(d.r)e={x:a+d.x*o,y:l+d.y*o,r:d.r*o};else if(d.d){const y=d.d;y.forEach(e=>{"M"===e[0]?(e[1]=a+e[1]*o,e[2]=l+e[2]*o):"A"===e[0]&&(e[1]=e[1]*o,e[2]=e[2]*o,e[6]=a+e[6]*o,e[7]=l+e[7]*o)}),e={d:y}}i?(i.x=a+i.x*o,i.y=l+i.y*o):i={},isNumber(t)&&(t=Math.round(t*o))}c.shapeArgs=e,i&&e&&(c.plotX=i.x,c.plotY=i.y),t&&e&&(c.dlOptions=merge(!0,{style:{width:t}},isObject(g,!0)?g:void 0)),c.name=c.options.name||p.join("âˆ©")}}}VennSeries.splitter="highcharts-split",VennSeries.defaultOptions=merge(ScatterSeries.defaultOptions,VennSeriesDefaults),extend(VennSeries.prototype,{axisTypes:[],directTouch:!0,isCartesian:!1,pointArrayMap:["value"],pointClass:VennPoint,utils:VennUtils}),addEvent(VennSeries,"afterSetOptions",function(e){const t=e.options,i=t.states||{};if(this.is("venn"))for(const r of Object.keys(i))i[r].halo=!1}),SeriesRegistry.registerSeriesType("venn",VennSeries);export default VennSeries;