"use strict";import PU from"../PathUtilities.js";const getLinkPath=PU["getLinkPath"];import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{series:{prototype:seriesProto},seriesTypes:{treemap:TreemapSeries,column:ColumnSeries}}=SeriesRegistry;import SVGRenderer from"../../Core/Renderer/SVG/SVGRenderer.js";const{symbols}=SVGRenderer["prototype"];import TreegraphNode from"./TreegraphNode.js";import TreegraphPoint from"./TreegraphPoint.js";import TU from"../TreeUtilities.js";const{getLevelOptions,getNodeWidth}=TU;import U from"../../Core/Utilities.js";const{arrayMax,crisp,extend,merge,pick,relativeLength,splat}=U;import TreegraphLink from"./TreegraphLink.js";import TreegraphLayout from"./TreegraphLayout.js";import TreegraphSeriesDefaults from"./TreegraphSeriesDefaults.js";import SVGElement from"../../Core/Renderer/SVG/SVGElement.js";import TextPath from"../../Extensions/TextPath.js";TextPath.compose(SVGElement);class TreegraphSeries extends TreemapSeries{constructor(){super(...arguments),this.nodeList=[],this.links=[]}init(){super.init.apply(this,arguments),this.layoutAlgorythm=new TreegraphLayout;const i=this,e=this.chart.labelCollectors;e.some(e=>"collectorFunc"===e.name)||e.push(function(){const e=[];if(!splat(i.options.dataLabels)[0].allowOverlap)for(const t of i.links||[])t.dataLabel&&e.push(t.dataLabel);return e})}getLayoutModifiers(){const e=this.chart,h=this,d=e.plotSizeX,c=e.plotSizeY,g=arrayMax(this.points.map(e=>e.node.xPosition));let m=1/0,k=-1/0,y=1/0,T=-1/0,v=0,u=0,P=0,L=0;this.points.forEach(t=>{if(!this.options.fillSpace||t.visible){const i=t.node,s=h.mapOptionsToLevel[t.node.level]||{},o=merge(this.options.marker,s.marker,t.options.marker),r=o.width??getNodeWidth(this,g),a=relativeLength(o.radius||0,Math.min(d,c)),l=o.symbol,n="circle"!==l&&o.height?relativeLength(o.height,c):2*a,p="circle"!==l&&r?relativeLength(r,d):2*a;i.nodeSizeX=p,i.nodeSizeY=n;let e;i.xPosition<=m&&(m=i.xPosition,e=o.lineWidth||0,u=Math.max(p+e,u)),i.xPosition>=k&&(k=i.xPosition,e=o.lineWidth||0,v=Math.max(p+e,v)),i.yPosition<=y&&(y=i.yPosition,e=o.lineWidth||0,L=Math.max(n+e,L)),i.yPosition>=T&&(T=i.yPosition,e=o.lineWidth||0,P=Math.max(n+e,P))}});var t=T===y?1:(c-(L+P)/2)/(T-y),i=T===y?c/2:-t*y+L/2,s=k===m?1:(d-(v+v)/2)/(k-m);return{ax:s,bx:k===m?d/2:-s*m+u/2,ay:t,by:i}}getLinks(){const i=this,s=[];return this.data.forEach(e=>{var t=i.mapOptionsToLevel[e.node.level||0]||{};e.node.parent?(t=merge(t,e.options),!e.linkToParent||e.linkToParent.destroyed?(t=new i.LinkClass(i,t,void 0,e),e.linkToParent=t):(e.collapsed=pick(e.collapsed,(this.mapOptionsToLevel[e.node.level]||{}).collapsed),e.linkToParent.visible=e.linkToParent.toNode.visible),e.linkToParent.index=s.push(e.linkToParent)-1):e.linkToParent&&(i.links.splice(e.linkToParent.index),e.linkToParent.destroy(),delete e.linkToParent)}),s}buildTree(e,t,i,s,o){var r=this.points[t];return i=r&&r.level||i,super.buildTree.call(this,e,t,i,s,o)}markerAttribs(){return{}}setCollapsedStatus(e,t){const i=e.point;i&&(i.collapsed=pick(i.collapsed,(this.mapOptionsToLevel[e.level]||{}).collapsed),t=!1!==(i.visible=t)&&!i.collapsed),e.children.forEach(e=>{this.setCollapsedStatus(e,t)})}drawTracker(){ColumnSeries.prototype.drawTracker.apply(this,arguments),ColumnSeries.prototype.drawTracker.call(this,this.links)}translate(){var e=this,t=e.options;let i=TU.updateRootId(e),s;seriesProto.translate.call(e);var o=e.tree=e.getTree();s=e.nodeMap[i],""===i||s&&s.children.length||(e.setRootNode("",!1),i=e.rootNode,s=e.nodeMap[i]),e.mapOptionsToLevel=getLevelOptions({from:s.level+1,levels:t.levels,to:o.height,defaults:{levelIsConstant:e.options.levelIsConstant,colorByPoint:t.colorByPoint}}),this.setCollapsedStatus(o,!0),e.links=e.getLinks(),e.setTreeValues(o),this.layoutAlgorythm.calculatePositions(e),e.layoutModifier=this.getLayoutModifiers(),this.points.forEach(e=>{this.translateNode(e)}),this.points.forEach(e=>{e.linkToParent&&this.translateLink(e.linkToParent)}),t.colorByPoint||e.setColorRecursive(e.tree)}translateLink(i){var s=i.fromNode,o=i.toNode,r=this.options.link?.lineWidth||0,a=pick(this.options.link?.curveFactor,.5),l=pick(i.options.link?.type,this.options.link?.type,"default");if(s.shapeArgs&&o.shapeArgs){var n=s.shapeArgs.width||0,p=this.chart.inverted,h=crisp((s.shapeArgs.y||0)+(s.shapeArgs.height||0)/2,r),d=crisp((o.shapeArgs.y||0)+(o.shapeArgs.height||0)/2,r);let e=crisp((s.shapeArgs.x||0)+n,r),t=crisp(o.shapeArgs.x||0,r);p&&(e-=n,t+=o.shapeArgs.width||0);var s=o.node.xPosition-s.node.xPosition,c=(i.shapeType="path",Math.abs(t-e)+n),c=c/s-n,s=c*a*(p?-1:1),n=crisp((t+e)/2,r);i.plotX=n,i.plotY=d,i.shapeArgs={d:getLinkPath[l]({x1:e,y1:h,x2:t,y2:d,width:c,offset:s,inverted:p,parentVisible:o.visible,radius:this.options.link?.radius})},i.dlBox={x:(e+t)/2,y:(h+d)/2,height:r,width:0},i.tooltipPos=p?[(this.chart.plotSizeY||0)-i.dlBox.y,(this.chart.plotSizeX||0)-i.dlBox.x]:[i.dlBox.x,i.dlBox.y]}}drawNodeLabels(e){var t=this.mapOptionsToLevel;let i,s;for(const o of e)s=t[o.node.level],i={style:{}},s&&s.dataLabels&&(i=merge(i,s.dataLabels),this.hasDataLabels=()=>!0),o.shapeArgs&&!splat(this.options.dataLabels)[0].style.width&&(i.style.width=o.shapeArgs.width,o.dataLabel&&o.dataLabel.css({width:o.shapeArgs.width+"px"})),o.dlOptions=merge(i,o.options.dataLabels);seriesProto.drawDataLabels.call(this,e)}alignDataLabel(e,t){const i=e.visible;e.visible=!0,super.alignDataLabel.apply(this,arguments),t.animate({opacity:!1===i?0:1},void 0,function(){i||t.hide()}),e.visible=i}drawDataLabels(){this.options.dataLabels&&(this.options.dataLabels=splat(this.options.dataLabels),this.drawNodeLabels(this.points),seriesProto.drawDataLabels.call(this,this.links))}destroy(){if(this.links){for(const e of this.links)e.destroy();this.links.length=0}return seriesProto.destroy.apply(this,arguments)}pointAttribs(e,t){var i=this,s=e&&i.mapOptionsToLevel[e.node.level||0]||{},o=e&&e.options,r=s.states&&s.states[t]||{};e&&(e.options.marker=merge(i.options.marker,s.marker,e.options.marker));const a=pick(r&&r.link&&r.link.color,o&&o.link&&o.link.color,s&&s.link&&s.link.color,i.options.link&&i.options.link.color),l=pick(r&&r.link&&r.link.lineWidth,o&&o.link&&o.link.lineWidth,s&&s.link&&s.link.lineWidth,i.options.link&&i.options.link.lineWidth),n=seriesProto.pointAttribs.call(i,e,t);return e&&(e.isLink&&(n.stroke=a,n["stroke-width"]=l,delete n.fill),e.visible||(n.opacity=0)),n}drawPoints(){TreemapSeries.prototype.drawPoints.apply(this,arguments),ColumnSeries.prototype.drawPoints.call(this,this.links)}translateNode(e){const t=this.chart,i=e.node,s=t.plotSizeY,o=t.plotSizeX,{ax:r,bx:a,ay:l,by:n}=this.layoutModifier,p=r*i.xPosition+a,h=l*i.yPosition+n,d=this.mapOptionsToLevel[i.level]||{},c=merge(this.options.marker,d.marker,e.options.marker),g=c.symbol,m=i.nodeSizeY,k=i.nodeSizeX,y=this.options.reversed,T=i.x=t.inverted?o-k/2-p:p-k/2,v=i.y=y?h-m/2:s-h-m/2,u=pick(e.options.borderRadius,d.borderRadius,this.options.borderRadius),P=symbols[g||"circle"];if(void 0===P?(e.hasImage=!0,e.shapeType="image",e.imageUrl=g.match(/^url\((.*?)\)$/)[1]):e.shapeType="path",!e.visible&&e.linkToParent){var L=e.linkToParent.fromNode;if(L){const f=L.shapeArgs||{},{x:p=0,y:h=0,width:k=0,height:m=0}=f;e.shapeArgs||(e.shapeArgs={}),e.hasImage||extend(e.shapeArgs,{d:P(p,h,k,m,u?{r:u}:void 0)}),extend(e.shapeArgs,{x:p,y:h}),e.plotX=L.plotX,e.plotY=L.plotY}}else e.plotX=T,e.plotY=v,e.shapeArgs={x:T,y:v,width:k,height:m,cursor:e.node.isLeaf?"default":"pointer"},e.hasImage||(e.shapeArgs.d=P(T,v,k,m,u?{r:u}:void 0));e.tooltipPos=t.inverted?[s-v-m/2,o-T-k/2]:[T+k/2,v]}}TreegraphSeries.defaultOptions=merge(TreemapSeries.defaultOptions,TreegraphSeriesDefaults),extend(TreegraphSeries.prototype,{pointClass:TreegraphPoint,NodeClass:TreegraphNode,LinkClass:TreegraphLink}),SeriesRegistry.registerSeriesType("treegraph",TreegraphSeries);export default TreegraphSeries;