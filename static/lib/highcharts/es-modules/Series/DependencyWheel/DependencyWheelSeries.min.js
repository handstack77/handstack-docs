"use strict";import A from"../../Core/Animation/AnimationUtilities.js";const animObject=A["animObject"];import DependencyWheelPoint from"./DependencyWheelPoint.js";import DependencyWheelSeriesDefaults from"./DependencyWheelSeriesDefaults.js";import H from"../../Core/Globals.js";const deg2rad=H["deg2rad"];import SankeyColumnComposition from"../Sankey/SankeyColumnComposition.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{pie:PieSeries,sankey:SankeySeries}=SeriesRegistry.seriesTypes;import U from"../../Core/Utilities.js";const{extend,merge,relativeLength}=U;import SVGElement from"../../Core/Renderer/SVG/SVGElement.js";import TextPath from"../../Extensions/TextPath.js";TextPath.compose(SVGElement);class DependencyWheelSeries extends SankeySeries{animate(e){var t=this;if(!e){const o=animObject(t.options.animation).duration,n=o/2/t.nodes.length;let e=0;for(const r of t.nodes){const s=r.graphic;s&&(s.attr({opacity:0}),setTimeout(()=>{r.graphic&&r.graphic.animate({opacity:1},{duration:n})},n*e++))}for(const i of t.points){const a=i.graphic;!i.isNode&&a&&a.attr({opacity:0}).animate({opacity:1},t.options.animation)}}}createNode(e){const i=super.createNode(e);return i.getSum=()=>i.linksFrom.concat(i.linksTo).reduce((e,t)=>e+t.weight,0),i.offset=t=>{const o=e=>e.fromNode===i?e.toNode:e.fromNode;let n=0,r=i.linksFrom.concat(i.linksTo),s;r.sort((e,t)=>o(e).index-o(t).index);for(let e=0;e<r.length;e++)if(o(r[e]).index>i.index){r=r.slice(0,e).reverse().concat(r.slice(e).reverse()),s=!0;break}s||r.reverse();for(let e=0;e<r.length;e++){if(r[e]===t)return n;n+=r[e].weight}},i}createNodeColumns(){const e=[SankeyColumnComposition.compose([],this)];for(const t of this.nodes)t.column=0,e[0].push(t);return e}getNodePadding(){return this.options.nodePadding/Math.PI}translate(){const e=this,i=e.options,a=2*Math.PI/(e.chart.plotHeight+e.getNodePadding()),t=e.getCenter(),c=(i.startAngle-90)*deg2rad,o=i.borderRadius,n="object"==typeof o?o.radius:o;super.translate();for(const r of this.nodeColumns[0])if(r.sum){const s=r.shapeArgs,d=t[0],l=t[1],h=t[2]/2,m="auto"===i.nodeWidth?20:i.nodeWidth,y=h-relativeLength(m||0,h),g=c+a*(s.y||0),f=c+a*((s.y||0)+(s.height||0));r.angle=g+(f-g)/2,r.shapeType="arc",r.shapeArgs={x:d,y:l,r:h,innerR:y,start:g,end:f,borderRadius:n},r.dlBox={x:d+Math.cos((g+f)/2)*(h+y)/2,y:l+Math.sin((g+f)/2)*(h+y)/2,width:1,height:1};for(const u of r.linksFrom)if(u.linkBase){let r,s;var p=u.linkBase.map((e,t)=>{var e=a*e,o=Math.cos(c+e)*(1+y),n=Math.sin(c+e)*(1+y);return r=i.curveFactor||0,(s=Math.abs(u.linkBase[3-t]*a-e))>Math.PI&&(s=2*Math.PI-s),(s*=y)<y&&(r*=s/y),{x:d+o,y:l+n,cpX:d+(1-r)*o,cpY:l+(1-r)*n}});u.shapeArgs={d:[["M",p[0].x,p[0].y],["A",y,y,0,0,1,p[1].x,p[1].y],["C",p[1].cpX,p[1].cpY,p[2].cpX,p[2].cpY,p[2].x,p[2].y],["A",y,y,0,0,1,p[3].x,p[3].y],["C",p[3].cpX,p[3].cpY,p[0].cpX,p[0].cpY,p[0].x,p[0].y]]}}}}}DependencyWheelSeries.defaultOptions=merge(SankeySeries.defaultOptions,DependencyWheelSeriesDefaults),extend(DependencyWheelSeries.prototype,{orderNodes:!1,getCenter:PieSeries.prototype.getCenter}),DependencyWheelSeries.prototype.pointClass=DependencyWheelPoint,SeriesRegistry.registerSeriesType("dependencywheel",DependencyWheelSeries);export default DependencyWheelSeries;