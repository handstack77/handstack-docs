"use strict";import A from"../../Core/Animation/AnimationUtilities.js";const animObject=A["animObject"];import Color from"../../Core/Color/Color.js";const color=Color["parse"];import ColumnSeriesDefaults from"./ColumnSeriesDefaults.js";import H from"../../Core/Globals.js";const noop=H["noop"];import Series from"../../Core/Series/Series.js";import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";import U from"../../Core/Utilities.js";const{clamp,crisp,defined,extend,fireEvent,isArray,isNumber,merge,pick,objectEach}=U;class ColumnSeries extends Series{animate(t){const o=this,e=this.yAxis,s=e.pos,i=e.reversed,r=o.options,{clipOffset:n,inverted:a}=this.chart,p={},l=a?"translateX":"translateY";let c,h;t&&n?(p.scaleY=.001,h=clamp(e.toPixels(r.threshold),s,s+e.len),a?(h+=i?-Math.floor(n[0]):Math.ceil(n[2]),p.translateX=h-e.len):(h+=i?Math.ceil(n[0]):-Math.floor(n[2]),p.translateY=h),o.clipBox&&o.setClip(),o.group.attr(p)):(c=Number(o.group.attr(l)),o.group.animate({scaleY:1},extend(animObject(o.options.animation),{step:function(t,e){o.group&&(p[l]=c+e.pos*(s-c),o.group.attr(p))}})))}init(t,e){super.init.apply(this,arguments);const o=this;(t=o.chart).hasRendered&&t.series.forEach(function(t){t.type===o.type&&(t.isDirty=!0)})}getColumnMetrics(){const i=this,t=i.options,e=i.xAxis,r=i.yAxis,o=e.options.reversedStacks,s=e.reversed&&!o||!e.reversed&&o,n={};let a,p=0;!1===t.grouping?p=1:i.chart.series.forEach(function(t){var e=t.yAxis,o=t.options;let s;t.type===i.type&&t.reserveSpace()&&r.len===e.len&&r.pos===e.pos&&(o.stacking&&"group"!==o.stacking?(a=t.stackKey,void 0===n[a]&&(n[a]=p++),s=n[a]):!1!==o.grouping&&(s=p++),t.columnIndex=s)});var l=Math.min(Math.abs(e.transA)*(!e.brokenAxis?.hasBreaks&&e.ordinal?.slope||t.pointRange||e.closestPointRange||e.tickInterval||1),e.len),c=l*t.groupPadding,h=(l-2*c)/(p||1),d=Math.min(t.maxPointWidth||e.len,pick(t.pointWidth,h*(1-2*t.pointPadding))),u=(i.columnIndex||0)+(s?1:0);return i.columnMetrics={width:d,offset:(h-d)/2+(c+u*h-l/2)*(s?-1:1),paddedWidth:h,columnCount:p},i.columnMetrics}crispCol(t,e,o,s){var i=this.borderWidth,r=this.chart.inverted;return s=crisp(e+s,i,r)-(e=crisp(e,i,r)),this.options.crisp&&(o=crisp(t+o,i)-(t=crisp(t,i))),{x:t,y:e,width:o,height:s}}adjustForMissingColumns(t,e,r,o){if(!r.isNull&&1<o.columnCount){const a=this.xAxis.series.filter(t=>t.visible).map(t=>t.index);let s=0,i=0;objectEach(this.xAxis.stacking?.stacks,t=>{if("number"==typeof r.x){const e=t[r.x.toString()];if(e){t=e.points[this.index];if(isArray(t)){const o=Object.keys(e.points).filter(t=>!t.match(",")&&e.points[t]&&1<e.points[t].length).map(parseFloat).filter(t=>-1!==a.indexOf(t)).sort((t,e)=>e-t);s=o.indexOf(this.index),i=o.length}}}}),s=this.xAxis.reversed?i-1-s:s;var n=(i-1)*o.paddedWidth+e;t=(r.plotX||0)+n/2-e-s*o.paddedWidth}return t}translate(){const c=this,h=c.chart,d=c.options,t=c.dense=c.closestPointRange*c.xAxis.transA<2,e=c.borderWidth=pick(d.borderWidth,t?0:1),u=c.xAxis,m=c.yAxis,g=d.threshold,f=pick(d.minPointLength,5),y=c.getColumnMetrics(),b=y.width,x=c.pointXOffset=y.offset,C=c.dataMin,v=c.dataMax,S=c.translatedThreshold=m.getThreshold(g);let k=c.barW=Math.max(b,1+2*e);d.pointPadding&&(k=Math.ceil(k)),Series.prototype.translate.apply(c),c.points.forEach(function(t){var e=pick(t.yBottom,S),o=999+Math.abs(e),s=t.plotX||0,o=clamp(t.plotY,-o,m.len+o);let i,r=Math.min(o,e),n=Math.max(o,e)-r,a=b,p=s+x,l=k;f&&Math.abs(n)<f&&(n=f,i=!m.reversed&&!t.negative||m.reversed&&t.negative,isNumber(g)&&isNumber(v)&&t.y===g&&v<=g&&(m.min||0)<g&&(C!==v||(m.max||0)<=g)&&(i=!i,t.negative=!t.negative),r=Math.abs(r-S)>f?e-f:S-(i?f:0)),defined(t.options.pointWidth)&&(a=l=Math.ceil(t.options.pointWidth),p-=Math.round((a-b)/2)),d.centerInCategory&&!d.stacking&&(p=c.adjustForMissingColumns(p,a,t,y)),t.barX=p,t.pointWidth=a,t.tooltipPos=h.inverted?[clamp(m.len+m.pos-h.plotLeft-o,m.pos-h.plotLeft,m.len+m.pos-h.plotLeft),u.len+u.pos-h.plotTop-p-l/2,n]:[u.left-h.plotLeft+p+l/2,clamp(o+m.pos-h.plotTop,m.pos-h.plotTop,m.len+m.pos-h.plotTop),n],t.shapeType=c.pointClass.prototype.shapeType||"roundedRect",t.shapeArgs=c.crispCol(p,t.isNull?S:r,l,t.isNull?0:n)}),fireEvent(this,"afterColumnTranslate")}drawGraph(){this.group[this.dense?"addClass":"removeClass"]("highcharts-dense-data")}pointAttribs(t,e){var o=this.options,s=this.pointAttrToOptions||{},i=s.stroke||"borderColor",s=s["stroke-width"]||"borderWidth";let r,n,a,p=t&&t.color||this.color,l=t&&t[i]||o[i]||p,c=t&&t.options.dashStyle||o.dashStyle,h=t&&t[s]||o[s]||this[s]||0,d=pick(t&&t.opacity,o.opacity,1);t&&this.zones.length&&(n=t.getZone(),p=t.options.color||n&&(n.color||t.nonZonedColor)||this.color,n&&(l=n.borderColor||l,c=n.dashStyle||c,h=n.borderWidth||h)),e&&t&&(a=(r=merge(o.states[e],t.options.states&&t.options.states[e]||{})).brightness,p=r.color||void 0!==a&&color(p).brighten(r.brightness).get()||p,l=r[i]||l,h=r[s]||h,c=r.dashStyle||c,d=pick(r.opacity,d));const u={fill:p,stroke:l,"stroke-width":h,opacity:d};return c&&(u.dashstyle=c),u}drawPoints(t=this.points){const r=this,n=this.chart,a=r.options,p=n.renderer,l=a.animationLimit||250;let c;t.forEach(function(t){var e=t.plotY;let o=t.graphic,s=!!o,i=o&&n.pointCount<l?"animate":"attr";isNumber(e)&&null!==t.y?(c=t.shapeArgs,o&&t.hasNewShapeType()&&(o=o.destroy()),r.enabledDataSorting&&(t.startXPos=r.xAxis.reversed?-(c&&c.width||0):r.xAxis.width),o||(t.graphic=o=p[t.shapeType](c).add(t.group||r.group),o&&r.enabledDataSorting&&n.hasRendered&&n.pointCount<l&&(o.attr({x:t.startXPos}),s=!0,i="animate")),o&&s&&o[i](merge(c)),n.styledMode||o[i](r.pointAttribs(t,t.selected&&"select")).shadow(!1!==t.allowShadow&&a.shadow),o&&(o.addClass(t.getClassName(),!0),o.attr({visibility:t.visible?"inherit":"hidden"}))):o&&(t.graphic=o.destroy())})}drawTracker(t=this.points){function e(t){const e=i?.getPointFromEvent(t);i&&e&&o.options.enableMouseTracking&&(i.isDirectTouch=!0,e.onMouseOver(t))}const o=this,s=o.chart,i=s.pointer;let r;t.forEach(function(e){r=isArray(e.dataLabels)?e.dataLabels:e.dataLabel?[e.dataLabel]:[],e.graphic&&(e.graphic.element.point=e),r.forEach(function(t){(t.div||t.element).point=e})}),o._hasTracking||(o.trackerGroups.forEach(function(t){o[t]&&(o[t].addClass("highcharts-tracker").on("mouseover",e).on("mouseout",function(t){i?.onTrackerMouseOut(t)}).on("touchstart",e),!s.styledMode&&o.options.cursor&&o[t].css({cursor:o.options.cursor}))}),o._hasTracking=!0),fireEvent(this,"afterDrawTracker")}remove(){const e=this,t=e.chart;t.hasRendered&&t.series.forEach(function(t){t.type===e.type&&(t.isDirty=!0)}),Series.prototype.remove.apply(e,arguments)}}ColumnSeries.defaultOptions=merge(Series.defaultOptions,ColumnSeriesDefaults),extend(ColumnSeries.prototype,{directTouch:!0,getSymbol:noop,negStacks:!0,trackerGroups:["group","dataLabelsGroup"]}),SeriesRegistry.registerSeriesType("column",ColumnSeries);export default ColumnSeries;