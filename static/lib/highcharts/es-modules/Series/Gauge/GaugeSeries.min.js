"use strict";import GaugePoint from"./GaugePoint.js";import H from"../../Core/Globals.js";const noop=H["noop"];import SeriesRegistry from"../../Core/Series/SeriesRegistry.js";const{series:Series,seriesTypes:{column:ColumnSeries}}=SeriesRegistry;import U from"../../Core/Utilities.js";const{clamp,isNumber,extend,merge,pick,pInt,defined}=U;class GaugeSeries extends Series{translate(){const e=this,p=e.yAxis,c=e.options,h=p.center;e.generatePoints(),e.points.forEach(e=>{var r=merge(c.dial,e.dial),t=pInt(r.radius)*h[2]/200,o=pInt(r.baseLength)*t/100,a=pInt(r.rearLength)*t/100,i=r.baseWidth,s=r.topWidth;let n=c.overshoot,d=p.startAngleRad+p.translate(e.y,void 0,void 0,void 0,!0);!isNumber(n)&&!1!==c.wrap||(n=isNumber(n)?n/180*Math.PI:0,d=clamp(d,p.startAngleRad-n,p.endAngleRad+n)),d=180*d/Math.PI,e.shapeType="path";r=r.path||[["M",-a,-i/2],["L",o,-i/2],["L",t,-s/2],["L",t,s/2],["L",o,i/2],["L",-a,i/2],["Z"]];e.shapeArgs={d:r,translateX:h[0],translateY:h[1],rotation:d},e.plotX=h[0],e.plotY=h[1],defined(e.y)&&p.max-p.min&&(e.percentage=(e.y-p.min)/(p.max-p.min)*100)})}drawPoints(){const i=this,s=i.chart,e=i.yAxis.center,r=i.pivot,n=i.options,t=n.pivot,d=s.renderer;i.points.forEach(e=>{const r=e.graphic,t=e.shapeArgs,o=t.d,a=merge(n.dial,e.dial);r?(r.animate(t),t.d=o):e.graphic=d[e.shapeType](t).addClass("highcharts-dial").add(i.group),s.styledMode||e.graphic[r?"animate":"attr"]({stroke:a.borderColor,"stroke-width":a.borderWidth,fill:a.backgroundColor})}),r?r.animate({translateX:e[0],translateY:e[1]}):t&&(i.pivot=d.circle(0,0,t.radius).attr({zIndex:2}).addClass("highcharts-pivot").translate(e[0],e[1]).add(i.group),s.styledMode||i.pivot.attr({fill:t.backgroundColor,stroke:t.borderColor,"stroke-width":t.borderWidth}))}animate(e){const t=this;e||t.points.forEach(e=>{const r=e.graphic;r&&(r.attr({rotation:180*t.yAxis.startAngleRad/Math.PI}),r.animate({rotation:e.shapeArgs.rotation},t.options.animation))})}render(){this.group=this.plotGroup("group","series",this.visible?"inherit":"hidden",this.options.zIndex,this.chart.seriesGroup),Series.prototype.render.call(this),this.group.clip(this.chart.clipRect)}setData(e,r){Series.prototype.setData.call(this,e,!1),this.processData(),this.generatePoints(),pick(r,!0)&&this.chart.redraw()}hasData(){return!!this.points.length}}GaugeSeries.defaultOptions=merge(Series.defaultOptions,{dataLabels:{borderColor:"#cccccc",borderRadius:3,borderWidth:1,crop:!1,defer:!1,enabled:!0,verticalAlign:"top",y:15,zIndex:2},dial:{backgroundColor:"#000000",baseLength:"70%",baseWidth:3,borderColor:"#cccccc",borderWidth:0,radius:"80%",rearLength:"10%",topWidth:1},pivot:{radius:5,borderWidth:0,borderColor:"#cccccc",backgroundColor:"#000000"},tooltip:{headerFormat:""},showInLegend:!1}),extend(GaugeSeries.prototype,{angular:!0,directTouch:!0,drawGraph:noop,drawTracker:ColumnSeries.prototype.drawTracker,fixedBox:!0,forceDL:!0,noSharedTooltip:!0,pointClass:GaugePoint,trackerGroups:["group","dataLabelsGroup"]}),SeriesRegistry.registerSeriesType("gauge",GaugeSeries);export default GaugeSeries;