---
sidebar_position: 0
---

# 게시판 프로젝트 시작하기

처음 개발을 시작할 때 게시판 만들기는 가장 기본적인 프로젝트로 권장됩니다. 특히 게시판은 웹 개발에 필요한 여러 주요 요소를 포괄하기 때문에 게시판 예제가 다음과 같이 HandStack 기반 개발의 핵심 개념을 이해하고 실습하는 데 매우 유용합니다.

* **웹 페이지 화면 구성**: 게시판을 만들면서 HandStack에서 기본 제공되는 tabler CSS Framework 기반의 웹 페이지의 레이아웃과 디자인을 배울 수 있습니다.
* **서버 데이터 통신 처리**: 게시판은 사용자의 요청을 서버로 전송하고, 서버의 응답을 처리하는 HandStack의 거래 과정을 이해하는 데 도움이 됩니다.
* **데이터베이스 처리**: 게시글을 작성, 읽기, 수정, 삭제하는 기능을 구현하면서 데이터베이스와의 상호작용을 Contracts로 설정하는 방법을 배울 수 있습니다.

> IT 분야에서 요즘 대세로 사용 중인 Copilot(AI) 으로 게시판을 만드는 데 참고 자료로 활용해서 만들어 보겠습니다. 여기에서는 Microsoft Copilot (ChatGPT v4)를 사용합니다.

## 사용자 스토리 만들기

게시판 프로젝트를 위해 제일 먼저 해야 할 것은 "페르소나 정하기" 입니다. IT 프로젝트 기획에서 페르소나를 정하는 이유는 다음과 같습니다.

* 사용자의 이해: 페르소나를 만들어 놓으면 사용자들의 요구 사항, 경험, 행동, 목표 등을 이해하는 데 있어서 도움이 됩니다.
* 소통의 효율성: 프로젝트의 페르소나를 설정하면 조직원들이 공통의 타깃을 이해하고 커뮤니케이션을 효율적으로 진행할 수 있다는 이점도 있습니다.

> 게시판 프로젝트의 사용자는 "개발자" 본인 1명 입니다.

그래서 게시판의 기능은 로그인/권한 기능, 파일 첨부 등등 다양한 고급 기능은 고려하지 않습니다. 대신 개발자가 원하는 게시판의 주요 기능을 다음과 같이 설정했습니다.

* 개발자가 작성하는 글은 글꼴, 컬러, 크기, 서식을 지정해야 하며 이미지를 보여 줄 수 있어야 합니다.
* 개발자가 게시 글을 작성할 때 "정보, 강좌, 소식"과 같이 분류하는 글을 작성합니다. 글에 대한 그룹과 조회 기능의 편의를 위해 필요합니다.
* 개발자가 자신의 글을 조회하고 바로 수정 또는 삭제 할 수 있어야 합니다. 게시 글 관리를 위해 시간 절약을 위해 화면 전환을 최소화 하기를 원합니다.
* 개발자가 글을 조회할 때 "분류, 기간, 제목"을 기준으로 조건 검색이 가능 해야합니다. 이때 기간은 조회 성능을 효율적으로 관리하기 위해 최근 1달을 오늘 날짜를 기준으로 자동 설정됩니다.
* 개발자가 원하는 게시글을 빠르게 찾기 위해 조회 한 글 목록에서 "분류, 기간, 제목, 입력시간"을 기준으로 순차, 역순으로 정렬 해야합니다.

## 화면/기능 생각하기

"개발자" 사용자가 원하는 게시판의 주요 기능에 필요한 화면과 가능을 간단하게 정리하면 다음과 같습니다.

* 게시글 목록 화면
  * "분류, 기간, 제목" 기준 조회 필터 기능
  * "분류, 기간, 제목, 입력시간" 기준 글 목록 정렬 기능
  * 게시글 등록 화면 호출
  * 기존 게시글 조회 화면 호출
* 신규 게시글 등록 화면
  * 글꼴, 컬러, 크기, 서식, 이미지를 표시할 수 있는 편집기 기능
  * 제목, 본문, 작성자 항목을 입력하는 기능
* 기존 게시글 편집 및 삭제 화면
  * 게시글 정보를 조회하는 기능
  * 글꼴, 컬러, 크기, 서식, 이미지를 표시할 수 있는 편집기 기능
  * 제목, 본문, 작성자 항목을 편집하는 기능
  * 경고 팝업 후 게시글을 삭제하는 기능

### 작업 항목 분류하기

만들어야 할 화면의 작업 항목을 관리하기 위해 다음과 같이 항목 ID로 분류합니다.

```
BOD: 게시판 프로젝트 ID
└-BOD010: 게시글 목록 ID
└-BOD011: 게시글 신규 등록 ID
└-BOD012: 게시글 편집 및 삭제 ID
```

이 항목 ID로 게시판에 필요한 소스의 디렉토리와 파일에 대한 구성은 다음과 같습니다.

```
contracts
├─dbclient
│  └─HDS
│      └─BOD
│          ├─BOD010.xml
│          ├─BOD011.xml
│          └─BOD012.xml
├─transact
│  └─HDS
│      └─BOD
│          ├─BOD010.json
│          ├─BOD011.json
│          └─BOD012.json
└─wwwroot
   └─BOD
       ├─BOD010.html
       ├─BOD010.js
       ├─BOD011.html
       ├─BOD011.js
       └─BOD012.html
       └─BOD012.js
```

## Copilot(AI) 으로 관리 데이터 생각 정리하기

HandStack은 공식적으로 SQL Server, Oracle, MySQL/MariaDB, PostgreSQL, SQLite 데이터베이스를 지원합니다. 게시판 프로젝트에서 사용하는 데이터베이스는 SQLite 입니다. SQLite는 개발자에게 다음과 같은 장점을 제공합니다.

* 최신 ANSI SQL 준수: 표준 SQL 문법을 사용 가능합니다. 데이터베이스의 고유 기능을 제외한 호환성이 높은 SQL을 재사용 가능합니다.
* 서버가 필요 없습니다: SQLite는 서버 프로세스를 시작, 중지 또는 구성할 필요가 없습니다.
* 간단한 데이터베이스 파일: SQLite 데이터베이스는 단일 일반 디스크 파일로, 어느 디렉토리에나 저장할 수 있습니다.

게시판을 만드는 데 필요한 데이터 항목을 Copilot(AI)에게 다음과 같이 활용해서 만들어 보겠습니다.

> 동일한 프롬프트 스크립트여도 로그인 계정의 작업 이력에 따라 다른 결과가 나올수 있고 출력 결과는 검증되지 않았기 때문에 참고용으로 사용 해야 합니다.

### 테이블 및 DDL 쿼리 작성 도움받기

게시판 테이블 및 쿼리 작성 스크립트와 결과는 다음과 같습니다.

---

```
간단한 분류 게시판 데이터베이스 테이블 정보 (컬럼명, 데이터 타입, 설명)를 SQLite 기준으로 MarkDown 문법으로 만들어줘. 그리고 실행 결과에서 테이블을 생성 하는 ddl 문법에서 ID를 자동 증가 키 컬럼으로 구성하고 기존 테이블이 없으면 CREATE 하는 예제를 알려줘
```
---

SQLite 기준으로 분류 게시판 데이터베이스 테이블을 만들었습니다. 아래는 간단한 분류 게시판 테이블의 구조입니다:

| 컬럼명 | 데이터 타입 | 설명 |
|--------|-------------|------|
| ID | INTEGER | 게시글의 고유 번호 (기본 키) |
| Category | TEXT | 게시글의 카테고리 |
| Title | TEXT | 게시글의 제목 |
| Content | TEXT | 게시글의 내용 |
| Author | TEXT | 게시글 작성자의 이름 |
| DatePosted | TEXT | 게시글이 작성된 날짜와 시간 |

이 테이블은 게시판의 기본적인 기능을 수행할 수 있습니다. 필요에 따라 추가적인 컬럼을 추가하거나 수정할 수 있습니다. 이 정보를 CSV 파일에 입력하면 SQLite 기준의 분류 게시판 데이터베이스 테이블 정보를 CSV 형식으로 만들 수 있습니다. 

참고로, SQLite에서 테이블을 생성하는 SQL 쿼리는 다음과 같습니다:

```sql
CREATE TABLE IF NOT EXISTS Board (
  ID INTEGER PRIMARY KEY AUTOINCREMENT,
  Category TEXT,
  Title TEXT,
  Content TEXT,
  Author TEXT,
  DatePosted TEXT
);
```
---

### 게시판 CRUD 쿼리 작성 도움받기

```
위의 Board 테이블 결과에서 SQLite 기준으로 CRUD 쿼리를 만들어줘
```

---

네, Board 테이블에 대한 CRUD(Create, Read, Update, Delete) 쿼리를 SQLite 기준으로 작성해드리겠습니다.

1. **Create (생성)**: 새로운 게시글을 추가합니다.
```sql
INSERT INTO Board (ID, Category, Title, Content, Author, DatePosted)
VALUES (1, '카테고리', '제목', '내용', '작성자', datetime('now'));
```

2. **Read (조회)**: 게시글을 조회합니다.
```sql
-- 모든 게시글 조회
SELECT * FROM Board;

-- 특정 ID의 게시글 조회
SELECT * FROM Board WHERE ID = 1;

-- 특정 카테고리의 게시글 조회
SELECT * FROM Board WHERE Category = '카테고리';
```

3. **Update (수정)**: 기존 게시글을 수정합니다.
```sql
UPDATE Board
SET Title = '새 제목', Content = '새 내용'
WHERE ID = 1;
```

4. **Delete (삭제)**: 게시글을 삭제합니다.
```sql
DELETE FROM Board WHERE ID = 1;
```

위의 쿼리들은 간단한 예시이며, 실제 사용 시에는 필요에 따라 적절히 수정하여 사용하시면 됩니다. 또한, 데이터베이스 작업을 할 때는 항상 주의를 기울여야 합니다. 특히, `UPDATE`와 `DELETE` 쿼리는 신중하게 사용해야 합니다. 잘못 사용하면 예상치 못한 데이터 손실이 발생할 수 있습니다.

---

> AI의 도움으로 게시판을 만들고 관리하기 위해 참고용 SQL이 충분히 만들어져 있어 이후 예제에 활용 하겠습니다.

## 테이블 DDL 및 CRUD 쿼리 적용하기

생성된 쿼리를 기능에 맞게 적절하게 관리하기 위해 다음과 같이 간단한 규칙을 만들어 기능 ID 값을 생성합니다. 여기에서 명령구분은 "D" 만 사용합니다.

| 명령구분 | 명칭 | 설명 |
| --- | --- | --- |
| D | Database  | 데이터베이스 명령 |
| F | Function  | 서버 함수 실행 |
| A | API  | RESTApi 호출 |
| T | Task  | 배치 작업 |

| 기능명 | 명칭 | 설명 |
| --- | --- | --- |
| I | INSERT  | 단순 INSERT |
| U | UPDATE  | 단순 UPDATE |
| D | DELETE  | 단순 DELETE |
| G | GET ROW | 단일 데이터를 조회하는 경우 |
| L | LIST    | 목록 데이터를 조회하는 경우 |
| M | MODIFY  | CRUD 복합 |
| Z | MANAGED  | 관리 목적의 실행 |

> 명령구분 1자리 + 기능 1자리 + 순번 2자리 = "LD01"

이 규칙은 wwwroot, transact, dbclient 모듈등등 모든 분야에 동일하게 적용합니다. 이제 데이터베이스 쿼리를 다음과 같이 적용할 수 있습니다.

### BOD010.xml 게시글 목록 쿼리

```xml
<?xml version="1.0" encoding="UTF-8"?>
<mapper xmlns="contract.xsd">
  <header>
    <application>HDS</application>
    <project>BOD</project>
    <transaction>BOD010</transaction>
    <datasource>DB01</datasource>
    <use>Y</use>
    <desc>게시판 Board 테이블 DDL 및 게시글 조회</desc>
  </header>
  <commands>
        <statement id="ZD01" seq="0" use="Y" timeout="0" desc="Board 테이블 DDL 및 초기 데이터 입력 적용">
            <![CDATA[
CREATE TABLE IF NOT EXISTS Board (
  ID INTEGER PRIMARY KEY AUTOINCREMENT,
  Category TEXT,
  Title TEXT,
  Content TEXT,
  Author TEXT,
  DatePosted TEXT
);

DELETE FROM Board;

INSERT INTO Board (Category, Title, Content, Author, DatePosted) VALUES ('정보', '정보 게시물 제목1', '정보 게시물 내용1', '개발자', datetime('now', 'localtime'));
INSERT INTO Board (Category, Title, Content, Author, DatePosted) VALUES ('강좌', '강좌 게시물 제목1', '강좌 게시물 내용1', '개발자', datetime('now', 'localtime'));
INSERT INTO Board (Category, Title, Content, Author, DatePosted) VALUES ('소식', '소식 게시물 제목1', '소식 게시물 내용1', '개발자', datetime('now', 'localtime'));
......
INSERT INTO Board (Category, Title, Content, Author, DatePosted) VALUES ('소식', '소식 게시물 제목30', '소식 게시물 내용30', '개발자', datetime('now', 'localtime'));
            ]]>
        </statement>
        
        <statement id="LD01" seq="0" use="Y" timeout="0" desc="분류, 기간, 제목을 기준으로 게시글 조회">
            <![CDATA[
SELECT B.ID
    , B.Category
    , B.Title
    , B.Author
    , B.DatePosted
FROM Board B 
WHERE B.DatePosted BETWEEN @StartDate AND @EndDate
    AND CASE WHEN @Category = '' THEN @Category ELSE B.Category = @Category
    AND CASE WHEN @Title = '' THEN @Title ELSE B.Title = @Title;
            ]]>
            <param id="@Category" type="String" length="-1" value="" />
            <param id="@Title" type="String" length="-1" value="" />
            <param id="@StartDate" type="String" length="-1" value="" />
            <param id="@EndDate" type="String" length="-1" value="" />
        </statement>
  </commands>
</mapper>
```

### BOD011.xml 게시글 신규 등록 쿼리

```xml
<?xml version="1.0" encoding="UTF-8"?>
<mapper xmlns="contract.xsd">
  <header>
    <application>HDS</application>
    <project>BOD</project>
    <transaction>BOD011</transaction>
    <datasource>DB01</datasource>
    <use>Y</use>
    <desc>게시글 신규 등록</desc>
  </header>
  <commands>
        <statement id="ID01" seq="0" use="Y" timeout="0" desc="게시글 입력">
            <![CDATA[
INSERT INTO Board
(
    Category
    , Title
    , Content
    , Author
    , DatePosted
) 
VALUES
(
    Category
    , Title
    , Content
    , Author
    , datetime('now', 'localtime')
);
            ]]>
            <param id="@Category" type="String" length="-1" value="" />
            <param id="@Title" type="String" length="-1" value="" />
            <param id="@Content" type="String" length="-1" value="" />
            <param id="@Author" type="String" length="-1" value="" />
        </statement>
  </commands>
</mapper>
```

### BOD012.xml 게시글 편집 및 삭제 쿼리

```xml
<?xml version="1.0" encoding="UTF-8"?>
<mapper xmlns="contract.xsd">
  <header>
    <application>HDS</application>
    <project>BOD</project>
    <transaction>BOD012</transaction>
    <datasource>DB01</datasource>
    <use>Y</use>
    <desc>게시글 편집 및 삭제</desc>
  </header>
  <commands>
        <statement id="GD01" seq="0" use="Y" timeout="0" desc="게시글 조회">
            <![CDATA[
SELECT B.Category
    , B.Title
    , B.Content
    , B.Author
    , B.DatePosted
FROM Board B 
WHERE B.ID = @ID;
            ]]>
            <param id="@ID" type="String" length="-1" value="" />
        </statement>

        <statement id="UD01" seq="0" use="Y" timeout="0" desc="게시글 변경" native="Y" modified="2023-09-25 00:00:00">
            <![CDATA[
UPDATE Board
SET Category = @Category
    , Title = @Title
    , Content = @Content
    , Author = @Author
WHERE ID = @ID;
            ]]>
            <param id="@ID" type="String" length="-1" value="" />
            <param id="@Category" type="String" length="-1" value="" />
            <param id="@Title" type="String" length="-1" value="" />
            <param id="@Content" type="String" length="-1" value="" />
            <param id="@Author" type="String" length="-1" value="" />
        </statement>

        <statement id="DD01" seq="0" use="Y" timeout="0" desc="게시글 삭제">
            <![CDATA[
DELETE FROM Board
WHERE ID = @ID;
            ]]>
            <param id="@ID" type="String" length="-1" value="" />
        </statement>
  </commands>
</mapper>
```

데이터베이스 쿼리는 XML로 관리하며 MyBatis와 유사하게 SQL 쿼리와 저장 프로시저 호출을 위한 매개변수 매핑을 직접 제어할 수 있게 해줍니다. 이 방식은 직접적인 SQL 제어로 복잡한 쿼리나 성능 튜닝에 유용합니다. HandStack에서는 추가 기능으로 유연한 SQL 작성을 위한 동적 쿼리처럼 복잡한 쿼리 처리나 전처리 쿼리, 보상 거래 실행등등 다양한 시나리오에 대응 가능합니다.

정리하면 게시판을 위한 쿼리 구성을 다음과 같이 3개의 파일에 6개의 쿼리로 정리했습니다.

```
contracts
└─dbclient
   └─HDS
       └─BOD
           ├─BOD010.xml: ZD01, LD01
           ├─BOD011.xml: ID01
           └─BOD012.xml: GD01, UD01, DD01
```

## 게시판 거래 요청 관리하기

HandStack 기반의 화면에서 모든 요청은 단일 Endpoint으로 호출됩니다. 그래서 요청 거래가 적절하게 들어오는 지 검증을 하기 위한 설정을 정의합니다.

### BOD010.json 게시글 목록 거래

```json
{
    "ApplicationID": "HDS",
    "ProjectID": "BOD",
    "TransactionID": "BOD010",
    "Comment": "게시글 목록 거래",
    "Services": [
        {
            "ServiceID": "ZD01",
            "Authorize": false,
            "ReturnType": "Json",
            "CommandType": "D",
            "TransactionScope": false,
            "Inputs": [
                {
                    "ModelID": "Dynamic",
                    "Fields": [],
                    "TestValues": [],
                    "DefaultValues": [],
                    "Type": "Row",
                    "BaseFieldMappings": [],
                    "ParameterHandling": "Rejected"
                }
            ],
            "Outputs": []
        },
        {
            "ServiceID": "LD01",
            "Authorize": false,
            "ReturnType": "Json",
            "CommandType": "D",
            "TransactionScope": false,
            "Inputs": [
                {
                    "ModelID": "Dynamic",
                    "Fields": [],
                    "TestValues": [],
                    "DefaultValues": [],
                    "Type": "Row",
                    "BaseFieldMappings": [],
                    "ParameterHandling": "Rejected"
                }
            ],
            "Outputs": [
                {
                    "ModelID": "Dynamic",
                    "Fields": [
                    ],
                    "Type": "Grid"
                }
            ]
        }
    ],
    "Models": []
}

```

### BOD011.json 게시글 신규 등록 거래

```json
{
    "ApplicationID": "HDS",
    "ProjectID": "BOD",
    "TransactionID": "BOD011",
    "Comment": "게시글 신규 등록 거래",
    "Services": [
        {
            "ServiceID": "ID01",
            "Authorize": false,
            "ReturnType": "Json",
            "CommandType": "D",
            "TransactionScope": false,
            "Inputs": [
                {
                    "ModelID": "Dynamic",
                    "Fields": [],
                    "TestValues": [],
                    "DefaultValues": [],
                    "Type": "Row",
                    "BaseFieldMappings": [],
                    "ParameterHandling": "Rejected"
                }
            ],
            "Outputs": []
        }
    ],
    "Models": []
}

```

### BOD012.json 게시글 편집 및 삭제 거래

```json
{
    "ApplicationID": "HDS",
    "ProjectID": "BOD",
    "TransactionID": "BOD012",
    "Comment": "게시글 편집 및 삭제 거래",
    "Services": [
        {
            "ServiceID": "GD01",
            "Authorize": false,
            "ReturnType": "Json",
            "CommandType": "D",
            "TransactionScope": false,
            "Inputs": [
                {
                    "ModelID": "Dynamic",
                    "Fields": [],
                    "TestValues": [],
                    "DefaultValues": [],
                    "Type": "Row",
                    "BaseFieldMappings": [],
                    "ParameterHandling": "Rejected"
                }
            ],
            "Outputs": [
                {
                    "ModelID": "Dynamic",
                    "Fields": [
                    ],
                    "Type": "Form"
                }
            ]
        },
        {
            "ServiceID": "UD01",
            "Authorize": false,
            "ReturnType": "Json",
            "CommandType": "D",
            "TransactionScope": false,
            "Inputs": [
                {
                    "ModelID": "Dynamic",
                    "Fields": [],
                    "TestValues": [],
                    "DefaultValues": [],
                    "Type": "Row",
                    "BaseFieldMappings": [],
                    "ParameterHandling": "Rejected"
                }
            ],
            "Outputs": []
        },
        {
            "ServiceID": "UD01",
            "Authorize": false,
            "ReturnType": "Json",
            "CommandType": "D",
            "TransactionScope": false,
            "Inputs": [
                {
                    "ModelID": "Dynamic",
                    "Fields": [],
                    "TestValues": [],
                    "DefaultValues": [],
                    "Type": "Row",
                    "BaseFieldMappings": [],
                    "ParameterHandling": "Rejected"
                }
            ],
            "Outputs": []
        }
    ],
    "Models": []
}

```

정리하면 게시판을 위한 거래 구성을 다음과 같이 3개의 파일에 6개의 요청/응답 설정으로 정리했습니다.

> 이 규칙을 벗어나는 요청이 들어올 경우 HandStack 에서는 잘못된 요청 처리 응답을 반환합니다.

```
contracts
└─transact
   └─HDS
       └─BOD
           ├─BOD010.json
               ZD01 - 단일값 요청/응답 없음
               LD01 - 단일값 요청/Grid 목록값 응답
           ├─BOD011.json
               ID01 - 단일값 요청/응답 없음
           └─BOD012.json
               GD01 - 단일값 요청/Form 단일값 응답
               UD01 - 단일값 요청/응답 없음
               DD01 - 단일값 요청/응답 없음
```

## 게시판 화면 개발하기

HandStack 화면은 오픈소스인 Bootstrap 기반의 Tabler CSS Framework를 기본 번들로 사용합니다. 필요에 따라 간단한 설정 변경으로 다른 CSS Framework을 사용 할 수 있습니다.

다음은 예제에 사용된 레이아웃과 디자인에 대한 주요 참고자료 입니다. 여기에 있는 예제를 화면 개발에 그대로 사용하세요.

* [시작하기](https://tabler.io/docs/getting-started)
* [미리보기](https://tabler.io/preview)
* [아이콘 찾기](https://tabler.io/icons)


HandStack 의 화면은 syn.loader.js 자바스크립트를 통해 필요한 리소스를 개발/운영 환경에 따라 자동으로 불러옵니다. 그래서 화면에 필요한 기본 HTML 구성은 다음과 같습니다.

```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body style="visibility: hidden;">
  <form autocomplete="off" id="form1" syn-datafield="MainForm">
    <div class="page">
      <div class="page-wrapper">
        <div class="page-body">
          <div class="container-xl">
            <!-- 디자인 서식 -->
          </div>
        </div>
      </div>
    </div>
  </form>
  <script src="/js/syn.loader.js"></script>
</body>
</html>

```

```
contracts
└─wwwroot
   └─BOD
       ├─BOD010.html
       ├─BOD010.js
       ├─BOD011.html
       ├─BOD011.js
       └─BOD012.html
       └─BOD012.js
```

## 게시판 화면 데모 실행하기

웹 브라우저로 바로 결과를 확인하려면 다음 주소를 확인하세요. https://handstack.kr/view/BOD/BOD010.html

### GitHub 에서 데모 소스 확인하기

"개발자" 사용자가 원하는 게시판의 주요 기능의 모든 소스는 다음과 같습니다.

dbclient > HDS > BOD

* [BOD010.xml](https://github.com/handstack77/handstack/blob/master/2.Modules/wwwroot/Contracts/dbclient/HDS/BOD/BOD010.xml)
* [BOD011.xml](https://github.com/handstack77/handstack/blob/master/2.Modules/wwwroot/Contracts/dbclient/HDS/BOD/BOD011.xml)
* [BOD012.xml](https://github.com/handstack77/handstack/blob/master/2.Modules/wwwroot/Contracts/dbclient/HDS/BOD/BOD012.xml)

transact > HDS > BOD
* [BOD010.json](https://github.com/handstack77/handstack/blob/master/2.Modules/wwwroot/Contracts/transact/HDS/BOD/BOD010.json)
* [BOD011.json](https://github.com/handstack77/handstack/blob/master/2.Modules/wwwroot/Contracts/transact/HDS/BOD/BOD011.json)
* [BOD012.json](https://github.com/handstack77/handstack/blob/master/2.Modules/wwwroot/Contracts/transact/HDS/BOD/BOD012.json)

wwwroot > BOD
* [BOD010.html](https://github.com/handstack77/handstack/blob/master/2.Modules/wwwroot/wwwroot/view/BOD/BOD010.html)
* [BOD010.js](https://github.com/handstack77/handstack/blob/master/2.Modules/wwwroot/wwwroot/view/BOD/BOD010.js)
* [BOD011.html](https://github.com/handstack77/handstack/blob/master/2.Modules/wwwroot/wwwroot/view/BOD/BOD011.html)
* [BOD011.js](https://github.com/handstack77/handstack/blob/master/2.Modules/wwwroot/wwwroot/view/BOD/BOD011.js)
* [BOD012.html](https://github.com/handstack77/handstack/blob/master/2.Modules/wwwroot/wwwroot/view/BOD/BOD012.html)
* [BOD012.js](https://github.com/handstack77/handstack/blob/master/2.Modules/wwwroot/wwwroot/view/BOD/BOD012.js)

이와 같이 게시판 프로젝트 예제를 보며 텍스트 편집기 만으로 만들수 있고 자유롭게 배포할 수 있는 간소화된 방법을 확인 했습니다. 이 예제는 HelloWorld 수준의 간단한 예제이며 HandStack은 기업에 필요한 다양한 시나리오의 요구사항에 대응하는 기능들을 제공합니다.

HandStack은 순수한 웹 표준 기술 (HTML, Javascript)과 SQL 만으로 비즈니스 앱을 개발하고 운영할 수 있는 솔루션입니다. 이러한 개발 및 운영 절차는 기존의 Java, ASP.NET, PHP, Node.js, Go, Python 등등 다양한 개발 기술들과 비교 하여 개발자들의 개발 지식 학습 및 운영 비용 절감에 분명한 장점을 제공합니다.